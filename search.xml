<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kubectl常用命令</title>
    <url>/knowledge-base/2022/09/13/kubectl-study/</url>
    <content><![CDATA[<div class="note primary"><p>详解kubectl常用命令，熟悉常规操作</p>
</div>
<span id="more"></span>

<h1 id="kubectl-常用命令"><a href="#kubectl-常用命令" class="headerlink" title="kubectl 常用命令"></a>kubectl 常用命令</h1><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 要获取用于部署的Yaml（服务，窗格，机密等）：</span><br><span class="line">kubectl get deploy deploymentname -o yaml --export</span><br><span class="line"></span><br><span class="line">从kubernetes下载yaml的语法</span><br><span class="line">kubectl get [resource type] -n [namespace] [resource Name] -o yaml &gt; [New file name]</span><br><span class="line"></span><br><span class="line">从运行的pod创建yaml文件：</span><br><span class="line">kubectl get po -n nginx nginx-deployment-755cfc7dcf-5s7j8 -o yaml &gt; podDetail.yaml</span><br><span class="line"></span><br><span class="line">从运行的Pod创建copysetyaml文件：</span><br><span class="line">kubectl get rs -n nginx -o yaml &gt; latestReplicaSet.yaml</span><br><span class="line"></span><br><span class="line">从运行的pod创建部署yaml文件：</span><br><span class="line">kubectl get deploy -n nginx -o yaml &gt; latestDeployement.yaml</span><br><span class="line"></span><br><span class="line">使用此命令获取服务的Yaml格式</span><br><span class="line">kubectl get service servicename -n &lt;namespace&gt; -o yaml</span><br><span class="line"></span><br><span class="line">您也可以将其放入某个文件中</span><br><span class="line">kubectl get service servicename -n &lt;namespace&gt; -o yaml &gt; service.yaml</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>redis.conf 配置文件介绍</title>
    <url>/knowledge-base/2018/08/25/redis-conf/</url>
    <content><![CDATA[<div class="note warning"><p>在Redis的使用过程，除了知道对Redis五种数据类型的操作方法之外，最主要额就是对redis.conf进行配置了,下面整理出redis.conf中常见的一些配置介绍。 </p>
</div>

<span id="more"></span>

<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="redis-conf-配置项说明如下："><a href="#redis-conf-配置项说明如下：" class="headerlink" title="redis.conf 配置项说明如下："></a>redis.conf 配置项说明如下：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1: Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line">    daemonize no</span><br><span class="line"></span><br><span class="line">2: 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class="line">    pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line">3: 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，</span><br><span class="line">因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class="line">  port 6379</span><br><span class="line"></span><br><span class="line">4: 绑定的主机地址</span><br><span class="line">  bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">5: 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line">  timeout 300</span><br><span class="line"></span><br><span class="line">6: 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，</span><br><span class="line">默认为verbose</span><br><span class="line">  loglevel verbose</span><br><span class="line"></span><br><span class="line">7: 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志</span><br><span class="line">记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line">  logfile stdout</span><br><span class="line"></span><br><span class="line">8: 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line">  databases 16</span><br><span class="line"></span><br><span class="line">9: 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">  save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">  Redis默认配置文件中提供了三个条件：</span><br><span class="line">  save 900 1</span><br><span class="line">  save 300 10</span><br><span class="line">  save 60 10000</span><br><span class="line">  分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line"></span><br><span class="line">10: 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，</span><br><span class="line">可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line">  rdbcompression yes</span><br><span class="line"></span><br><span class="line">11: 指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line">  dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">12: 指定本地数据库存放目录</span><br><span class="line">  dir ./</span><br><span class="line"></span><br><span class="line">13: 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line">  slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">14: 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line">  masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">15: 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line">  requirepass foobared</span><br><span class="line"></span><br><span class="line">16: 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，</span><br><span class="line">如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端</span><br><span class="line">返回max number of clients reached错误信息</span><br><span class="line">  maxclients 128</span><br><span class="line"></span><br><span class="line">17: 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，</span><br><span class="line">当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，</span><br><span class="line">Value会存放在swap区</span><br><span class="line">  maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">18: 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</span><br><span class="line">因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line">  appendonly no</span><br><span class="line"></span><br><span class="line">19: 指定更新日志文件名，默认为appendonly.aof</span><br><span class="line">   appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line">20: 指定更新日志条件，共有3个可选值： </span><br><span class="line">  no：表示等操作系统进行数据缓存同步到磁盘（快） </span><br><span class="line">  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span><br><span class="line">  everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line">  appendfsync everysec</span><br><span class="line"></span><br><span class="line">21: 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，</span><br><span class="line">访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class="line">   vm-enabled no</span><br><span class="line"></span><br><span class="line">22: 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line">   vm-swap-file /tmp/redis.swap</span><br><span class="line"></span><br><span class="line">23: 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),</span><br><span class="line">也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line">   vm-max-memory 0</span><br><span class="line"></span><br><span class="line">24: Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，</span><br><span class="line">vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；</span><br><span class="line">如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line">   vm-page-size 32</span><br><span class="line"></span><br><span class="line">25: 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line">   vm-pages 134217728</span><br><span class="line"></span><br><span class="line">26: 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，</span><br><span class="line">可能会造成比较长时间的延迟。默认值为4</span><br><span class="line">   vm-max-threads 4</span><br><span class="line"></span><br><span class="line">27: 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line">  glueoutputbuf yes</span><br><span class="line"></span><br><span class="line">28: 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line">  hash-max-zipmap-entries 64</span><br><span class="line">  hash-max-zipmap-value 512</span><br><span class="line"></span><br><span class="line">29: 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line">  activerehashing yes</span><br><span class="line"></span><br><span class="line">30: 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</span><br><span class="line">  include /path/to/local.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#daemonize no  默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">#  当 redis 在后台运行的时候， Redis 默认会把 pid 文件放在 /var/run/redis.pid ，你可以配置到其他地址。</span><br><span class="line"></span><br><span class="line">#  当运行多个 redis 服务时，需要指定不同的 pid 文件和端口</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line">#  指定 redis 运行的端口，默认是 6379</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#  在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志</span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">#  指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span><br><span class="line"></span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"></span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">#  设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</span><br><span class="line"></span><br><span class="line"># 0 是关闭此设置</span><br><span class="line"></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"># TCP keepalive</span><br><span class="line"></span><br><span class="line">#  在 Linux 上，指定值（秒）用于发送 ACKs 的时间。注意关闭连接需要双倍的时间。默认为 0 。</span><br><span class="line"></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line">#  指定日志记录级别，生产环境推荐 notice</span><br><span class="line"></span><br><span class="line"># Redis 总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 verbose</span><br><span class="line"></span><br><span class="line"># debug     记录很多信息，用于开发和测试</span><br><span class="line"></span><br><span class="line"># varbose   有用的信息，不像 debug 会记录那么多</span><br><span class="line"></span><br><span class="line"># notice    普通的 verbose ，常用于生产环境</span><br><span class="line"></span><br><span class="line"># warning   只有非常重要或者严重的信息会记录到日志</span><br><span class="line"></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">#  配置 log 文件地址</span><br><span class="line"></span><br><span class="line">#  默认值为 stdout ，标准输出，若后台模式会输出到 /dev/null 。</span><br><span class="line"></span><br><span class="line">logfile /var/log/redis/redis.log</span><br><span class="line"></span><br><span class="line">#  可用数据库数</span><br><span class="line"></span><br><span class="line">#  默认值为 16 ，默认数据库为 0 ，数据库范围在 0- （ database-1 ）之间</span><br><span class="line"></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">################################ 快照#################################</span><br><span class="line"></span><br><span class="line">#  保存数据到磁盘，格式如下 :</span><br><span class="line"></span><br><span class="line">#   save  </span><br><span class="line"></span><br><span class="line">#    指出在多长时间内，有多少次更新操作，就将数据同步到数据文件 rdb 。</span><br><span class="line"></span><br><span class="line">#    相当于条件触发抓取快照，这个可以多个条件配合</span><br><span class="line"></span><br><span class="line">#    比如默认配置文件中的设置，就设置了三个条件</span><br><span class="line"></span><br><span class="line">#   save 900 1  900 秒内至少有 1 个 key 被改变</span><br><span class="line"></span><br><span class="line">#   save 300 10  300 秒内至少有 300 个 key 被改变</span><br><span class="line"></span><br><span class="line">#   save 60 10000  60 秒内至少有 10000 个 key 被改变</span><br><span class="line"></span><br><span class="line"># save 900 1</span><br><span class="line"></span><br><span class="line"># save 300 10</span><br><span class="line"></span><br><span class="line"># save 60 10000</span><br><span class="line"></span><br><span class="line">#  后台存储错误停止写。</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#  存储至本地数据库时（持久化到 rdb 文件）是否压缩数据，默认为 yes</span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 对rdb数据进行校验,耗费CPU资源,默认为yes</span><br><span class="line"></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#  本地持久化数据库文件名，默认值为 dump.rdb</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#  工作目录</span><br><span class="line"></span><br><span class="line">#  数据库镜像备份的文件放置的路径。</span><br><span class="line"></span><br><span class="line">#  这里的路径跟文件名要分开配置是因为 redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成，</span><br><span class="line"></span><br><span class="line">#  再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。</span><br><span class="line"></span><br><span class="line"># AOF 文件也会存放在这个目录下面</span><br><span class="line"></span><br><span class="line">#  注意这里必须制定一个目录而不是文件</span><br><span class="line"></span><br><span class="line">dir /var/lib/redis-server/</span><br><span class="line"></span><br><span class="line">################################# 复制 #################################</span><br><span class="line"></span><br><span class="line">#  主从复制 . 设置该数据库为其他数据库的从数据库 .</span><br><span class="line"></span><br><span class="line">#  设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</span><br><span class="line"></span><br><span class="line"># slaveof </span><br><span class="line"></span><br><span class="line">#  当 master 服务设置了密码保护时 ( 用 requirepass 制定的密码 )</span><br><span class="line"></span><br><span class="line"># slave 服务连接 master 的密码</span><br><span class="line"></span><br><span class="line"># masterauth </span><br><span class="line"></span><br><span class="line">#  当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：</span><br><span class="line"></span><br><span class="line"># 1)  如果 slave-serve-stale-data 设置为 yes( 默认设置 ) ，从库会继续响应客户端的请求</span><br><span class="line"></span><br><span class="line"># 2)  如果 slave-serve-stale-data 是指为 no ，出去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个</span><br><span class="line"></span><br><span class="line">#     错误 &quot;SYNC with master in progress&quot;</span><br><span class="line"></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">#  配置 slave 实例是否接受写。写 slave 对存储短暂数据（在同 master 数据同步后可以很容易地被删除）是有用的，但未配置的情况下，客户端写可能会发送问题。</span><br><span class="line"></span><br><span class="line">#  从 Redis2.6 后，默认 slave 为 read-only</span><br><span class="line"></span><br><span class="line">slaveread-only yes</span><br><span class="line"></span><br><span class="line">#  从库会按照一个时间间隔向主库发送 PINGs. 可以通过 repl-ping-slave-period 设置这个时间间隔，默认是 10 秒</span><br><span class="line"></span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># repl-timeout  设置主库批量数据传输时间或者 ping 回复时间间隔，默认值是 60 秒</span><br><span class="line"></span><br><span class="line">#  一定要确保 repl-timeout 大于 repl-ping-slave-period</span><br><span class="line"></span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line">#  在 slave socket 的 SYNC 后禁用 TCP_NODELAY</span><br><span class="line"></span><br><span class="line">#  如果选择“ yes ” ,Redis 将使用一个较小的数字 TCP 数据包和更少的带宽将数据发送到 slave ， 但是这可能导致数据发送到 slave 端会有延迟 , 如果是 Linux kernel 的默认配置，会达到 40 毫秒 .</span><br><span class="line"></span><br><span class="line">#  如果选择 &quot;no&quot; ，则发送数据到 slave 端的延迟会降低，但将使用更多的带宽用于复制 .</span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">#  设置复制的后台日志大小。</span><br><span class="line"></span><br><span class="line">#  复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。</span><br><span class="line"></span><br><span class="line">#  后台日志在至少有一个 slave 连接时，仅仅分配一次。</span><br><span class="line"></span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line">#  在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。</span><br><span class="line"></span><br><span class="line"># 0 意味着从不释放后台日志</span><br><span class="line"></span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">#  如果 master 不能再正常工作，那么会在多个 slave 中，选择优先值最小的一个 slave 提升为 master ，优先值为 0 表示不能提升为 master 。</span><br><span class="line"></span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line">#  如果少于 N 个 slave 连接，且延迟时间 &lt;=M 秒，则 master 可配置停止接受写操作。</span><br><span class="line"></span><br><span class="line">#  例如需要至少 3 个 slave 连接，且延迟 &lt;=10 秒的配置：</span><br><span class="line"></span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"></span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line">#  设置 0 为禁用</span><br><span class="line"></span><br><span class="line">#   默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10</span><br><span class="line"></span><br><span class="line">################################## 安全 ###################################</span><br><span class="line"></span><br><span class="line">#  设置客户端连接后进行任何其他指定前需要使用的密码。</span><br><span class="line"></span><br><span class="line">#  警告：因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解</span><br><span class="line"></span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line">#  命令重命名 .</span><br><span class="line"></span><br><span class="line">#  在一个共享环境下可以重命名相对危险的命令。比如把 CONFIG 重名为一个不容易猜测的字符。</span><br><span class="line"></span><br><span class="line">#  举例 :</span><br><span class="line"></span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line">#  如果想删除一个命令，直接把它重命名为一个空字符 &quot;&quot; 即可，如下：</span><br><span class="line"></span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">################################### 约束###################################</span><br><span class="line"></span><br><span class="line">#设置同一时间最大客户端连接数，默认无限制， </span><br><span class="line"></span><br><span class="line">#Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，</span><br><span class="line"></span><br><span class="line">#如果设置  maxclients 0 ，表示不作限制。</span><br><span class="line"></span><br><span class="line">#当客户端连接数到达限制时， Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span><br><span class="line"></span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line">#  指定 Redis 最大内存限制， Redis 在启动时会把数据加载到内存中，达到最大内存后， Redis 会按照清除策略尝试清除已到期的 Key</span><br><span class="line"></span><br><span class="line">#  如果 Redis 依照策略清除后无法提供足够空间，或者策略设置为 ”noeviction” ，则使用更多空间的命令将会报错，例如 SET, LPUSH 等。但仍然可以进行读取操作</span><br><span class="line"></span><br><span class="line">#  注意： Redis 新的 vm 机制，会把 Key 存放内存， Value 会存放在 swap 区</span><br><span class="line"></span><br><span class="line">#  该选项对 LRU 策略很有用。</span><br><span class="line"></span><br><span class="line"># maxmemory 的设置比较适合于把 redis 当作于类似 memcached 的缓存来使用，而不适合当做一个真实的 DB 。</span><br><span class="line"></span><br><span class="line">#  当把 Redis 当做一个真实的数据库使用的时候，内存使用将是一个很大的开销</span><br><span class="line"></span><br><span class="line"># maxmemory </span><br><span class="line"></span><br><span class="line">#  当内存达到最大值的时候 Redis 会选择删除哪些数据？有五种方式可供选择</span><br><span class="line"></span><br><span class="line"># volatile-lru -&gt;  利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用  Least RecentlyUsed )</span><br><span class="line"></span><br><span class="line"># allkeys-lru -&gt;  利用 LRU 算法移除任何 key</span><br><span class="line"></span><br><span class="line"># volatile-random -&gt;  移除设置过过期时间的随机 key</span><br><span class="line"></span><br><span class="line"># allkeys-&gt;random -&gt; remove a randomkey, any key</span><br><span class="line"></span><br><span class="line"># volatile-ttl -&gt;  移除即将过期的 key(minor TTL)</span><br><span class="line"></span><br><span class="line"># noeviction -&gt;  不移除任何可以，只是返回一个写错误</span><br><span class="line"></span><br><span class="line">#  注意：对于上面的策略，如果没有合适的 key 可以移除，当写的时候 Redis 会返回一个错误</span><br><span class="line"></span><br><span class="line">#  默认是 :  volatile-lru</span><br><span class="line"></span><br><span class="line"># maxmemory-policy volatile-lru  </span><br><span class="line"></span><br><span class="line"># LRU  和  minimal TTL 算法都不是精准的算法，但是相对精确的算法 ( 为了节省内存 ) ，随意你可以选择样本大小进行检测。</span><br><span class="line"></span><br><span class="line"># Redis 默认的灰选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置</span><br><span class="line"></span><br><span class="line"># maxmemory-samples 3</span><br><span class="line"></span><br><span class="line">############################## AOF###############################</span><br><span class="line"></span><br><span class="line">#  默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。</span><br><span class="line"></span><br><span class="line">#  所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。</span><br><span class="line"></span><br><span class="line">#  开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到 appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。</span><br><span class="line"></span><br><span class="line">#  但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对 appendonly.aof 进行重新整理。</span><br><span class="line"></span><br><span class="line">#  你可以同时开启 asynchronous dumps 和  AOF</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF 文件名称  ( 默认 : &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line"># appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line"># Redis 支持三种同步 AOF 文件的策略 :</span><br><span class="line"></span><br><span class="line"># no:  不进行同步，系统去操作  . Faster.</span><br><span class="line"></span><br><span class="line"># always: always 表示每次有写操作都进行同步 . Slow, Safest.</span><br><span class="line"></span><br><span class="line"># everysec:  表示对写操作进行累积，每秒同步一次 . Compromise.</span><br><span class="line"></span><br><span class="line">#  默认是 &quot;everysec&quot; ，按照速度和安全折中这是最好的。</span><br><span class="line"></span><br><span class="line">#  如果想让 Redis 能更高效的运行，你也可以设置为 &quot;no&quot; ，让操作系统决定什么时候去执行</span><br><span class="line"></span><br><span class="line">#  或者相反想让数据更安全你也可以设置为 &quot;always&quot;</span><br><span class="line"></span><br><span class="line">#  如果不确定就用  &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># AOF 策略设置为 always 或者 everysec 时，后台处理进程 ( 后台保存或者 AOF 日志重写 ) 会执行大量的 I/O 操作</span><br><span class="line"></span><br><span class="line">#  在某些 Linux 配置中会阻止过长的 fsync() 请求。注意现在没有任何修复，即使 fsync 在另外一个线程进行处理</span><br><span class="line"></span><br><span class="line">#  为了减缓这个问题，可以设置下面这个参数 no-appendfsync-on-rewrite</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># AOF  自动重写</span><br><span class="line"></span><br><span class="line">#  当 AOF 文件增长到一定大小的时候 Redis 能够调用  BGREWRITEAOF  对日志文件进行重写</span><br><span class="line"></span><br><span class="line">#  它是这样工作的： Redis 会记住上次进行些日志后文件的大小 ( 如果从开机以来还没进行过重写，那日子大小在开机的时候确定 )</span><br><span class="line"></span><br><span class="line">#  基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动</span><br><span class="line"></span><br><span class="line">#  同时需要指定一个最小大小用于 AOF 重写，这个用于阻止即使文件很小但是增长幅度很大也去重写 AOF 文件的情况</span><br><span class="line"></span><br><span class="line">#  设置  percentage 为 0 就关闭这个特性</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">################################ LUASCRIPTING #############################</span><br><span class="line"></span><br><span class="line"># 一个 Lua 脚本最长的执行时间为 5000 毫秒（ 5 秒），如果为 0 或负数表示无限执行时间。</span><br><span class="line"></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">################################LOW LOG################################</span><br><span class="line"></span><br><span class="line"># Redis Slow Log  记录超过特定执行时间的命令。执行时间不包括 I/O 计算比如连接客户端，返回结果等，只是命令执行时间</span><br><span class="line"></span><br><span class="line">#  可以通过两个参数设置 slow log ：一个是告诉 Redis 执行超过多少时间被记录的参数 slowlog-log-slower-than( 微妙 ) ，</span><br><span class="line"></span><br><span class="line">#  另一个是 slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除</span><br><span class="line"></span><br><span class="line">#  下面的时间以微妙为单位，因此 1000000 代表一秒。</span><br><span class="line"></span><br><span class="line">#  注意指定一个负数将关闭慢日志，而设置为 0 将强制每个命令都会记录</span><br><span class="line"></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">#  对日志长度没有限制，只是要注意它会消耗内存</span><br><span class="line"></span><br><span class="line">#  可以通过  SLOWLOG RESET 回收被慢日志消耗的内存</span><br><span class="line"></span><br><span class="line">#  推荐使用默认值 128 ，当慢日志超过 128 时，最先进入队列的记录会被踢出</span><br><span class="line"></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">################################  事件通知  #############################</span><br><span class="line"></span><br><span class="line">#  当事件发生时， Redis 可以通知 Pub/Sub 客户端。</span><br><span class="line"></span><br><span class="line">#  可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识：</span><br><span class="line"></span><br><span class="line"># K     Keyspace 事件，以 _keyspace@_ 的前缀方式发布</span><br><span class="line"></span><br><span class="line"># E     Keyevent 事件，以 _keysevent@_ 的前缀方式发布</span><br><span class="line"></span><br><span class="line"># g     通用事件（不指定类型），像 DEL, EXPIRE, RENAME, …</span><br><span class="line"></span><br><span class="line"># $     String 命令</span><br><span class="line"></span><br><span class="line"># s     Set 命令</span><br><span class="line"></span><br><span class="line"># h     Hash 命令</span><br><span class="line"></span><br><span class="line"># z     有序集合命令</span><br><span class="line"></span><br><span class="line"># x     过期事件（每次 key 过期时生成）</span><br><span class="line"></span><br><span class="line"># e     清除事件（当 key 在内存被清除时生成）</span><br><span class="line"></span><br><span class="line"># A     g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件</span><br><span class="line"></span><br><span class="line"># notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span><br><span class="line"></span><br><span class="line">#  例子：启用 list 和通用事件：</span><br><span class="line"></span><br><span class="line"># notify-keyspace-events Elg</span><br><span class="line"></span><br><span class="line">#  默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。</span><br><span class="line"></span><br><span class="line">#  注意如果你不指定至少 K 或 E 之一，不会发送任何事件。</span><br><span class="line"></span><br><span class="line">notify-keyspace-events “”</span><br><span class="line"></span><br><span class="line">##############################  高级配置  ###############################</span><br><span class="line"></span><br><span class="line">#  当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时，</span><br><span class="line"></span><br><span class="line"># hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</span><br><span class="line"></span><br><span class="line"># Redis Hash 对应 Value 内部实际就是一个 HashMap ，实际这里会有 2 种不同实现，</span><br><span class="line"></span><br><span class="line">#  这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 valueredisObject 的 encoding 为 zipmap,</span><br><span class="line"></span><br><span class="line">#  当成员数量增大时会自动转成真正的 HashMap, 此时 encoding 为 ht 。</span><br><span class="line"></span><br><span class="line">hash-max-zipmap-entries 512</span><br><span class="line"></span><br><span class="line">hash-max-zipmap-value 64  </span><br><span class="line"></span><br><span class="line">#  和 Hash 一样，多个小的 list 以特定的方式编码来节省空间。</span><br><span class="line"></span><br><span class="line"># list 数据类型节点值大小小于多少字节会采用紧凑存储格式。</span><br><span class="line"></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line"></span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># set 数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。</span><br><span class="line"></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">#  和 hashe 和 list 一样 , 排序的 set 在指定的长度内以指定编码方式存储以节省空间</span><br><span class="line"></span><br><span class="line"># zsort 数据类型节点值大小小于多少字节会采用紧凑存储格式。</span><br><span class="line"></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line"></span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash ，可以降低内存的使用</span><br><span class="line"></span><br><span class="line">#  当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no 。</span><br><span class="line"></span><br><span class="line">#  如果没有这么严格的实时性要求，可以设置为 yes ，以便能够尽可能快的释放内存</span><br><span class="line"></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 客户端的输出缓冲区的限制，因为某种原因客户端从服务器读取数据的速度不够快，</span><br><span class="line"></span><br><span class="line"># 可用于强制断开连接（一个常见的原因是一个发布 / 订阅客户端消费消息的速度无法赶上生产它们的速度）。</span><br><span class="line"></span><br><span class="line">#  可以三种不同客户端的方式进行设置：</span><br><span class="line"></span><br><span class="line"># normal -&gt;  正常客户端</span><br><span class="line"></span><br><span class="line"># slave  -&gt; slave 和 MONITOR 客户端</span><br><span class="line"></span><br><span class="line"># pubsub -&gt;  至少订阅了一个 pubsub channel 或 pattern 的客户端</span><br><span class="line"></span><br><span class="line">#  每个 client-output-buffer-limit 语法 :</span><br><span class="line"></span><br><span class="line"># client-output-buffer-limit   </span><br><span class="line"></span><br><span class="line">#  一旦达到硬限制客户端会立即断开，或者达到软限制并保持达成的指定秒数（连续）。</span><br><span class="line"></span><br><span class="line">#  例如，如果硬限制为 32 兆字节和软限制为 16 兆字节 /10 秒，客户端将会立即断开</span><br><span class="line"></span><br><span class="line">#  如果输出缓冲区的大小达到 32 兆字节，客户端达到 16 兆字节和连续超过了限制 10 秒，也将断开连接。</span><br><span class="line"></span><br><span class="line">#  默认 normal 客户端不做限制，因为他们在一个请求后未要求时（以推的方式）不接收数据，</span><br><span class="line"></span><br><span class="line">#  只有异步客户端可能会出现请求数据的速度比它可以读取的速度快的场景。</span><br><span class="line"></span><br><span class="line">#  把硬限制和软限制都设置为 0 来禁用该特性</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit slave 256mb 64mb60</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb60</span><br><span class="line"></span><br><span class="line"># Redis 调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除过期的 Key ，等等。</span><br><span class="line"></span><br><span class="line">#  不是所有的任务都以相同的频率执行，但 Redis 依照指定的“ Hz ”值来执行检查任务。</span><br><span class="line"></span><br><span class="line">#  默认情况下，“ Hz ”的被设定为 10 。</span><br><span class="line"></span><br><span class="line">#  提高该值将在 Redis 空闲时使用更多的 CPU 时，但同时当有多个 key 同时到期会使 Redis 的反应更灵敏，以及超时可以更精确地处理。</span><br><span class="line"></span><br><span class="line">#  范围是 1 到 500 之间，但是值超过 100 通常不是一个好主意。</span><br><span class="line"></span><br><span class="line">#  大多数用户应该使用 10 这个预设值，只有在非常低的延迟的情况下有必要提高最大到 100 。</span><br><span class="line"></span><br><span class="line">hz 10  </span><br><span class="line"></span><br><span class="line">#  当一个子节点重写 AOF 文件时，如果启用下面的选项，则文件每生成 32M 数据进行同步。</span><br><span class="line"></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible项目使用</title>
    <url>/knowledge-base/2019/11/09/python-install/</url>
    <content><![CDATA[<div class="note primary"><p>介绍ansible项目的使用</p>
</div>
<span id="more"></span>

<h2 id="1-python3的安装"><a href="#1-python3的安装" class="headerlink" title="1. python3的安装"></a>1. python3的安装</h2><ol>
<li>安装依赖环境</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel	</span><br></pre></td></tr></table></figure>

<p>2.下载Python3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz</span></span><br></pre></td></tr></table></figure>

<p>3.安装python3</p>
<p>　　我个人习惯安装在&#x2F;usr&#x2F;local&#x2F;python3（具体安装位置看个人喜好）<br>　　创建目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -p /usr/local/python3</span></span><br></pre></td></tr></table></figure>

<p>4.进入解压后的目录，编译安装。（编译安装前需要安装编译器yum install gcc）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> Python-3.6.1``<span class="comment"># ./configure --prefix=/usr/local/python3  #/usr/local/python3为安装目录</span></span></span><br></pre></td></tr></table></figure>

<p>5.建立python3的软链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span> -s /usr/local/python3/bin/python3 /usr/bin/python3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-创建python虚拟环境"><a href="#2-创建python虚拟环境" class="headerlink" title="2. 创建python虚拟环境"></a>2. 创建python虚拟环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir venv;cd venv</span><br><span class="line">python -m venv oms -- 生成oms的虚拟环境</span><br><span class="line">在.bash_profile 添加别名</span><br><span class="line">alias cdoms=&#x27;source $HOME/venv/oms/bin/activate&#x27;</span><br><span class="line">安装环境初始化，配置pip国内镜像</span><br><span class="line">vi .pip/pip.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br><span class="line">disable-pip-version-check = true</span><br><span class="line">timeout = 120</span><br><span class="line">执行包管理文件 pip使用方法</span><br><span class="line">在联网的主机执行</span><br><span class="line">------------------------------------</span><br><span class="line">pip install -r requirements.txt -- 安装包管理 </span><br><span class="line">pip show --files SomePackage 查看已安装的包</span><br><span class="line">pip list --outdated  pip检查哪些包需要更新</span><br><span class="line">pip freeze &gt; requirements 按着一定格式输出已安装包列表</span><br><span class="line">pip download -d ./tools -r requirements.txt -- 下载本地安装包</span><br><span class="line">--------------------------------------</span><br><span class="line">把tools打包到不联网的主机上展开安装</span><br><span class="line">pip install --no-index --find-links=$HOME/tools -r requirements.txt -- 离线安装</span><br><span class="line"></span><br><span class="line">连接postgres指定动态库 -- 没有</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/pgsql/lib/</span><br></pre></td></tr></table></figure>

<h2 id="3-解决Python-h-No-such-file-or-directory"><a href="#3-解决Python-h-No-such-file-or-directory" class="headerlink" title="3. 解决Python.h No such file or directory"></a>3. 解决Python.h No such file or directory</h2><p>1.可以先查看一下含python-devel的包</p>
<pre><code>yum search python | grep python-devel
</code></pre>
<p>2.64位安装python-devel.x86_64，32位安装python-devel.i686，我这里安装:</p>
<pre><code>sudo yum install python-devel.x86_64
</code></pre>
<ol start="3">
<li>进入&#x2F;usr&#x2F;include&#x2F;python2.7看一下现在有没有Python.h，版本不同目录名不同，我这里是2.7版本。其实也可以看到很多.h文件，python需要库或头文件都在这个地方。</li>
</ol>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>corosync+ pacemaker实现pg流复制自动切换</title>
    <url>/knowledge-base/2018/05/31/corosync-pg/</url>
    <content><![CDATA[<div class="note danger"><p>说明：</p>
<p>该文档用于说明以corosync+pacemaker的方式实现PostgreSQL流复制自动切换。注意内容包括有关corosync&#x2F;pacemaker知识总结以及整个环境的搭建过程和问题处理。</p>
</div>

<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Corosync</p>
<p>Corosync是由OpenAIS项目分离独立出来的项目，分离后能实现HA信息传输功能的就成为了Corosync，因此Corosync 60%的代码来源于OpenAIS。</p>
<p>Corosync与分离出来的Heartbeat类似，都属于集群信息层，负责传送集群信息以及节点间的心跳信息，单纯HA软件都不存在管理资源的功能，而是需要依赖上层的CRM来管理资源。目前最著名的资源管理器为Pacemaker，Corosync+Pacemaker也成为高可用集群方案中的最佳组合。</p>
<p>Pacemaker</p>
<p>Pacemaker，即Cluster Resource Manager（CRM），管理整个HA，客户端通过pacemaker管理监控整个集群。</p>
<p>常用的集群管理工具：</p>
<p>（1）基于命令行</p>
<p>crm shell&#x2F;pcs</p>
<p>（2）基于图形化</p>
<p>pygui&#x2F;hawk&#x2F;lcmc&#x2F;pcs</p>
<p>Pacemaker内部组件、模块关系图：</p>
<p><a href="http://image.codeweblog.com/upload/7/5c/75c7d2ac33b21262.png"><img src="http://image.codeweblog.com/upload/7/5c/75c7d2ac33b21262_thumb.png" alt="corosync+ pacemaker实现pg流复制自动切换"></a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="2-1-OS"><a href="#2-1-OS" class="headerlink" title="2.1 OS"></a>2.1 OS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/issue</span><br><span class="line">CentOS release 6.4 (Final)</span><br><span class="line">Kernel \r on an \m</span><br><span class="line"></span><br><span class="line"># uname -a</span><br><span class="line">Linux node1 2.6.32-358.el6.x86_64 #1 SMP Fri Feb 22 00:31:26 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-IP"><a href="#2-2-IP" class="headerlink" title="2.2 IP"></a>2.2 IP</h2><p>node1:</p>
<p>eth0 192.168.100.201&#x2F;24 GW 192.168.100.1 —真实地址</p>
<p>eth1 10.10.10.1&#x2F;24 —心跳地址</p>
<p>eth2 192.168.1.1&#x2F;24 —流复制地址</p>
<p>node2:</p>
<p>eth0 192.168.100.202&#x2F;24 GW 192.168.100.1 —真实地址</p>
<p>eth1 10.10.10.2&#x2F;24 —心跳地址</p>
<p>eth2 192.168.1.2&#x2F;24 —流复制地址</p>
<p>虚拟地址：</p>
<p>eth0:0 192.168.100.213&#x2F;24 —vip-master</p>
<p>eth0:0 192.168.100.214&#x2F;24 —vip-slave</p>
<p>eth2:0 192.168.1.3&#x2F;24 —vip-rep</p>
<h2 id="2-3-软件版本"><a href="#2-3-软件版本" class="headerlink" title="2.3 软件版本"></a>2.3 软件版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -qa | grep corosync</span><br><span class="line">corosync-1.4.5-2.3.x86_64</span><br><span class="line">corosynclib-1.4.5-2.3.x86_64</span><br><span class="line"></span><br><span class="line"># rpm -qa | grep pacemaker</span><br><span class="line">pacemaker-libs-1.1.10-14.el6_5.2.x86_64</span><br><span class="line">pacemaker-cli-1.1.10-14.el6_5.2.x86_64</span><br><span class="line">pacemaker-1.1.10-14.el6_5.2.x86_64</span><br><span class="line">pacemaker-cluster-libs-1.1.10-14.el6_5.2.x86_64</span><br><span class="line"></span><br><span class="line"># rpm -qa | grep crmsh</span><br><span class="line">crmsh-1.2.6-6.1.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PostgreSQL Version：9.1.4</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="3-1-设置YUM源"><a href="#3-1-设置YUM源" class="headerlink" title="3.1 设置YUM源"></a>3.1 设置YUM源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/yum.repos.d/ha-clustering.repo</span><br><span class="line">[haclustering]</span><br><span class="line">name=HA Clustering</span><br><span class="line">baseurl=http://download.opensuse.org/repositories/network:/ha-clustering:/Stable/CentOS_CentOS-6/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-2-安装pacemaker-x2F-corosync-x2F-crmsh"><a href="#3-2-安装pacemaker-x2F-corosync-x2F-crmsh" class="headerlink" title="3.2 安装pacemaker&#x2F;corosync&#x2F;crmsh"></a>3.2 安装pacemaker&#x2F;corosync&#x2F;crmsh</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install pacemaker corosync crmsh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装后会在&#x2F;usr&#x2F;lib&#x2F;ocf&#x2F;resource.d下生成相应的ocf资源脚本，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /usr/lib/ocf/resource.d/</span><br><span class="line">[root@node1 resource.d]# ls</span><br><span class="line">heartbeat  pacemaker  redhat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过命令查看资源脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 resource.d]# crm ra list ocf</span><br><span class="line">ASEHAagent.sh        AoEtarget            AudibleAlarm         CTDB                 ClusterMon           Delay                Dummy</span><br><span class="line">EvmsSCC              Evmsd                Filesystem           HealthCPU            HealthSMART          ICP                  IPaddr</span><br><span class="line">IPaddr2              IPsrcaddr            IPv6addr             LVM                  LinuxSCSI            MailTo               ManageRAID</span><br><span class="line">ManageVE             Pure-FTPd            Raid1                Route                SAPDatabase          SAPInstance          SendArp</span><br><span class="line">ServeRAID            SphinxSearchDaemon   Squid                Stateful             SysInfo              SystemHealth         VIPArip</span><br><span class="line">VirtualDomain        WAS                  WAS6                 WinPopup             Xen                  Xinetd               anything</span><br><span class="line">apache               apache.sh            asterisk             clusterfs.sh         conntrackd           controld             db2</span><br><span class="line">dhcpd                drbd                 drbd.sh              eDir88               ethmonitor           exportfs             fio</span><br><span class="line">fs.sh                iSCSILogicalUnit     iSCSITarget          ids                  ip.sh                iscsi                jboss</span><br><span class="line">ldirectord           lvm.sh               lvm_by_lv.sh         lvm_by_vg.sh         lxc                  mysql                mysql-proxy</span><br><span class="line">mysql.sh             named                named.sh             netfs.sh             nfsclient.sh         nfsexport.sh         nfsserver</span><br><span class="line">nfsserver.sh         nginx                ocf-shellfuncs       openldap.sh          oracle               oracledb.sh          orainstance.sh</span><br><span class="line">oralistener.sh       oralsnr              pgsql                ping                 pingd                portblock            postfix</span><br><span class="line">postgres-8.sh        pound                proftpd              remote               rsyncd               rsyslog              samba.sh</span><br><span class="line">script.sh            scsi2reservation     service.sh           sfex                 slapd                smb.sh               svclib_nfslock</span><br><span class="line">symlink              syslog-ng            tomcat               tomcat-5.sh          tomcat-6.sh          varnish              vm.sh</span><br><span class="line">vmware               zabbixserver</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动corosync：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# service corosync start</span><br><span class="line">Starting Corosync Cluster Engine (corosync):               [  OK  ]</span><br><span class="line">[root@node2 ~]# service corosync start</span><br><span class="line">Starting Corosync Cluster Engine (corosync):               [  OK  ]</span><br><span class="line">[root@node2 ~]# crm status</span><br><span class="line">Last updated: Sat Jan 18 07:00:34 2014</span><br><span class="line">Last change: Sat Jan 18 06:58:11 2014 via crmd on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">0 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若出现以下错误可先禁止掉stonith，该错误是因为stonith未配置导致，错误如下：</p>
<p>crm_verify[4921]: 2014&#x2F;01&#x2F;10_07:34:34 ERROR: unpack_resources: Resource start-up disabled since no STONITH resources have been defined</p>
<p>crm_verify[4921]: 2014&#x2F;01&#x2F;10_07:34:34 ERROR: unpack_resources: Either configure some or disable STONITH with the stonith-enabled option</p>
<p>crm_verify[4921]: 2014&#x2F;01&#x2F;10_07:34:34 ERROR: unpack_resources: NOTE: Clusters with shared data need STONITH to ensure data integrity</p>
<p>禁止stonith（只在一个节点上执行即可）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure property stonith-enabled=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3-安装PostgreSQL"><a href="#3-3-安装PostgreSQL" class="headerlink" title="3.3 安装PostgreSQL"></a>3.3 安装PostgreSQL</h2><p>安装目录为&#x2F;opt&#x2F;pgsql</p>
<p>{安装过程略}</p>
<p>为postgres用户配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[postgres@node1 ~]$ cat .bash_profile</span><br><span class="line"># .bash_profile</span><br><span class="line"></span><br><span class="line"># Get the aliases and functions</span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line"> . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific environment and startup programs</span><br><span class="line"></span><br><span class="line">export PATH=/opt/pgsql/bin:$PATH:$HOME/bin</span><br><span class="line">export PGDATA=/opt/pgsql/data</span><br><span class="line">export PGUSER=postgres</span><br><span class="line">export PGPORT=5432</span><br><span class="line">export LD_LIBRARY_PATH=/opt/pgsql/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="4-1-hosts设置"><a href="#4-1-hosts设置" class="headerlink" title="4.1 hosts设置"></a>4.1 hosts设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim /etc/hosts</span><br><span class="line">192.168.100.201 node1</span><br><span class="line">192.168.100.202 node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-2-配置corosync"><a href="#4-2-配置corosync" class="headerlink" title="4.2 配置corosync"></a>4.2 配置corosync</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span>root@node1 ~<span class="punctuation">]</span># cd /etc/corosync/</span><br><span class="line"><span class="punctuation">[</span>root@node1 corosync<span class="punctuation">]</span># ls</span><br><span class="line">corosync.conf.example  corosync.conf.example.udpu  service.d  uidgid.d</span><br><span class="line"><span class="punctuation">[</span>root@node1 corosync<span class="punctuation">]</span># cp corosync.conf.example corosync.conf</span><br><span class="line"><span class="punctuation">[</span>root@node1 corosync<span class="punctuation">]</span># vim corosync.conf</span><br><span class="line">compatibility<span class="punctuation">:</span> whitetank <span class="comment">//兼容旧版本</span></span><br><span class="line"></span><br><span class="line">totem <span class="punctuation">&#123;</span> <span class="comment">//节点间通信协议定义</span></span><br><span class="line"> version<span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"> secauth<span class="punctuation">:</span> on <span class="comment">//是否开启安全认证</span></span><br><span class="line"> threads<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"> interface <span class="punctuation">&#123;</span> <span class="comment">//心跳配置</span></span><br><span class="line"> ringnumber<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"> bindnetaddr<span class="punctuation">:</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.0</span> <span class="comment">//绑定网络</span></span><br><span class="line"> mcastaddr<span class="punctuation">:</span> <span class="number">226.94</span><span class="number">.1</span><span class="number">.1</span> <span class="comment">//向外发送多播的地址</span></span><br><span class="line"> mcastport<span class="punctuation">:</span> <span class="number">5405</span> <span class="comment">//多播端口</span></span><br><span class="line"> ttl<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">logging <span class="punctuation">&#123;</span> <span class="comment">//日志设置</span></span><br><span class="line"> fileline<span class="punctuation">:</span> off</span><br><span class="line"> to_stderr<span class="punctuation">:</span> no <span class="comment">//是否发送错误信息到标准输出</span></span><br><span class="line"> to_logfile<span class="punctuation">:</span> yes <span class="comment">//是否记录到日志文件</span></span><br><span class="line"> to_syslog<span class="punctuation">:</span> yes <span class="comment">//是否记录到系统日志</span></span><br><span class="line"> logfile<span class="punctuation">:</span> /var/log/cluster/corosync.log <span class="comment">//日志文件，注意/var/log/cluster目录必须存在</span></span><br><span class="line"> debug<span class="punctuation">:</span> off</span><br><span class="line"> timestamp<span class="punctuation">:</span> on <span class="comment">//日志中是否标记时间</span></span><br><span class="line"> logger_subsys <span class="punctuation">&#123;</span></span><br><span class="line"> subsys<span class="punctuation">:</span> AMF</span><br><span class="line"> debug<span class="punctuation">:</span> off</span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">amf <span class="punctuation">&#123;</span></span><br><span class="line"> mode<span class="punctuation">:</span> disabled</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">service <span class="punctuation">&#123;</span></span><br><span class="line">        ver<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">        name<span class="punctuation">:</span> pacemaker <span class="comment">//启用pacemaker</span></span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br><span class="line"></span><br><span class="line">aisexec <span class="punctuation">&#123;</span></span><br><span class="line">        user<span class="punctuation">:</span>   root</span><br><span class="line">        group<span class="punctuation">:</span>  root</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-生成密钥"><a href="#4-3-生成密钥" class="headerlink" title="4.3 生成密钥"></a>4.3 生成密钥</h2><p>{默认利用random生成，但如果中断的系统随机数不够用就需要较长的时间，此时可以通过urandom来替代random}</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 corosync]# mv /dev/random /dev/random.bak</span><br><span class="line">[root@node1 corosync]# ln -s /dev/urandom /dev/random</span><br><span class="line">[root@node1 corosync]# corosync-keygen</span><br><span class="line">Corosync Cluster Engine Authentication key generator.</span><br><span class="line">Gathering 1024 bits for key from /dev/random.</span><br><span class="line">Press keys on your keyboard to generate entropy.</span><br><span class="line">Writing corosync key to /etc/corosync/authkey.</span><br></pre></td></tr></table></figure>

<h2 id="4-4-SSH互信配置"><a href="#4-4-SSH互信配置" class="headerlink" title="4.4 SSH互信配置"></a>4.4 SSH互信配置</h2><p>node1 -&gt; node2 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# cd .ssh/</span><br><span class="line">[root@node1 .ssh]# ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">2c:ed:1e:a6:a7:cd:e3:b2:7c:de:aa:ff:63:28:9a:19 root@node1</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|       o         |</span><br><span class="line">|      . S        |</span><br><span class="line">|       o         |</span><br><span class="line">|    E   +.       |</span><br><span class="line">|     =o*=oo      |</span><br><span class="line">|    +.*%O=o.     |</span><br><span class="line">+-----------------+</span><br><span class="line">[root@node1 .ssh]# ssh-copy-id -i id_rsa.pub node2</span><br><span class="line">The authenticity of host &#x27;node2 (192.168.100.202)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is be:76:cd:29:af:59:76:11:6a:c7:7d:72:27:df:d1:02.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;node2,192.168.100.202&#x27; (RSA) to the list of known hosts.</span><br><span class="line">root@node2&#x27;s password:</span><br><span class="line">Now try logging into the machine, with &quot;ssh &#x27;node2&#x27;&quot;, and check in:</span><br><span class="line"></span><br><span class="line">  .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">to make sure we haven&#x27;t added extra keys that you weren&#x27;t expecting.</span><br><span class="line">[root@node1 .ssh]# ssh node2 date</span><br><span class="line">Sat Jan 18 06:36:21 CST 2014</span><br></pre></td></tr></table></figure>

<p>node2 -&gt; node1 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# cd .ssh/</span><br><span class="line">[root@node2 .ssh]# ssh-keygen -t rsa</span><br><span class="line">[root@node2 .ssh]# ssh-copy-id -i id_rsa.pub node1</span><br><span class="line">[root@node2 .ssh]# ssh node1 date</span><br><span class="line">Sat Jan 18 06:37:31 CST 2014		</span><br></pre></td></tr></table></figure>

<h2 id="4-5-同步配置"><a href="#4-5-同步配置" class="headerlink" title="4.5 同步配置"></a>4.5 同步配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 corosync]# scp authkey corosync.conf node2:/etc/corosync/</span><br><span class="line">authkey         100%  128     0.1KB/s   00:00</span><br><span class="line">corosync.conf   100% 2808     2.7KB/s   00:00</span><br></pre></td></tr></table></figure>

<h2 id="4-6-下载替换脚本"><a href="#4-6-下载替换脚本" class="headerlink" title="4.6 下载替换脚本"></a>4.6 下载替换脚本</h2><p>虽然安装了上述软件后会生成pgsql资源脚本，但是其版本过旧，且自带的pgsql不能实现自动切换功能，所以在安装了pacemaker&#x2F;corosync之后需要从网上下载进行替换，如下：</p>
<p><a href="">https://github.com/ClusterLabs/resource-agents/tree/master/heartbeat</a>�</p>
<p>下载pgsql与ocf-shellfuncs.in</p>
<p>替换：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> pgsql /usr/lib/ocf/resource.d/heartbeat/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> ocf-shellfuncs.in /usr/lib/ocf/lib/heartbeat/ocf-shellfuncs</span></span><br></pre></td></tr></table></figure>

<p>{注意要将ocf-shellfuncs.in名称改为ocf-shellfuncs，否则pgsql可能会找不到要用的函数。新下载的函数定义文件中添加了一些新功能函数，如ocf_local_nodename等}</p>
<p>pgsql资源脚本特性：</p>
<p>●主节点失效切换</p>
<p>master宕掉时，RA检测到该问题并将master标记为stop，随后将slave提升为新的master。</p>
<p>●异步与同步切换</p>
<p>如果slave宕掉或者LAN中存在问题，那么当设置为同步复制时包含写操作的事务将会被终止，也就意味着服务将停止。因此，为防止服务停止RA将会动态地将同步转换为异步复制。</p>
<p>●初始启动时自动识别新旧数据</p>
<p>当两个或多个节点上的Pacemaker同时初始启动时，RA通过每个节点上最近的replay location进行比较，找出最新数据节点。这个拥有最新数据的节点将被认为是master。当然，若在一个节点上启动pacemaker或者该节点上的pacemaker是第一个被启动的，那么它也将成为master。RA依据停止前的数据状态进行裁定。</p>
<p>●读负载均衡</p>
<p>由于slave节点可以处理只读事务，因此对于读操作可以通过虚拟另一个虚拟IP来实现读操作的负载均衡。</p>
<h2 id="4-7-启动corosync"><a href="#4-7-启动corosync" class="headerlink" title="4.7 启动corosync"></a>4.7 启动corosync</h2><p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# service corosync start</span><br><span class="line">[root@node2 ~]# service corosync start</span><br></pre></td></tr></table></figure>

<p>检测状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm status</span><br><span class="line">Last updated: Tue Jan 21 23:55:13 2014</span><br><span class="line">Last change: Tue Jan 21 23:37:36 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">0 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br></pre></td></tr></table></figure>

<p>{corosync启动成功}</p>
<h2 id="4-8-配置流复制"><a href="#4-8-配置流复制" class="headerlink" title="4.8 配置流复制"></a>4.8 配置流复制</h2><p>在node1&#x2F;node2上配置postgresql.conf&#x2F;pg_hba.conf：</p>
<p>postgresql.conf :</p>
<p>listen_addresses &#x3D; ‘*’</p>
<p>port &#x3D; 5432</p>
<p>wal_level &#x3D; hot_standby</p>
<p>archive_mode &#x3D; on</p>
<p>archive_command &#x3D; ‘test ! -f &#x2F;opt&#x2F;archivelog&#x2F;%f &amp;&amp; cp %p &#x2F;opt&#x2F;archivelog&#x2F;%f’</p>
<p>max_wal_senders &#x3D; 4</p>
<p>wal_keep_segments &#x3D; 50</p>
<p>hot_standby &#x3D; on</p>
<p>​	pg_hba.conf :</p>
<p>host replication postgres 192.168.1.0&#x2F;24 trust</p>
<p>在node2上执行基础同步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[postgres@node2 data]$ pg_basebackup -h 192.168.1.1 -U postgres -D /opt/pgsql/data -P</span><br></pre></td></tr></table></figure>

<p>若需测试流复制是否能够成功，可在此处手工配置（corosync启动数据库时自动生成，若已经存在将会被覆盖）recovery.conf进行测试：</p>
<p>standby_mode &#x3D; ‘on’</p>
<p>primary_conninfo &#x3D; ‘host&#x3D;192.168.1.1 port&#x3D;5432 user&#x3D;postgres application_name&#x3D;node2 keepalives_idle&#x3D;60 keepalives_interval&#x3D;5 keepalives_count&#x3D;5’</p>
<p>restore_command &#x3D; ‘cp &#x2F;opt&#x2F;archivelog&#x2F;%f %p’</p>
<p>recovery_target_timeline &#x3D; ‘latest’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[postgres@node2 data]$ pg_ctl start</span><br><span class="line">[postgres@node1 pgsql]$ psql</span><br><span class="line">postgres=# select client_addr,sync_state from pg_stat_replication;</span><br><span class="line"> client_addr | sync_state</span><br><span class="line">-------------+------------</span><br><span class="line"> 192.168.1.2 | sync</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>停止数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[postgres@node2 ~]$ pg_ctl stop -m f</span><br><span class="line">[postgres@node1 ~]$ pg_ctl stop -m f</span><br></pre></td></tr></table></figure>

<h2 id="4-9-配置pacemaker"><a href="#4-9-配置pacemaker" class="headerlink" title="4.9 配置pacemaker"></a>4.9 配置pacemaker</h2><p>{关于pacemaker的配置可通过多种方式，如crmsh、hb_gui、pcs等，该实验使用crmsh配置}</p>
<p>编写crm配置脚本：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# cat pgsql.crm</span><br><span class="line">property \ <span class="operator">/</span><span class="operator">/</span>设置全局属性</span><br><span class="line">    <span class="keyword">no</span><span class="operator">-</span>quorum<span class="operator">-</span>policy<span class="operator">=</span>&quot;ignore&quot; \ <span class="operator">/</span><span class="operator">/</span>关闭法定投票人数策略，多节点时启用</span><br><span class="line">    stonith<span class="operator">-</span>enabled<span class="operator">=</span>&quot;false&quot; \ <span class="operator">/</span><span class="operator">/</span>禁用stonith设备检测</span><br><span class="line">    crmd<span class="operator">-</span>transition<span class="operator">-</span>delay<span class="operator">=</span>&quot;0s&quot;</span><br><span class="line"></span><br><span class="line">rsc_defaults \ <span class="operator">/</span><span class="operator">/</span>资源默认属性配置</span><br><span class="line">    resource<span class="operator">-</span>stickiness<span class="operator">=</span>&quot;INFINITY&quot; \ <span class="operator">/</span><span class="operator">/</span>资源留在所处位置的自愿程度，INFINITY为无限自愿</span><br><span class="line">    migration<span class="operator">-</span>threshold<span class="operator">=</span>&quot;1&quot; <span class="operator">/</span><span class="operator">/</span>设置资源发生多少次故障时节点将失去管理该资源的资格</span><br><span class="line"></span><br><span class="line">ms msPostgresql pgsql \ <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">    meta \</span><br><span class="line">        master<span class="operator">-</span>max<span class="operator">=</span>&quot;1&quot; \</span><br><span class="line">        master<span class="operator">-</span>node<span class="operator">-</span>max<span class="operator">=</span>&quot;1&quot; \</span><br><span class="line">        clone<span class="operator">-</span>max<span class="operator">=</span>&quot;2&quot; \</span><br><span class="line">        clone<span class="operator">-</span>node<span class="operator">-</span>max<span class="operator">=</span>&quot;1&quot; \</span><br><span class="line">        notify<span class="operator">=</span>&quot;true&quot;</span><br><span class="line"></span><br><span class="line">clone clnPingCheck pingCheck <span class="operator">/</span><span class="operator">/</span>克隆资源</span><br><span class="line"><span class="keyword">group</span> master<span class="operator">-</span><span class="keyword">group</span> \ <span class="operator">/</span><span class="operator">/</span>定义资源组</span><br><span class="line">      vip<span class="operator">-</span>master \</span><br><span class="line">      vip<span class="operator">-</span>rep</span><br><span class="line"></span><br><span class="line">primitive vip<span class="operator">-</span>master ocf:heartbeat:IPaddr2 \ <span class="operator">/</span><span class="operator">/</span>定义vip<span class="operator">-</span>master资源</span><br><span class="line">    params \</span><br><span class="line">        ip<span class="operator">=</span>&quot;192.168.100.213&quot; \</span><br><span class="line">        nic<span class="operator">=</span>&quot;eth0&quot; \</span><br><span class="line">        cidr_netmask<span class="operator">=</span>&quot;24&quot; \</span><br><span class="line">    op <span class="keyword">start</span>   timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;stop&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;10s&quot; <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op stop    timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;block&quot;</span><br><span class="line"></span><br><span class="line">  primitive vip<span class="operator">-</span>rep ocf:heartbeat:IPaddr2 \ <span class="operator">/</span><span class="operator">/</span>定义vip<span class="operator">-</span>rep资源</span><br><span class="line">    params \</span><br><span class="line">        ip<span class="operator">=</span>&quot;192.168.1.3&quot; \</span><br><span class="line">        nic<span class="operator">=</span>&quot;eth2&quot; \</span><br><span class="line">        cidr_netmask<span class="operator">=</span>&quot;24&quot; \</span><br><span class="line">    meta \</span><br><span class="line">            migration<span class="operator">-</span>threshold<span class="operator">=</span>&quot;0&quot; \</span><br><span class="line">    op <span class="keyword">start</span>   timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;10s&quot; <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op stop    timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;block&quot;</span><br><span class="line"></span><br><span class="line">primitive vip<span class="operator">-</span>slave ocf:heartbeat:IPaddr2 \ <span class="operator">/</span><span class="operator">/</span>定义vip<span class="operator">-</span>slave资源</span><br><span class="line">    params \</span><br><span class="line">        ip<span class="operator">=</span>&quot;192.168.100.214&quot; \</span><br><span class="line">        nic<span class="operator">=</span>&quot;eth0&quot; \</span><br><span class="line">        cidr_netmask<span class="operator">=</span>&quot;24&quot; \</span><br><span class="line">    meta \</span><br><span class="line">        resource<span class="operator">-</span>stickiness<span class="operator">=</span>&quot;1&quot; \</span><br><span class="line">    op <span class="keyword">start</span>   timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;10s&quot; <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op stop    timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;block&quot;</span><br><span class="line"></span><br><span class="line">primitive pgsql ocf:heartbeat:pgsql \ <span class="operator">/</span><span class="operator">/</span>定义pgsql资源</span><br><span class="line">    params \ <span class="operator">/</span><span class="operator">/</span>设置相关参数</span><br><span class="line">        pgctl<span class="operator">=</span>&quot;/opt/pgsql/bin/pg_ctl&quot; \</span><br><span class="line">        psql<span class="operator">=</span>&quot;/opt/pgsql/bin/psql&quot; \</span><br><span class="line">        pgdata<span class="operator">=</span>&quot;/opt/pgsql/data/&quot; \</span><br><span class="line">        start_opt<span class="operator">=</span>&quot;-p 5432&quot; \</span><br><span class="line">        rep_mode<span class="operator">=</span>&quot;sync&quot; \</span><br><span class="line">        node_list<span class="operator">=</span>&quot;node1 node2&quot; \</span><br><span class="line">        restore_command<span class="operator">=</span>&quot;cp /opt/archivelog/%f %p&quot; \</span><br><span class="line">        primary_conninfo_opt<span class="operator">=</span>&quot;keepalives_idle=60 keepalives_interval=5 keepalives_count=5&quot; \</span><br><span class="line">        master_ip<span class="operator">=</span>&quot;192.168.1.3&quot; \</span><br><span class="line">        stop_escalate<span class="operator">=</span>&quot;0&quot; \</span><br><span class="line">    op <span class="keyword">start</span>   timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;7s&quot; <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;2s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; role<span class="operator">=</span>&quot;Master&quot; \</span><br><span class="line">    op promote timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op demote  timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;stop&quot; \</span><br><span class="line">    op stop    timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;block&quot; \</span><br><span class="line">    op notify  timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;</span><br><span class="line"></span><br><span class="line">primitive pingCheck ocf:pacemaker:ping \ <span class="operator">/</span><span class="operator">/</span>定义pingCheck资源</span><br><span class="line">    params \</span><br><span class="line">        name<span class="operator">=</span>&quot;default_ping_set&quot; \</span><br><span class="line">        host_list<span class="operator">=</span>&quot;192.168.100.1&quot; \</span><br><span class="line">        multiplier<span class="operator">=</span>&quot;100&quot; \</span><br><span class="line">    op <span class="keyword">start</span>   timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op monitor timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;10s&quot; <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;restart&quot; \</span><br><span class="line">    op stop    timeout<span class="operator">=</span>&quot;60s&quot; <span class="type">interval</span><span class="operator">=</span>&quot;0s&quot;  <span class="keyword">on</span><span class="operator">-</span>fail<span class="operator">=</span>&quot;ignore&quot;</span><br><span class="line"></span><br><span class="line">location rsc_location<span class="number">-1</span> vip<span class="operator">-</span>slave \ <span class="operator">/</span><span class="operator">/</span>定义资源vip<span class="operator">-</span>slave选择位置</span><br><span class="line">    rule  <span class="number">200</span>: pgsql<span class="operator">-</span>status eq &quot;HS:sync&quot; \</span><br><span class="line">    rule  <span class="number">100</span>: pgsql<span class="operator">-</span>status eq &quot;PRI&quot; \</span><br><span class="line">    rule  <span class="operator">-</span>inf: not_defined pgsql<span class="operator">-</span>status \</span><br><span class="line">    rule  <span class="operator">-</span>inf: pgsql<span class="operator">-</span>status ne &quot;HS:sync&quot; <span class="keyword">and</span> pgsql<span class="operator">-</span>status ne &quot;PRI&quot;</span><br><span class="line"></span><br><span class="line">location rsc_location<span class="number">-2</span> msPostgresql \ <span class="operator">/</span><span class="operator">/</span>定义资源msPostgresql选择位置</span><br><span class="line">    rule <span class="operator">-</span>inf: not_defined default_ping_set <span class="keyword">or</span> default_ping_set lt <span class="number">100</span></span><br><span class="line"></span><br><span class="line">colocation rsc_colocation<span class="number">-1</span> inf: msPostgresql        clnPingCheck <span class="operator">/</span><span class="operator">/</span>定义在相同节点上运行的资源</span><br><span class="line">colocation rsc_colocation<span class="number">-2</span> inf: master<span class="operator">-</span><span class="keyword">group</span>        msPostgresql:Master</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> rsc_order<span class="number">-1</span> <span class="number">0</span>: clnPingCheck          msPostgresql <span class="operator">/</span><span class="operator">/</span>定义对资源的操作顺序</span><br><span class="line"><span class="keyword">order</span> rsc_order<span class="number">-2</span> <span class="number">0</span>: msPostgresql:promote  master<span class="operator">-</span><span class="keyword">group</span>:<span class="keyword">start</span>   symmetrical<span class="operator">=</span><span class="literal">false</span></span><br><span class="line"><span class="keyword">order</span> rsc_order<span class="number">-3</span> <span class="number">0</span>: msPostgresql:demote   master<span class="operator">-</span><span class="keyword">group</span>:stop    symmetrical<span class="operator">=</span><span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：该脚本针对网上的配置方式做了一点修改，因为网上是针对pacemaker-1.0.*进行配置的，而本实验使用的是pacemaker-1.1.10。</p>
<p>导入配置脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure load update pgsql.crm</span><br><span class="line">WARNING: pgsql: specified timeout 60s for stop is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for start is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for notify is smaller than the advised 90</span><br><span class="line">WARNING: pgsql: specified timeout 60s for demote is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for promote is smaller than the advised 120</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一段时间后查看ha状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm status</span><br><span class="line">Last updated: Tue Jan 21 23:55:13 2014</span><br><span class="line">Last change: Tue Jan 21 23:37:36 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# crm_mon -Afr -1</span><br><span class="line">Last updated: Tue Jan 21 23:37:20 2014</span><br><span class="line">Last change: Tue Jan 21 23:37:36 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 1000</span><br><span class="line">    + pgsql-data-status                : LATEST</span><br><span class="line">    + pgsql-master-baseline            : 0000000006000078</span><br><span class="line">    + pgsql-status                     : PRI</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 100</span><br><span class="line">    + pgsql-data-status                : STREAMING|SYNC</span><br><span class="line">    + pgsql-status                     : HS:sync   </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line">* Node node2:</span><br><span class="line">* Node node1:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：刚启动时两节点均为slave，一段时间后node1自动切换为master。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="5-1-备节点失效"><a href="#5-1-备节点失效" class="headerlink" title="5.1 备节点失效"></a>5.1 备节点失效</h2><p>在node2上杀死postgres数据库进程，模拟备节点上数据库崩溃：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# killall -9 postgres</span><br></pre></td></tr></table></figure>

<p>查看此时集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_mon -Afr -1</span><br><span class="line">Last updated: Wed Jan 22 02:15:06 2014</span><br><span class="line">Last change: Wed Jan 22 02:15:33 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Stopped: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 1000</span><br><span class="line">    + pgsql-data-status                : LATEST</span><br><span class="line">    + pgsql-master-baseline            : 0000000006000078</span><br><span class="line">    + pgsql-status                     : PRI</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : -INFINITY</span><br><span class="line">    + pgsql-data-status                : DISCONNECT</span><br><span class="line">    + pgsql-status                     : STOP      </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line">* Node node2:</span><br><span class="line">   pgsql: migration-threshold=1 fail-count=1 last-failure=&#x27;Wed Jan 22 02:15:35 2014&#x27;</span><br><span class="line">* Node node1: </span><br><span class="line"></span><br><span class="line">Failed actions:</span><br><span class="line">    pgsql_monitor_7000 on node2 &#x27;not running&#x27; (7): call=42, status=complete, last-rc-change=&#x27;Wed Jan 22 02:14:58 2014&#x27;, queued=0ms, exec=0ms</span><br></pre></td></tr></table></figure>

<p>{vip-slave资源已成功切换到了node1上}</p>
<p>重启node2上的corosync，数据库将重新伴随启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# service corosync restart</span><br><span class="line">[root@node1 ~]# crm_mon -Afr -1</span><br><span class="line">Last updated: Wed Jan 22 02:16:24 2014</span><br><span class="line">Last change: Wed Jan 22 02:16:55 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 1000</span><br><span class="line">    + pgsql-data-status                : LATEST</span><br><span class="line">    + pgsql-master-baseline            : 0000000006000078</span><br><span class="line">    + pgsql-status                     : PRI</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 100</span><br><span class="line">    + pgsql-data-status                : STREAMING|SYNC</span><br><span class="line">    + pgsql-status                     : HS:sync   </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line">* Node node2:</span><br><span class="line">* Node node1:</span><br></pre></td></tr></table></figure>

<p>{vip-slave又重新回到了nod2上}</p>
<h2 id="5-2-主节点失效切换"><a href="#5-2-主节点失效切换" class="headerlink" title="5.2 主节点失效切换"></a>5.2 主节点失效切换</h2><p>在node1上杀死postgres数据库进程，模拟主节点上数据库崩溃：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# killall -9 postgres</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等会查看集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# crm_mon -Afr -1</span><br><span class="line">Last updated: Wed Jan 22 02:17:50 2014</span><br><span class="line">Last change: Wed Jan 22 02:18:16 2014 via crm_attribute on node2</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node2 ]</span><br><span class="line">     Stopped: [ node1 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : -INFINITY</span><br><span class="line">    + pgsql-data-status                : DISCONNECT</span><br><span class="line">    + pgsql-status                     : STOP</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql                     : 1000</span><br><span class="line">    + pgsql-data-status                : LATEST</span><br><span class="line">    + pgsql-master-baseline            : 0000000008014A70</span><br><span class="line">    + pgsql-status                     : PRI       </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line">* Node node2:</span><br><span class="line">* Node node1:</span><br><span class="line">   pgsql: migration-threshold=1 fail-count=1 last-failure=&#x27;Wed Jan 22 02:18:11 2014&#x27;</span><br><span class="line"></span><br><span class="line">Failed actions:</span><br><span class="line">    pgsql_monitor_2000 on node1 &#x27;not running&#x27; (7): call=2435, status=complete, last-rc-change=&#x27;Wed Jan 22 02:18:11 2014&#x27;, queued=0ms, exec=0ms</span><br></pre></td></tr></table></figure>

<p>{vip-master&#x2F;vip-rep都已成功切换到node2上，且node2已变为master，node2上pg数据库状态已切换为PRI}</p>
<p>停止node1上的corosync：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# service corosync stop</span><br></pre></td></tr></table></figure>

<p>执行一次基础同步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[postgres@node1 data]$ pwd</span><br><span class="line">/opt/pgsql/data</span><br><span class="line">[postgres@node1 data]$ rm -rf *</span><br><span class="line">[postgres@node1 data]$ pg_basebackup -h 192.168.1.3 -U postgres -D /opt/pgsql/data/ -P</span><br><span class="line">19172/19172 kB (100%), 1/1 tablespace</span><br><span class="line">NOTICE:  pg_stop_backup complete, all required WAL segments have been archived</span><br><span class="line">[postgres@node1 data]$ ls</span><br><span class="line">backup_label      base    pg_clog      pg_ident.conf  pg_notify  pg_stat_tmp  pg_tblspc    PG_VERSION  postgresql.conf</span><br><span class="line">backup_label.old  global  pg_hba.conf  pg_multixact   pg_serial  pg_subtrans  pg_twophase  pg_xlog     recovery.done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动node1上的corosync：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># service corosync start</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-主节点恢复"><a href="#5-3-主节点恢复" class="headerlink" title="5.3 主节点恢复"></a>5.3 主节点恢复</h2><p>修复原主节点后将其恢复为当前备节点</p>
<p>在node1上执行一次基础同步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[postgres@node1 data]$ pwd</span><br><span class="line">/opt/pgsql/data</span><br><span class="line">[postgres@node1 data]$ rm -rf *</span><br><span class="line">[postgres@node1 data]$ pg_basebackup -h 192.168.2.3 -U postgres -D /opt/pgsql/data/ -P</span><br><span class="line">19172/19172 kB (100%), 1/1 tablespace</span><br><span class="line">NOTICE:  pg_stop_backup complete, all required WAL segments have been archived</span><br><span class="line">[postgres@node1 data]$ ls</span><br><span class="line">backup_label      base    pg_clog      pg_ident.conf  pg_notify  pg_stat_tmp  pg_tblspc    PG_VERSION  postgresql.conf</span><br><span class="line">backup_label.old  global  pg_hba.conf  pg_multixact   pg_serial  pg_subtrans  pg_twophase  pg_xlog     recovery.done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动heartbeat之前必须删除资锁，不然资源将不会伴随heartbeat启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# rm -rf /var/lib/pgsql/tmp/PGSQL.lock	</span><br></pre></td></tr></table></figure>

<p>{该锁文件在当节点为主节点时创建，但不会因为heartbeat的异常停止或数据库&#x2F;系统的异常终止而自动删除，所以在恢复一个节点的时候只要该节点充当过主节点就需要手动清理该锁文件}</p>
<p>重启node1上的heartbeat：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# service heartbeat restart</span><br></pre></td></tr></table></figure>

<p>过段时间后查看集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# crm_mon -Afr1</span><br><span class="line">============</span><br><span class="line">Last updated: Mon Jan 27 08:50:43 2014</span><br><span class="line">Stack: Heartbeat</span><br><span class="line">Current DC: node2 (f2dcd1df-7429-42f5-82e9-b73921f97cab) - partition with quorum</span><br><span class="line">Version: 1.0.12-unknown</span><br><span class="line">2 Nodes configured, unknown expected votes</span><br><span class="line">4 Resources configured.</span><br><span class="line">============</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Master/Slave Set: msPostgresql</span><br><span class="line">     Masters: [ node2 ]</span><br><span class="line">     Slaves: [ node1 ]</span><br><span class="line"> Clone Set: clnPingCheck</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql:0                   : 100</span><br><span class="line">    + pgsql-data-status                : STREAMING|SYNC</span><br><span class="line">    + pgsql-status                     : HS:sync</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                 : 100</span><br><span class="line">    + master-pgsql:1                   : 1000</span><br><span class="line">    + pgsql-data-status                : LATEST</span><br><span class="line">    + pgsql-master-baseline            : 00000000120000B0</span><br><span class="line">    + pgsql-status                     : PRI       </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line">* Node node1:</span><br><span class="line">* Node node2:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>{vip-slave已成功切到node1上，node1成功成为流复制备节点}</p>
<h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><h2 id="6-1-启动关闭corosync"><a href="#6-1-启动关闭corosync" class="headerlink" title="6.1 启动关闭corosync"></a>6.1 启动关闭corosync</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# service corosync start</span><br><span class="line">[root@node1 ~]# service corosync stop</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-2-查看HA状态"><a href="#6-2-查看HA状态" class="headerlink" title="6.2 查看HA状态"></a>6.2 查看HA状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm status</span><br><span class="line">Last updated: Tue Jan 21 23:55:13 2014</span><br><span class="line">Last change: Tue Jan 21 23:37:36 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-3-查看资源状态及节点属性"><a href="#6-3-查看资源状态及节点属性" class="headerlink" title="6.3 查看资源状态及节点属性"></a>6.3 查看资源状态及节点属性</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# crm_mon <span class="operator">-</span>Afr <span class="number">-1</span></span><br><span class="line"><span class="keyword">Last</span> updated: Tue Jan <span class="number">21</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">20</span> <span class="number">2014</span></span><br><span class="line"><span class="keyword">Last</span> change: Tue Jan <span class="number">21</span> <span class="number">23</span>:<span class="number">37</span>:<span class="number">36</span> <span class="number">2014</span> via crm_attribute <span class="keyword">on</span> node1</span><br><span class="line">Stack: classic openais (<span class="keyword">with</span> plugin)</span><br><span class="line"><span class="keyword">Current</span> DC: node1 <span class="operator">-</span> <span class="keyword">partition</span> <span class="keyword">with</span> quorum</span><br><span class="line">Version: <span class="number">1.1</span><span class="number">.10</span><span class="number">-14.</span>el6_5<span class="number">.2</span><span class="number">-368</span>c726</span><br><span class="line"><span class="number">2</span> Nodes configured, <span class="number">2</span> expected votes</span><br><span class="line"><span class="number">7</span> Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">Full</span> list <span class="keyword">of</span> resources:</span><br><span class="line"></span><br><span class="line"> vip<span class="operator">-</span>slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource <span class="keyword">Group</span>: master<span class="operator">-</span><span class="keyword">group</span></span><br><span class="line">     vip<span class="operator">-</span>master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip<span class="operator">-</span>rep (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master<span class="operator">/</span>Slave <span class="keyword">Set</span>: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone <span class="keyword">Set</span>: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line"><span class="operator">*</span> Node node1:</span><br><span class="line">    <span class="operator">+</span> default_ping_set                 : <span class="number">100</span></span><br><span class="line">    <span class="operator">+</span> master<span class="operator">-</span>pgsql                     : <span class="number">1000</span></span><br><span class="line">    <span class="operator">+</span> pgsql<span class="operator">-</span>data<span class="operator">-</span>status                : LATEST</span><br><span class="line">    <span class="operator">+</span> pgsql<span class="operator">-</span>master<span class="operator">-</span>baseline            : <span class="number">0000000006000078</span></span><br><span class="line">    <span class="operator">+</span> pgsql<span class="operator">-</span>status                     : PRI</span><br><span class="line"><span class="operator">*</span> Node node2:</span><br><span class="line">    <span class="operator">+</span> default_ping_set                 : <span class="number">100</span></span><br><span class="line">    <span class="operator">+</span> master<span class="operator">-</span>pgsql                     : <span class="number">100</span></span><br><span class="line">    <span class="operator">+</span> pgsql<span class="operator">-</span>data<span class="operator">-</span>status                : STREAMING<span class="operator">|</span>SYNC</span><br><span class="line">    <span class="operator">+</span> pgsql<span class="operator">-</span>status                     : HS:sync   </span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line"><span class="operator">*</span> Node node2:</span><br><span class="line"><span class="operator">*</span> Node node1:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-4-查看配置"><a href="#6-4-查看配置" class="headerlink" title="6.4 查看配置"></a>6.4 查看配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure show</span><br><span class="line">node node1 \</span><br><span class="line">        attributes pgsql-data-status=&quot;LATEST&quot;</span><br><span class="line">node node2 \</span><br><span class="line">        attributes pgsql-data-status=&quot;STREAMING|SYNC&quot;</span><br><span class="line">primitive pgsql ocf:heartbeat:pgsql \</span><br><span class="line">        params pgctl=&quot;/opt/pgsql/bin/pg_ctl&quot; psql=&quot;/opt/pgsql/bin/psql&quot; pgdata=&quot;/opt/pgsql/data/&quot; start_opt=&quot;-p 5432&quot; rep_mode=&quot;sync&quot; node_list=&quot;node1 node2&quot; restore_command=&quot;cp /opt/archivelog/%f %p&quot; primary_conninfo_opt=&quot;keepalives_idle=60 keepalives_interval=5 keepalives_count=5&quot; master_ip=&quot;192.168.1.3&quot; stop_escalate=&quot;0&quot; \</span><br><span class="line">        op start timeout=&quot;60s&quot; interval=&quot;0s&quot; on-fail=&quot;restart&quot; \</span><br><span class="line">        op monitor timeout=&quot;60s&quot; interval=&quot;7s&quot; on-fail=&quot;restart&quot; \</span><br><span class="line">        op monitor timeout=&quot;60s&quot; interval=&quot;2s&quot; on-fail=&quot;restart&quot; role=&quot;Master&quot; \</span><br><span class="line">        op promote timeout=&quot;60s&quot; interval=&quot;0s&quot; on-fail=&quot;restart&quot; \</span><br><span class="line">        op demote timeout=&quot;60s&quot; interval=&quot;0s&quot; on-fail=&quot;stop&quot; \</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-5-实时监控HA"><a href="#6-5-实时监控HA" class="headerlink" title="6.5 实时监控HA"></a>6.5 实时监控HA</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_mon -Afr</span><br><span class="line">Last updated: Wed Jan 22 00:40:12 2014</span><br><span class="line">Last change: Tue Jan 21 23:37:36 2014 via crm_attribute on node1</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1 - partition with quorum</span><br><span class="line">Version: 1.1.10-14.el6_5.2-368c726</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">7 Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Full list of resources:</span><br><span class="line"></span><br><span class="line">vip-slave (ocf::heartbeat:IPaddr2): Started node2</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line">     vip-rep    (ocf::heartbeat:IPaddr2): Started node1</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line">* Node node1:</span><br><span class="line">    + default_ping_set                  : 100</span><br><span class="line">    + master-pgsql                      : 1000</span><br><span class="line">    + pgsql-data-status                 : LATEST</span><br><span class="line">    + pgsql-master-baseline             : 0000000006000078</span><br><span class="line">    + pgsql-status                      : PRI</span><br><span class="line">* Node node2:</span><br><span class="line">    + default_ping_set                  : 100</span><br><span class="line">    + master-pgsql                      : 100</span><br><span class="line">    + pgsql-data-status                 : STREAMING|SYNC</span><br><span class="line">    + pgsql-status                      : HS:sync   </span><br><span class="line"></span><br><span class="line">Migration summary:* Node node2: * Node node1:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-6-crm-resource命令"><a href="#6-6-crm-resource命令" class="headerlink" title="6.6 crm_resource命令"></a>6.6 crm_resource命令</h2><h3 id="资源启动-x2F-关闭："><a href="#资源启动-x2F-关闭：" class="headerlink" title="资源启动&#x2F;关闭："></a>资源启动&#x2F;关闭：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_resource -r vip-master -v started</span><br><span class="line">[root@node1 ~]# crm_resource -r vip-master -v stoped</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列举资源："><a href="#列举资源：" class="headerlink" title="列举资源："></a>列举资源：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_resource -L</span><br><span class="line"> vip-slave (ocf::heartbeat:IPaddr2): Started</span><br><span class="line"> Resource Group: master-group</span><br><span class="line">     vip-master (ocf::heartbeat:IPaddr2): Started</span><br><span class="line">     vip-rep (ocf::heartbeat:IPaddr2): Started</span><br><span class="line"> Master/Slave Set: msPostgresql [pgsql]</span><br><span class="line">     Masters: [ node1 ]</span><br><span class="line">     Slaves: [ node2 ]</span><br><span class="line"> Clone Set: clnPingCheck [pingCheck]</span><br><span class="line">     Started: [ node1 node2 ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看资源位置："><a href="#查看资源位置：" class="headerlink" title="查看资源位置："></a>查看资源位置：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_resource -W -r pgsql</span><br><span class="line">resource pgsql is running on: node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="迁移资源："><a href="#迁移资源：" class="headerlink" title="迁移资源："></a>迁移资源：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_resource -M -r vip-slave -N node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除资源："><a href="#删除资源：" class="headerlink" title="删除资源："></a>删除资源：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm_resource -D -r vip-slave -t primitive</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-7-crm命令"><a href="#6-7-crm命令" class="headerlink" title="6.7 crm命令"></a>6.7 crm命令</h2><h3 id="列举指定的RA："><a href="#列举指定的RA：" class="headerlink" title="列举指定的RA："></a>列举指定的RA：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm ra list ocf pacemaker</span><br><span class="line">ClusterMon     Dummy          HealthCPU      HealthSMART    Stateful       SysInfo        SystemHealth   controld       ping           pingd</span><br><span class="line">remote</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm node delete node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="停用节点："><a href="#停用节点：" class="headerlink" title="停用节点："></a>停用节点：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm node standby node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启用节点："><a href="#启用节点：" class="headerlink" title="启用节点："></a>启用节点：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm node online node2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置pacemaker："><a href="#配置pacemaker：" class="headerlink" title="配置pacemaker："></a>配置pacemaker：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure</span><br><span class="line"><span class="meta prompt_">crm(live)configure#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">……</span></span><br><span class="line">……</span><br><span class="line"><span class="meta prompt_">crm(live)configure# </span><span class="language-bash">commit</span></span><br><span class="line"><span class="meta prompt_">crm(live)configure# </span><span class="language-bash">quit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-8-重置failcount"><a href="#6-8-重置failcount" class="headerlink" title="6.8 重置failcount"></a>6.8 重置failcount</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm resource</span><br><span class="line"><span class="meta prompt_">crm(live)resource# </span><span class="language-bash">failcount pgsql <span class="built_in">set</span> node1 0</span></span><br><span class="line"><span class="meta prompt_">crm(live)resource# </span><span class="language-bash">failcount pgsql show node1</span></span><br><span class="line">scope=status  name=fail-count-pgsql value=0</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# crm resource cleanup pgsql</span><br><span class="line">Cleaning up pgsql:0 on node1</span><br><span class="line">Waiting for 1 replies from the CRMd. OK</span><br><span class="line"></span><br><span class="line">[root@node1 ~]# crm_failcount -G -U node1 -r pgsql</span><br><span class="line">scope=status  name=fail-count-pgsql value=INFINITY</span><br><span class="line">[root@node1 ~]# crm_failcount -D -U node1 -r pgsql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="7-1-Q1"><a href="#7-1-Q1" class="headerlink" title="7.1 Q1"></a>7.1 Q1</h2><p>问题现象：</p>
<p>corosync.log日志中报错：</p>
<p>Jan 15 10:23:57 node1 lrmd: [6327]: info: RA output: (pgsql:0:monitor:stderr) &#x2F;usr&#x2F;lib&#x2F;ocf&#x2F;resource.d&#x2F;&#x2F;heartbeat&#x2F;pgsql: line 1749: ocf_local_nodename: command not found</p>
<p>Jan 15 10:23:57 node1 crm_attribute: [11094]: info: Invoked: &#x2F;usr&#x2F;sbin&#x2F;crm_attribute -l reboot -N -n -v 0000000006000090 pgsql-xlog-loc lrm_get_rsc_type_metadata(578)</p>
<p>Jan 15 10:23:57 node1 lrmd: [6327]: info: RA output: (pgsql:0:monitor:stderr) Could not map uname&#x3D;-n to a UUID: The object&#x2F;attribute does not exist</p>
<p>解决方式：</p>
<p>查看pgsql脚本，发现其中使用了ocf_local_nodename，该函数本该在ocf-shellfuncs.in中有定义，但却没有这个函数，上网查看相关论坛</p>
<p><a href="http://www.gossamer-threads.com/lists/linuxha/users/89379?do=post_view_threaded">http://www.gossamer-threads.com/lists/linuxha/users/89379?do=post_view_threaded</a>�</p>
<p>指出此时需要相关补丁，解决ocf_local_nodename函数的补丁：</p>
<p><a href="">https://github.com/ClusterLabs/resource-agents/commit/abc1c3f6464f6e5e7a1e41cd7c9b8179896c1903</a>�</p>
<p>最新的版本没有ocf_local_nodename函数，所以使用以下版本：</p>
<p>{注：确保pacemaker版本&gt;1.1.8，不然crm_node -n命令无法使用}</p>
<p><a href="">https://github.com/ClusterLabs/resource-agents/blob/a6f4ddf76cb4bbc1b3df4c9b6632a6351b63c19e/heartbeat/pgsql</a>�</p>
<p><a href="">https://github.com/ClusterLabs/resource-agents/tree/abc1c3f6464f6e5e7a1e41cd7c9b8179896c1903/heartbeat</a>�</p>
<p>不含有ocf_local_nodename函数的pgsql脚本：</p>
<p><a href="">https://raw.github.com/ClusterLabs/resource-agents/a6f4ddf76cb4bbc1b3df4c9b6632a6351b63c19e/heartbeat/pgsql</a>�</p>
<h2 id="7-2-Q2"><a href="#7-2-Q2" class="headerlink" title="7.2 Q2"></a>7.2 Q2</h2><p>问题现象：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure load update pgsql.crm</span><br><span class="line">WARNING: pingCheck: specified timeout 60s for start is smaller than the advised 90</span><br><span class="line">WARNING: pingCheck: specified timeout 60s for stop is smaller than the advised 100</span><br><span class="line">WARNING: pgsql: specified timeout 60s for stop is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for start is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for notify is smaller than the advised 90</span><br><span class="line">WARNING: pgsql: specified timeout 60s for demote is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: specified timeout 60s for promote is smaller than the advised 120</span><br><span class="line">ERROR: master-group: attribute ordered does not exist</span><br><span class="line">Do you still want to commit? no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>错误提示：在定义的master-group中ordered属性不存在</p>
<p>（1）该问题是pacemaker版本所致，在pacemaker-1.1版本中不支持ordered,colocated属性，通过以下方法以1.0版本的cibconfig.py替换当前新版本试图解决此问题，结果失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# vim /usr/lib64/python2.6/site-packages/crmsh/cibconfig.py</span><br><span class="line">[root@node1 ~]# cd /usr/lib64/python2.6/site-packages/crmsh/</span><br><span class="line">[root@node1 crmsh]# mv cibconfig.py cibconfig.py.bak</span><br><span class="line">[root@node1 crmsh]# wget https://github.com/ClusterLabs/pacemaker-1.0/blob/fa1a99ab36e0ed015f1bcbbb28f7db962a9d1abc/shell/modules/cibconfig.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）从配置脚本中去除关于ordered的定义（成功）：</p>
<p>group master-group \</p>
<p>vip-master \</p>
<p>vip-rep \</p>
<p>meta \</p>
<p>ordered&#x3D;”false”</p>
<p>改为：</p>
<p>group master-group \</p>
<p>vip-master \</p>
<p>vip-rep</p>
<h2 id="7-3-Q3"><a href="#7-3-Q3" class="headerlink" title="7.3 Q3"></a>7.3 Q3</h2><p>问题现象：</p>
<p>安装pacemaker时报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install pacemaker*</span></span><br><span class="line">……</span><br><span class="line"><span class="meta prompt_">--&gt; </span><span class="language-bash">Processing Dependency: libesmtp.so.5()(64bit) <span class="keyword">for</span> package: pacemaker</span></span><br><span class="line"><span class="meta prompt_">--&gt; </span><span class="language-bash">Finished Dependency Resolution</span></span><br><span class="line">pacemaker-1.0.12-1.el5.centos.i386 from clusterlabs has depsolving problems</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">Missing Dependency: libesmtp.so.5 is needed by package pacemaker-1.0.12-1.el5.centos.i386 (clusterlabs)</span></span><br><span class="line">pacemaker-1.0.12-1.el5.centos.x86_64 from clusterlabs has depsolving problems</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">Missing Dependency: libesmtp.so.5()(64bit) is needed by package pacemaker-1.0.12-1.el5.centos.x86_64 (clusterlabs)</span></span><br><span class="line">Error: Missing Dependency: libesmtp.so.5 is needed by package pacemaker-1.0.12-1.el5.centos.i386 (clusterlabs)</span><br><span class="line">Error: Missing Dependency: libesmtp.so.5()(64bit) is needed by package pacemaker-1.0.12-1.el5.centos.x86_64 (clusterlabs)</span><br><span class="line"> You could try using --skip-broken to work around the problem</span><br><span class="line"> You could try running: package-cleanup --problems</span><br><span class="line">                        package-cleanup --dupes</span><br><span class="line">                        rpm -Va --nofiles --nodigest</span><br><span class="line">The program package-cleanup is found in the yum-utils package.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>提示缺少libesmtp，安装即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget ftp://ftp.univie.ac.at/systems/linux/fedora/epel/5/x86_64/libesmtp-1.0.4-5.el5.x86_64.rpm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget ftp://ftp.univie.ac.at/systems/linux/fedora/epel/5/i386/libesmtp-1.0.4-5.el5.i386.rpm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -ivh libesmtp-1.0.4-5.el5.x86_64.rpm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpm -ivh libesmtp-1.0.4-5.el5.i386.rpm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-4-Q4"><a href="#7-4-Q4" class="headerlink" title="7.4 Q4"></a>7.4 Q4</h2><p>问题现象：</p>
<p>加载crm配置时报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# crm configure load update pgsql.crm</span><br><span class="line">ERROR: pgsql: parameter rep_mode does not exist</span><br><span class="line">ERROR: pgsql: parameter node_list does not exist</span><br><span class="line">ERROR: pgsql: parameter master_ip does not exist</span><br><span class="line">ERROR: pgsql: parameter restore_command does not exist</span><br><span class="line">ERROR: pgsql: parameter primary_conninfo_opt does not exist</span><br><span class="line">WARNING: pgsql: specified timeout 60s for stop is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: action monitor_Master not advertised in meta-data, it may not be supported by the RA</span><br><span class="line">WARNING: pgsql: specified timeout 60s for start is smaller than the advised 120</span><br><span class="line">WARNING: pgsql: action notify not advertised in meta-data, it may not be supported by the RA</span><br><span class="line">WARNING: pgsql: action demote not advertised in meta-data, it may not be supported by the RA</span><br><span class="line">WARNING: pgsql: action promote not advertised in meta-data, it may not be supported by the RA</span><br><span class="line">WARNING: pingCheck: specified timeout 60s for start is smaller than the advised 90</span><br><span class="line">WARNING: pingCheck: specified timeout 60s for stop is smaller than the advised 100</span><br><span class="line">Do you still want to commit? no</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>参数不存在是因为pgsql脚本太旧，需要替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp pgsql root@192.168.100.201:/usr/lib/ocf/resource.d/heartbeat/</span><br><span class="line">scp ocf-shellfuncs.in root@192.168.100.201:/usr/lib/ocf/lib/heartbeat/</span><br><span class="line"></span><br><span class="line">scp pgsql root@192.168.100.202:/usr/lib/ocf/resource.d/heartbeat/</span><br><span class="line">scp ocf-shellfuncs.in root@192.168.100.202:/usr/lib/ocf/lib/heartbeat/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-5-Q5"><a href="#7-5-Q5" class="headerlink" title="7.5 Q5"></a>7.5 Q5</h2><p>问题现象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# crm_mon <span class="operator">-</span>Afr <span class="number">-1</span></span><br><span class="line"><span class="keyword">Last</span> updated: Tue Jan <span class="number">21</span> <span class="number">05</span>:<span class="number">10</span>:<span class="number">56</span> <span class="number">2014</span></span><br><span class="line"><span class="keyword">Last</span> change: Tue Jan <span class="number">21</span> <span class="number">05</span>:<span class="number">10</span>:<span class="number">08</span> <span class="number">2014</span> via cibadmin <span class="keyword">on</span> node1</span><br><span class="line">Stack: classic openais (<span class="keyword">with</span> plugin)</span><br><span class="line"><span class="keyword">Current</span> DC: node1 <span class="operator">-</span> <span class="keyword">partition</span> <span class="keyword">with</span> quorum</span><br><span class="line">Version: <span class="number">1.1</span><span class="number">.10</span><span class="number">-14.</span>el6_5<span class="number">.2</span><span class="number">-368</span>c726</span><br><span class="line"><span class="number">2</span> Nodes configured, <span class="number">2</span> expected votes</span><br><span class="line"><span class="number">7</span> Resources configured</span><br><span class="line"></span><br><span class="line">Online: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">Full</span> list <span class="keyword">of</span> resources:</span><br><span class="line"></span><br><span class="line"> vip<span class="operator">-</span>slave (ocf::heartbeat:IPaddr2): Stopped</span><br><span class="line"> Resource <span class="keyword">Group</span>: master<span class="operator">-</span><span class="keyword">group</span></span><br><span class="line">     vip<span class="operator">-</span>master (ocf::heartbeat:IPaddr2): Stopped</span><br><span class="line">     vip<span class="operator">-</span>rep (ocf::heartbeat:IPaddr2): Stopped</span><br><span class="line"> Master<span class="operator">/</span>Slave <span class="keyword">Set</span>: msPostgresql [pgsql]</span><br><span class="line">     Stopped: [ node1 node2 ]</span><br><span class="line"> Clone <span class="keyword">Set</span>: clnPingCheck [pingCheck]</span><br><span class="line">     Stopped: [ node1 node2 ]</span><br><span class="line"></span><br><span class="line">Node Attributes:</span><br><span class="line"><span class="operator">*</span> Node node1:</span><br><span class="line"><span class="operator">*</span> Node node2:</span><br><span class="line"></span><br><span class="line">Migration summary:</span><br><span class="line"><span class="operator">*</span> Node node1:</span><br><span class="line"><span class="operator">*</span> Node node2: </span><br><span class="line"></span><br><span class="line">Failed actions:</span><br><span class="line">    pingCheck_monitor_0 <span class="keyword">on</span> node1 <span class="string">&#x27;invalid parameter&#x27;</span> (<span class="number">2</span>): <span class="keyword">call</span><span class="operator">=</span><span class="number">23</span>, status<span class="operator">=</span>complete, <span class="keyword">last</span><span class="operator">-</span>rc<span class="operator">-</span>change<span class="operator">=</span><span class="string">&#x27;Tue Jan 21 05:10:10 2014&#x27;</span>, queued<span class="operator">=</span><span class="number">200</span>ms, <span class="keyword">exec</span><span class="operator">=</span><span class="number">0</span>ms</span><br><span class="line">    pingCheck_monitor_0 <span class="keyword">on</span> node2 <span class="string">&#x27;invalid parameter&#x27;</span> (<span class="number">2</span>): <span class="keyword">call</span><span class="operator">=</span><span class="number">23</span>, status<span class="operator">=</span>complete, <span class="keyword">last</span><span class="operator">-</span>rc<span class="operator">-</span>change<span class="operator">=</span><span class="string">&#x27;Tue Jan 21 05:09:36 2014&#x27;</span>, queued<span class="operator">=</span><span class="number">281</span>ms, <span class="keyword">exec</span><span class="operator">=</span><span class="number">0</span>ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>该错误是因为脚本定义中的pingCheck调用的pingd脚本中存在未知参数，经查ocf&#x2F;pacemaker&#x2F;pingd中不存在multiplier参数：</p>
<p>primitive pingCheck ocf:pacemaker:pingd \</p>
<p>params \</p>
<p>name&#x3D;”default_ping_set” \</p>
<p>host_list&#x3D;”192.168.100.1” \</p>
<p>multiplier&#x3D;”100” \</p>
<p>op start timeout&#x3D;”60s” interval&#x3D;”0s” on-fail&#x3D;”restart” \</p>
<p>op monitor timeout&#x3D;”60s” interval&#x3D;”10s” on-fail&#x3D;”restart” \</p>
<p>op stop timeout&#x3D;”60s” interval&#x3D;”0s” on-fail&#x3D;”ignore”</p>
<p>因此将调用改为ocf💓pingd</p>
<h2 id="7-6-Q6"><a href="#7-6-Q6" class="headerlink" title="7.6 Q6"></a>7.6 Q6</h2><p>问题现象：</p>
<p>corosync日志中报错：</p>
<p>Jan 21 04:36:02 corosync [TOTEM ] Received message has invalid digest… ignoring.</p>
<p>Jan 21 04:36:02 corosync [TOTEM ] Invalid packet data</p>
<p>解决方式：</p>
<p>说明网络中存在相同的多播，更改多播地址即可。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次没用创建成功 删除 所有配置 --- /var/lib/pacemaker/cib</span><br><span class="line">搭建高可用单播配置：cd /etc/corosync/corosync.conf</span><br><span class="line">        interface &#123;</span><br><span class="line">                member &#123;</span><br><span class="line">                     memberaddr:192.168.67.134</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 member &#123;</span><br><span class="line">                     memberaddr:192.168.67.135 </span><br><span class="line">                &#125;</span><br><span class="line">                ringnumber: 0</span><br><span class="line">                bindnetaddr: 192.168.67.0  （网段）</span><br><span class="line">                mcastport: 5405</span><br><span class="line">                ttl: 1</span><br><span class="line">        &#125;</span><br><span class="line"> 在推荐的网络接口配置中有几件事需要注意：</span><br><span class="line">所有心跳网络的 ringnumber 配置不能重复，最小值为 0 。</span><br><span class="line">bindnetaddr 是心跳网卡 IP 地址对应的网络地址。示例中使用了两个子网掩码为 /24 的 IPv4 网段。</span><br><span class="line">Corosync 通信使用 UDP 协议，端口为 mcastport （接收数据）和 mcastport - 1 （发送数据）。配置防火墙时需要打开这两个端口。</span><br><span class="line">pgsql.crm--------内容</span><br><span class="line">primitive pingCheck ocf:pacemaker:ping \</span><br><span class="line">   params \</span><br><span class="line">        name=&quot;default_ping_set&quot; \</span><br><span class="line">        host_list=&quot;192.168.67.1&quot; \ (使用网关地址，必须是ping通)</span><br><span class="line">        multiplier=&quot;100&quot; \</span><br><span class="line">        </span><br><span class="line">[postgres@node2 ~]$ crm_mon -Afr -1 ---（错误：权限不足，必须是root用户）</span><br><span class="line">Could not establish cib_ro connection: No such file or directory (2)</span><br><span class="line"></span><br><span class="line">Connection to cluster failed: Transport endpoint is not connected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VIP 192.168.67.130 必须在一个网段</span><br></pre></td></tr></table></figure>





<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p>脚本：</p>
<p><a href="">https://github.com/ClusterLabs/resource-agents/blob/master/heartbeat/pgsql</a>�</p>
<p>脚本使用说明：</p>
<p><a href="">https://github.com/t-matsuo/resource-agents/wiki/Resource-Agent-for-PostgreSQL-9.1-streaming-replication</a>�</p>
<p>crm_resouce命令：</p>
<p><a href="http://www.novell.com/zh-cn/documentation/sle_ha/book_sleha/data/man_crmresource.html">http://www.novell.com/zh-cn/documentation/sle_ha/book_sleha/data/man_crmresource.html</a>�</p>
<p>crm_failcount命令：</p>
<p><a href="http://www.novell.com/zh-cn/documentation/sle_ha/book_sleha/data/man_crmfailcount.html">http://www.novell.com/zh-cn/documentation/sle_ha/book_sleha/data/man_crmfailcount.html</a>�</p>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip指定安装源安装类库</title>
    <url>/knowledge-base/2019/08/31/pip-config/</url>
    <content><![CDATA[<div class="note primary"><p>解决下载速度慢</p>
</div>
<span id="more"></span>

<p>用pip安装依赖包时默认访问 <a href="https://pypi.python.org/simple/">https://pypi.Python.org/simple/</a></p>
<p>但是很多包因为网速问题经常安装不上，这时候就需要选择国内的一些安装源安装相应的包</p>
<pre><code>豆瓣 http://pypi.douban.com/ 
中国科学技术大学http://pypi.mirrors.ustc.edu.cn/simple/ 
清华：https://pypi.tuna.tsinghua.edu.cn/simple
阿里云：http://mirrors.aliyun.com/pypi/simple/
华中理工大学：http://pypi.hustunique.com/
山东理工大学：http://pypi.sdutlinux.org/ 
</code></pre>
<h3 id="pip版本更新"><a href="#pip版本更新" class="headerlink" title="pip版本更新"></a>pip版本更新</h3><p>window：</p>
<p>python -m pip install -U pip</p>
<p>on Linux or macOS:</p>
<p>pip install -U pip</p>
<h4 id="有两种方式使用我们自己指定的镜像源，第一种是手动指定："><a href="#有两种方式使用我们自己指定的镜像源，第一种是手动指定：" class="headerlink" title="有两种方式使用我们自己指定的镜像源，第一种是手动指定："></a>有两种方式使用我们自己指定的镜像源，第一种是手动指定：</h4><pre><code>pip install Numpy -i https://pypi.tuna.tsinghua.edu.cn/simple 
</code></pre>
<h4 id="第二种：你可以把它写在配置文件中"><a href="#第二种：你可以把它写在配置文件中" class="headerlink" title="第二种：你可以把它写在配置文件中"></a>第二种：你可以把它写在配置文件中</h4><p>Linux&#x2F;OSX : 在当前用户目录下创建.pip文件夹</p>
<pre><code>mkdir ~/.pip
</code></pre>
<h4 id="然后在该目录下创建pip-conf文件填写："><a href="#然后在该目录下创建pip-conf文件填写：" class="headerlink" title="然后在该目录下创建pip.conf文件填写："></a>然后在该目录下创建pip.conf文件填写：</h4><pre><code>[global]
trusted-host=mirrors.aliyun.com
index-url=http://mirrors.aliyun.com/pypi/simple/
</code></pre>
<p>Windows：创建%HOMEPATH%\pip\pip.ini文件来配置。</p>
<p>例如：C:\Users\fxl\pip\pip.ini</p>
<p>pip.ini配置的主要一些配置：</p>
<p>[global]<br>trusted-host&#x3D;mirrors.aliyun.com<br>index-url&#x3D;<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>​	</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql 表空间创建、删除</title>
    <url>/knowledge-base/2018/05/31/pg-tablespace/</url>
    <content><![CDATA[<div class="note info"><p>表空间：字面上理解就是表存储的物理空间，其实包括数据库的表、索引、序列等。</p>
<p>可以将表空间创建在服务器的不同分区，这样做的好处有：</p>
<p>一、如果初始化集群所在分区已经用光，可以方便的其他分区上创建表空间已达到扩容的目的。</p>
<p>二、对于频繁访问的数据可以存储在性能较高、较快的磁盘分区上，而不常用的数据存储在便宜的较慢的磁盘分区上。</p>
</div>

<span id="more"></span>

<h1 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h1><p>语法：</p>
<p>postgres&#x3D;# \h create tablespace<br>Command:     CREATE TABLESPACE<br>Description: define a new tablespace<br>Syntax:<br>CREATE TABLESPACE tablespace_name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ OWNER user_name ]</span><br><span class="line">LOCATION &#x27;directory&#x27;</span><br><span class="line">[ WITH ( tablespace_option = value [, ... ] ) ]</span><br></pre></td></tr></table></figure>

<p>用户必须有表空间所在目录访问权限，所以在创建表空间之前需要在对应分区下创建相应的目录，并为其分配权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /usr/local/pgdata</span><br><span class="line">[root@localhost ~]# chown postgres:postgres /usr/local/pgdata/</span><br></pre></td></tr></table></figure>

<p> 创建表空间示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres=# create tablespace tbs_test owner postgres location &#x27;/usr/local/pgdata&#x27;;</span><br><span class="line">CREATE TABLESPACE </span><br></pre></td></tr></table></figure>

<p>创建表空间成功后，可在数据库集群目录下看到一个新增的目录pg_tblspc下有一个连接文件51276,指向到&#x2F;usr&#x2F;local&#x2F;pgdata下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /mnt/syncdata/pgsql941/data/pg_tblspc/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 postgres postgres 17 Aug 30 02:06 51276 -&gt; /usr/local/pgdata</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /usr/local/pgdata/</span><br><span class="line">total 4</span><br><span class="line">drwx------. 2 postgres postgres 4096 Aug 30 02:06 PG_9.4_201409291</span><br></pre></td></tr></table></figure>

<p>在此表空间内创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">create</span> <span class="keyword">table</span> test(a <span class="type">int</span>) tablespace tbs_test;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>

<p>现在在表空间目录下就会新增一个test表对应的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /usr/local/pgdata/PG_9.4_201409291/13003/51277 </span><br><span class="line">-rw-------. 1 postgres postgres 0 Aug 30 02:15 /usr/local/pgdata/PG_9.4_201409291/13003/51277</span><br></pre></td></tr></table></figure>

<p>其中51277对应的是test表的relfilenode，13003是数据库postgres的oid。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> oid,datname <span class="keyword">from</span> pg_database <span class="keyword">where</span> datname <span class="operator">=</span> <span class="string">&#x27;postgres&#x27;</span>;</span><br><span class="line">  oid  <span class="operator">|</span> datname  </span><br><span class="line"><span class="comment">-------+----------</span></span><br><span class="line"> <span class="number">13003</span> <span class="operator">|</span> postgres</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> relname,relfilenode <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"> relname <span class="operator">|</span> relfilenode </span><br><span class="line"><span class="comment">---------+-------------</span></span><br><span class="line"> test    <span class="operator">|</span>       <span class="number">51277</span></span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>

<h1 id="删除表空"><a href="#删除表空" class="headerlink" title="删除表空"></a>删除表空</h1><p>postgres&#x3D;# \h drop tablespace<br>Command:     DROP TABLESPACE<br>Description: remove a tablespace<br>Syntax:<br>DROP TABLESPACE [ IF EXISTS ] name</p>
<p>删除表空间前必须要删除该表空间下的所有数据库对象，否则无法删除。</p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">drop</span> tablespace if <span class="keyword">exists</span> tbs_test;</span><br><span class="line">ERROR:  tablespace &quot;tbs_test&quot; <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">empty</span></span><br></pre></td></tr></table></figure>

<p>删除刚才在此表空间创建的表test，然后再删除表空间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> test;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">drop</span> tablespace if <span class="keyword">exists</span> tbs_test;</span><br><span class="line"><span class="keyword">DROP</span> TABLESPACE</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>postgres日常使用</title>
    <url>/knowledge-base/2018/05/31/postgres/</url>
    <content><![CDATA[<div class="note warning"><p>主要记录本人平时使用的postgres的建库，备库和日常使用的SQL语句，其中涉及一点postgres的高可用运维内容和数据库的注意事项。</p>
</div>

<span id="more"></span>

<h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">initdb <span class="operator">-</span>D <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>pgsql<span class="operator">/</span><span class="number">10</span><span class="operator">/</span>data <span class="operator">-</span>U postgres <span class="operator">-</span>W <span class="operator">-</span>E UTF8 <span class="comment">--locale=zh_CN.UTF-8    </span></span><br><span class="line">initdb <span class="operator">-</span>D <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>pgsql<span class="operator">/</span><span class="number">10</span><span class="operator">/</span>data <span class="operator">-</span>U postgres <span class="operator">-</span>W <span class="operator">-</span>E UTF8 <span class="comment">--locale=zh_CN.UTF-8 --debug --data-checksums</span></span><br></pre></td></tr></table></figure>
<h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test <span class="keyword">WITH</span> OWNER <span class="operator">=</span> postgres ENCODING <span class="operator">=</span> <span class="string">&#x27;UTF8&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看表的索引："><a href="#查看表的索引：" class="headerlink" title="查看表的索引："></a>查看表的索引：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_indexes <span class="keyword">where</span> tablename<span class="operator">=</span><span class="string">&#x27;log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="导出备份数据库："><a href="#导出备份数据库：" class="headerlink" title="导出备份数据库："></a>导出备份数据库：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres databasename <span class="operator">&gt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>databasename.bak.yyyymmdd.sql</span><br></pre></td></tr></table></figure>

<h5 id="导入恢复数据库-sql文件是pg-dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等"><a href="#导入恢复数据库-sql文件是pg-dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等" class="headerlink" title="导入恢复数据库(sql文件是pg_dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等)"></a>导入恢复数据库(sql文件是pg_dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等)</h5><figure class="highlight sql"><figcaption><span>lite</span></figcaption><table><tr><td class="code"><pre><span class="line">psql <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>d databasename <span class="operator">&lt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>databasename.bak.yyyymmdd.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出数据结构，主要是加上参数-s："><a href="#导出数据结构，主要是加上参数-s：" class="headerlink" title="导出数据结构，主要是加上参数-s："></a>导出数据结构，主要是加上参数-s：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>U username <span class="operator">-</span>W dbname <span class="operator">-</span>f <span class="operator">/</span>tmp<span class="operator">/</span>filename.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表："><a href="#导出某个表：" class="headerlink" title="导出某个表："></a>导出某个表：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename dbname <span class="operator">&gt;</span> test.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表的结构，同样是加参数”-s”："><a href="#导出某个表的结构，同样是加参数”-s”：" class="headerlink" title="导出某个表的结构，同样是加参数”-s”："></a>导出某个表的结构，同样是加参数”-s”：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename <span class="operator">-</span>s dbname <span class="operator">&gt;</span> test_construct.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表的数据，加参数”-a”："><a href="#导出某个表的数据，加参数”-a”：" class="headerlink" title="导出某个表的数据，加参数”-a”："></a>导出某个表的数据，加参数”-a”：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename <span class="operator">-</span>a dbname <span class="operator">&gt;</span> test_data.sql</span><br></pre></td></tr></table></figure>
<h4 id="删除主键-x2F-添加主键"><a href="#删除主键-x2F-添加主键" class="headerlink" title="删除主键&#x2F;添加主键"></a>删除主键&#x2F;添加主键</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> server <span class="keyword">drop</span> <span class="keyword">constraint</span> server_pkey ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> server <span class="keyword">add</span> <span class="keyword">primary</span> key (id,test) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看序列：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.sequences <span class="keyword">where</span> sequence_schema <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span>;</span><br><span class="line">查看数据库大小：<span class="keyword">select</span> pg_size_pretty(pg_database_size(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">查看表的大小：<span class="keyword">select</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;test&#x27;</span>));</span><br></pre></td></tr></table></figure>


<h5 id="由于-copy-命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作-而-copy-命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在-DBA-手中。"><a href="#由于-copy-命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作-而-copy-命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在-DBA-手中。" class="headerlink" title="由于 copy 命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作;而 \copy 命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在 DBA 手中。"></a>由于 copy 命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作;而 \copy 命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在 DBA 手中。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename) <span class="keyword">to</span> <span class="string">&#x27;/tmp/1.txt&#x27;</span> (format csv,delimiter <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">\<span class="keyword">copy</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename) <span class="keyword">to</span> <span class="string">&#x27;/tmp/1.txt&#x27;</span> <span class="keyword">with</span> delimiter <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line"></span><br><span class="line">psql <span class="operator">-</span>c &quot;\copy (select * from PBX_CASH_RCV_REG where TRAN_DATE=&#x27;20170913&#x27;) to &#x27;PBX_CASH_RCV_REG.txt&#x27; with delimiter &#x27;|&#x27; NULL &#x27; &#x27;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="清除所有表"><a href="#清除所有表" class="headerlink" title="清除所有表"></a>清除所有表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> aaa() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    tmp <span class="type">VARCHAR</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> names <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> </span><br><span class="line">    <span class="keyword">select</span> tablename <span class="keyword">from</span> pg_tables <span class="keyword">where</span> schemaname<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> ;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> stmt <span class="keyword">IN</span> names LOOP</span><br><span class="line">    tmp :<span class="operator">=</span> <span class="string">&#x27;DROP TABLE &#x27;</span><span class="operator">||</span> quote_ident(stmt.tablename) <span class="operator">||</span> <span class="string">&#x27; CASCADE;&#x27;</span>;</span><br><span class="line">RAISE NOTICE <span class="string">&#x27;notice: %&#x27;</span>, tmp;</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">&#x27;DROP TABLE &#x27;</span><span class="operator">||</span> quote_ident(stmt.tablename) <span class="operator">||</span> <span class="string">&#x27; CASCADE;&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line">  RAISE NOTICE <span class="string">&#x27;finished .....&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line">调用时用：</span><br><span class="line"><span class="keyword">select</span> aaa();</span><br></pre></td></tr></table></figure>

<h5 id="获取系统表中字段信息"><a href="#获取系统表中字段信息" class="headerlink" title="获取系统表中字段信息"></a>获取系统表中字段信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.attnum,a.attname <span class="keyword">AS</span> field,t.typname <span class="keyword">AS</span> type,a.attlen <span class="keyword">AS</span> length,a.atttypmod <span class="keyword">AS</span> lengthvar,a.attnotnull <span class="keyword">AS</span> notnull <span class="keyword">FROM</span> pg_class c,pg_attribute a,pg_type t</span><br><span class="line"><span class="keyword">WHERE</span> c.relname <span class="operator">=</span> <span class="string">&#x27;dbmanager_hostlist&#x27;</span> <span class="keyword">and</span> a.attnum <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> a.attrelid <span class="operator">=</span> c.oid <span class="keyword">and</span> a.atttypid <span class="operator">=</span> t.oid <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.attnum;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\dtS   <span class="comment">--- 查看系统表</span></span><br><span class="line">\dtS<span class="operator">+</span>  <span class="comment">---  查看详细信息</span></span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">table</span> t <span class="keyword">IS</span> <span class="string">&#x27;this is a test&#x27;</span>; <span class="comment">--- 添加表注释</span></span><br><span class="line">\<span class="keyword">set</span> AUTOCOMMIT off <span class="comment">--- 关闭自动更新</span></span><br></pre></td></tr></table></figure>

<h5 id="指定去重的列排序"><a href="#指定去重的列排序" class="headerlink" title="指定去重的列排序"></a>指定去重的列排序</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">on</span> (subject) id,name,subject,score <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> subject,score <span class="keyword">desc</span>;</span><br><span class="line">扫描<span class="number">10</span>行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h5 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq</span><br><span class="line"><span class="keyword">select</span> nextval(<span class="string">&#x27;seq&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> nextval(<span class="string">&#x27;seq&#x27;</span>) <span class="keyword">from</span> window_test;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">function</span> nextval(regclass) volatile; <span class="comment">-- 只执行一遍 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">function</span> nextval(regclass) stable; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> generate_series(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">as</span> g(i) <span class="keyword">where</span> i <span class="operator">=</span> nextval(<span class="string">&#x27;seq&#x27;</span>::regclass);</span><br></pre></td></tr></table></figure>

<h5 id="锁表问题"><a href="#锁表问题" class="headerlink" title="锁表问题"></a>锁表问题</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询是否锁表了                                       </span></span><br><span class="line"><span class="keyword">select</span> oid <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname<span class="operator">=</span><span class="string">&#x27;可能锁表了的表&#x27;</span></span><br><span class="line"><span class="keyword">select</span> pid <span class="keyword">from</span> pg_locks <span class="keyword">where</span> relation<span class="operator">=</span><span class="string">&#x27;上面查出的oid&#x27;</span></span><br><span class="line"><span class="comment">--如果查询到了结果，表示该表被锁 则需要释放锁定        </span></span><br><span class="line"><span class="keyword">select</span> pg_cancel_backend(上面查到的pid) </span><br></pre></td></tr></table></figure>

<h5 id="增删改查的操作"><a href="#增删改查的操作" class="headerlink" title="增删改查的操作"></a>增删改查的操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 修改字段名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ubb_model rename <span class="keyword">column</span> hostname <span class="keyword">to</span> hostgroup;</span><br><span class="line"><span class="comment">--- 删除唯一约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ubb_services <span class="keyword">drop</span> <span class="keyword">constraint</span> ubb_services_services_key;</span><br><span class="line"><span class="comment">--- 增加一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype;                   </span><br><span class="line"><span class="comment">--- 删除一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span>  column_name;                           </span><br><span class="line"><span class="comment">--- 更改列的数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span>  column_name TYPE datatype;              </span><br><span class="line"><span class="comment">--- 表的重命名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME <span class="keyword">TO</span> new_name;                           </span><br><span class="line"><span class="comment">--- 更改列的名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME column_name <span class="keyword">to</span> new_column_name;          </span><br><span class="line"><span class="comment">--- 字段的not null设置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> column_name &#123;<span class="keyword">SET</span><span class="operator">|</span><span class="keyword">DROP</span>&#125; <span class="keyword">NOT</span> <span class="keyword">NULL</span>;          </span><br><span class="line"><span class="comment">--- 给列添加default</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> column_name <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> expression;</span><br><span class="line"><span class="comment">--- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> <span class="keyword">primary</span> key(sid);</span><br><span class="line"><span class="comment">--- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orders <span class="keyword">add</span> <span class="keyword">foreign</span> key(goods_id) <span class="keyword">references</span> goods(sid)  <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade: <span class="comment">--- 被引用行更新时，引用行自动更新； </span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> restrict: <span class="comment">--- 被引用的行禁止更新；</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade: <span class="comment">--- 被引用行删除时，引用行也一起删除；</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict: <span class="comment">--- 被引用的行禁止删除；</span></span><br><span class="line"><span class="comment">--- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orders <span class="keyword">drop</span> <span class="keyword">constraint</span> orders_goods_id_fkey;</span><br><span class="line"><span class="comment">--- 添加唯一约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> <span class="keyword">constraint</span> unique_goods_sid <span class="keyword">unique</span>(sid);</span><br><span class="line"><span class="comment">--- 删除默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods  <span class="keyword">alter</span> <span class="keyword">column</span> sid <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">---  修改字段的数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">alter</span> <span class="keyword">column</span> sid type <span class="type">character</span> <span class="type">varying</span>;</span><br><span class="line"><span class="comment">--- 重命名字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods rename <span class="keyword">column</span> sid <span class="keyword">to</span> ssid;</span><br></pre></td></tr></table></figure>

<h5 id="时间的使用方法"><a href="#时间的使用方法" class="headerlink" title="时间的使用方法:"></a>时间的使用方法:</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  to_char(<span class="built_in">CURRENT_DATE</span>,<span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span>  to_char(<span class="built_in">CURRENT_TIMESTAMP</span>,<span class="string">&#x27;YYYYMMDD&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span>  to_char(<span class="built_in">CURRENT_TIMESTAMP</span>,<span class="string">&#x27;YYYYMMDDMSUS&#x27;</span>);	</span><br><span class="line"><span class="keyword">select</span>  to_char(<span class="built_in">CURRENT_TIMESTAMP</span>,<span class="string">&#x27;HH24MISS&#x27;</span>);</span><br><span class="line"><span class="comment">--- 时间的计算</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_DATE</span>  <span class="operator">+</span> <span class="type">integer</span> <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_TIME</span>  <span class="operator">+</span> <span class="type">interval</span> <span class="string">&#x27;1 hour&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_TIME</span>  <span class="operator">+</span> <span class="type">time</span> <span class="string">&#x27;03:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="如何找到postgreSQL数据库中占空间最大的表？"><a href="#如何找到postgreSQL数据库中占空间最大的表？" class="headerlink" title="如何找到postgreSQL数据库中占空间最大的表？"></a>如何找到postgreSQL数据库中占空间最大的表？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> relname,relpages <span class="keyword">FROM</span> pg_class <span class="keyword">ORDER</span> <span class="keyword">BY</span> relpages <span class="keyword">DESC</span>;</span><br><span class="line">如果你只想要最大的那个表，可以用limit参数来限制结果的数量，就像这样：</span><br><span class="line"><span class="keyword">SELECT</span> relname, relpages <span class="keyword">FROM</span> pg_class <span class="keyword">ORDER</span> <span class="keyword">BY</span> relpages <span class="keyword">DESC</span> limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>relname <span class="operator">-</span> 关系名<span class="operator">/</span>表名</span><br><span class="line"><span class="number">2.</span>relpages <span class="operator">-</span> 关系页数（默认情况下一个页大小是<span class="number">8</span>kb）</span><br><span class="line"><span class="number">3.</span>pg_class <span class="operator">-</span> 系统表, 维护着所有relations的详细信息</span><br><span class="line"><span class="number">4.</span>limit <span class="number">1</span> <span class="operator">-</span> 限制返回结果只显示一行</span><br></pre></td></tr></table></figure>

<h5 id="如何计算postgreSQL数据库所占用的硬盘大小？"><a href="#如何计算postgreSQL数据库所占用的硬盘大小？" class="headerlink" title="如何计算postgreSQL数据库所占用的硬盘大小？"></a>如何计算postgreSQL数据库所占用的硬盘大小？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_database_size 这个方法是专门用来查询数据库大小的，它返回的结果单位是字节（bytes）。:</span><br><span class="line"><span class="keyword">SELECT</span> pg_database_size(<span class="string">&#x27;geekdb&#x27;</span>);</span><br><span class="line">如果你想要让结果更直观一点，那就使用pg_size_pretty方法，它可以把字节数转换成更友好易读的格式。</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_database_size(<span class="string">&#x27;geekdb&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="如何计算postgreSQL表所占用的硬盘大小？"><a href="#如何计算postgreSQL表所占用的硬盘大小？" class="headerlink" title="如何计算postgreSQL表所占用的硬盘大小？"></a>如何计算postgreSQL表所占用的硬盘大小？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">下面这个命令查出来的表大小是包含索引和toasted data的，如果你对除去索引外仅仅是表占的大小感兴趣，可以 使用后面提供的那个命令。</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_total_relation_size(<span class="string">&#x27;big_table&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="类别一、-如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法："><a href="#类别一、-如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法：" class="headerlink" title="类别一、 如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法："></a>类别一、 如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  目标表  SELECT  * FROM  来源表 ;</span><br></pre></td></tr></table></figure>

<h5 id="要将-articles-表插入到-newArticles-表中，则可以通过如下SQL语句实现："><a href="#要将-articles-表插入到-newArticles-表中，则可以通过如下SQL语句实现：" class="headerlink" title="要将 articles 表插入到 newArticles 表中，则可以通过如下SQL语句实现："></a>要将 articles 表插入到 newArticles 表中，则可以通过如下SQL语句实现：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  newArticles  SELECT  * FROM  articles ;</span><br></pre></td></tr></table></figure>

<h5 id="如果只希望导入指定字段，可以用这种方法："><a href="#如果只希望导入指定字段，可以用这种方法：" class="headerlink" title="如果只希望导入指定字段，可以用这种方法："></a>如果只希望导入指定字段，可以用这种方法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  目标表 (字段1, 字段2, ...)  SELECT   字段1, 字段2, ...   FROM  来源表 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TPersonnelChange(  </span><br><span class="line">    UserId,  </span><br><span class="line">    DepId,  </span><br><span class="line">    SubDepId,  </span><br><span class="line">    PostionType,  </span><br><span class="line">    AuthorityId,  </span><br><span class="line">    ChangeDateS,  </span><br><span class="line">    InsertDate,  </span><br><span class="line">    UpdateDate,  </span><br><span class="line">    SakuseiSyaId  </span><br><span class="line">)<span class="keyword">SELECT</span>  </span><br><span class="line">    UserId,  </span><br><span class="line">    DepId,  </span><br><span class="line">    SubDepId,  </span><br><span class="line">    PostionType,  </span><br><span class="line">    AuthorityId,  </span><br><span class="line">    DATE_FORMAT(EmployDate, <span class="string">&#x27;%Y%m%d&#x27;</span>),  </span><br><span class="line">    NOW(),  </span><br><span class="line">    NOW(),  </span><br><span class="line">    <span class="number">1</span>  </span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    TUserMst  </span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">    `Status` <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">AND</span> QuitFlg <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">AND</span> UserId <span class="operator">&gt;</span> <span class="number">2</span>  </span><br></pre></td></tr></table></figure>

<h5 id="generate-series函数应用"><a href="#generate-series函数应用" class="headerlink" title="generate_series函数应用"></a><a href="http://www.cnblogs.com/mchina/archive/2013/04/03/2997722.html">generate_series函数应用</a></h5><h5 id="批量添加数据"><a href="#批量添加数据" class="headerlink" title="批量添加数据"></a>批量添加数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> generate_series(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">--- int</span></span><br><span class="line"><span class="keyword">select</span> generate_series(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>); <span class="comment">--- 如果step 是正数，而start 大于stop，那么返回零行。相反，如果step 是负数，start 小于stop，则返回零行。如果是NULL 输入，也产生零行。step 为零则是一个错误。</span></span><br><span class="line"><span class="keyword">select</span> generate_series(<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">select</span> generate_series(now(), now() <span class="operator">+</span> <span class="string">&#x27;7 days&#x27;</span>, <span class="string">&#x27;1 day&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> generate_series(to_date(<span class="string">&#x27;20130403&#x27;</span>,<span class="string">&#x27;yyyymmdd&#x27;</span>), to_date(<span class="string">&#x27;20130404&#x27;</span>,<span class="string">&#x27;yyyymmdd&#x27;</span>), <span class="string">&#x27;3 hours&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<h4 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如何锁一个表的某一行</span><br><span class="line">select * from table rowlock where id =1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> localdatetime,retcode,respinfo <span class="keyword">from</span>  ol_transdetail <span class="keyword">where</span> localdatetime<span class="operator">&gt;</span> <span class="string">&#x27;20180109100000&#x27;</span> <span class="keyword">and</span> receprodcode<span class="operator">=</span><span class="string">&#x27;612020&#x27;</span> <span class="keyword">and</span> retcode<span class="operator">=</span><span class="string">&#x27;09209999&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span>  localdatetime<span class="operator">&gt;</span><span class="string">&#x27;20180109163000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时 <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span> localdate <span class="operator">=</span><span class="string">&#x27;20180329&#x27;</span>  <span class="keyword">and</span> localdatetime <span class="operator">&gt;</span> <span class="string">&#x27;20180329170300&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">DISTINCT</span>(logip) <span class="keyword">from</span> ol_transdetail  ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时  <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span> localdatetime <span class="operator">&gt;=</span> to_char(now() <span class="operator">-</span> <span class="type">interval</span> <span class="string">&#x27;1 min&#x27;</span>,<span class="string">&#x27;YYYYMMDDHHMMSS&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span>  logip ,retcode;</span><br></pre></td></tr></table></figure>

<h4 id="每分钟查询结果"><a href="#每分钟查询结果" class="headerlink" title="每分钟查询结果"></a>每分钟查询结果</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时 <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span>  localdatetime <span class="operator">&gt;</span> to_char(now() <span class="operator">-</span> <span class="type">interval</span> <span class="string">&#x27;1 min&#x27;</span>,<span class="string">&#x27;YYYYMMDDHHMISS&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),渠道耗时 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建基础备份"><a href="#创建基础备份" class="headerlink" title="创建基础备份"></a>创建基础备份</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">	vi pg_hba.conf</span><br><span class="line">	host <span class="keyword">all</span> <span class="keyword">all</span>  <span class="number">192.168</span><span class="number">.67</span><span class="number">.35</span><span class="operator">/</span><span class="number">24</span>             md5</span><br><span class="line">	host replication postgres <span class="number">192.168</span><span class="number">.67</span><span class="number">.35</span><span class="operator">/</span><span class="number">24</span> trust</span><br><span class="line">	pg_basebackup <span class="operator">-</span>h node1 <span class="operator">-</span>U replication <span class="operator">-</span>D <span class="operator">/</span>data<span class="operator">/</span>postgresql<span class="operator">/</span>data<span class="operator">/</span> <span class="operator">-</span>X stream <span class="operator">-</span>P</span><br><span class="line">查看主备关系</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_stat_replication ;</span><br></pre></td></tr></table></figure>

<h3 id="用pg-rewind命令同步新备库"><a href="#用pg-rewind命令同步新备库" class="headerlink" title="用pg_rewind命令同步新备库"></a>用pg_rewind命令同步新备库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pg_rewind --target-pgdata $PGDATA --source-server=&#x27;host=192.168.1.203 port=5432 user=postgres dbname=postgres&#x27; -P</span><br><span class="line">mv recovery.done recovery.conf</span><br><span class="line">vi recovery.conf</span><br></pre></td></tr></table></figure>

<h3 id="高可用（pcs-corosync-postgres）修复旧Master"><a href="#高可用（pcs-corosync-postgres）修复旧Master" class="headerlink" title="高可用（pcs+corosync+postgres）修复旧Master"></a>高可用（pcs+corosync+postgres）修复旧Master</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检查集群状态   </span><br><span class="line">由于设置了migration-threshold=&quot;3&quot;，发生一次普通的错误，Pacemaker会在原地重新启动postgres进程，不发生主从切换。</span><br><span class="line">（如果Master的物理机或网络发生故障，直接进行failover。）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一种方法：可通过<code>pg_basebackup</code>修复旧Master（需要强行恢复的情况下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># su - postgres</span><br><span class="line">$ rm -rf /data/postgresql/data</span><br><span class="line">$ pg_basebackup -h 192.168.41.136 -U postgres -D /data/postgresql/data -X stream -P</span><br><span class="line">$ exit</span><br><span class="line"># pcs resource cleanup msPostgresql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种方法：通过<code>pg_baseback</code>修复旧Master。<code>cls_rebuild_slave</code>是对<code>pg_basebackup</code>的包装，主要多了执行结果状态的检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# rm -rf /data/postgresql/data</span><br><span class="line">[root@node1 pha4pgsql]# cls_rebuild_slave </span><br><span class="line">22636/22636 kB (100%), 1/1 tablespace</span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">wait for recovery complete</span><br><span class="line">.....</span><br><span class="line">slave recovery of node1 successed</span><br><span class="line">[root@node1 pha4pgsql]# cls_status</span><br><span class="line">Last updated: Fri Apr 22 02:40:48 2016</span><br><span class="line">Last change: Fri Apr 22 02:40:36 2016 by root via crm_resource on node1</span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (2) - partition with quorum</span><br><span class="line">Version: 1.1.12-a14efad</span><br><span class="line">2 Nodes configured</span><br><span class="line">4 Resources configured</span><br></pre></td></tr></table></figure>

<p>第三种方法: 9.5以上版本还可以通过<code>pg_rewind</code>修复旧Master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# cls_repair_by_pg_rewind </span><br><span class="line">connected to server</span><br><span class="line">servers diverged at WAL position 0/7000410 on timeline 2</span><br><span class="line">rewinding from last common checkpoint at 0/7000368 on timeline 2</span><br><span class="line">reading source file list</span><br><span class="line">reading target file list</span><br><span class="line">reading WAL in target</span><br><span class="line">need to copy 67 MB (total source directory size is 85 MB)</span><br><span class="line">69591/69591 kB (100%) copied</span><br><span class="line">creating backup label and updating control file</span><br><span class="line">syncing target data directory</span><br><span class="line">Done!</span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">wait for recovery complete</span><br><span class="line">....</span><br><span class="line">slave recovery of node1 successed </span><br></pre></td></tr></table></figure>

<h3 id="高可用（pcs-corosync-postgres）Slave上进程故障"><a href="#高可用（pcs-corosync-postgres）Slave上进程故障" class="headerlink" title="高可用（pcs+corosync+postgres）Slave上进程故障"></a>高可用（pcs+corosync+postgres）Slave上进程故障</h3><p>再强制杀死Master上的postgres进程2次后检查集群状态。</p>
<p>fail-count增加到3后，Pacemaker不再启动PostgreSQL，保持其为停止状态。</p>
<p>同时，Master(node1)(VIP所在的主机)上的复制模式被自动切换到异步复制，防止写操作hang住。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# tail /var/lib/pgsql/tmp/rep_mode.conf</span><br><span class="line">synchronous_standby_names = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="修复Salve"><a href="#修复Salve" class="headerlink" title="修复Salve"></a>修复Salve</h4><p>在node2上执行<code>cls_cleanup</code>，清除fail-count后，Pacemaker会再次启动PostgreSQL进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# cls_cleanup </span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">[root@node2 ~]# cls_status </span><br><span class="line">Last updated: Sun May  8 01:43:13 2016</span><br><span class="line">Last change: Sun May  8 01:43:08 2016 by root via crm_resource on node1</span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (2) - partition with quorum</span><br><span class="line">Version: 1.1.12-a14efad</span><br><span class="line">2 Nodes configured</span><br><span class="line">4 Resources configured</span><br></pre></td></tr></table></figure>

<p>同时，Master(node1)上的复制模式又自动切换回到同步复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# tail /var/lib/pgsql/tmp/rep_mode.conf</span><br><span class="line">synchronous_standby_names = &#x27;node2&#x27;(只会有同步流复制)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><p>出现故障时，可通过以下方法排除故障</p>
<ol>
<li><p>确认集群服务是否OK</p>
<p>pcs status</p>
</li>
<li><p>查看错误日志</p>
<p>PostgreSQL的错误日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/messages</span><br><span class="line">/var/log/cluster/corosync.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Pacemaker输出的日志非常多，可以进行过滤。</p>
<p>只看Pacemaker的资源调度（在Current DC节点上执行)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep Initiating /var/log/messages </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只查看expgsql RA的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep expgsql /var/log/messages</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其它故障的处理"><a href="#其它故障的处理" class="headerlink" title="其它故障的处理"></a>其它故障的处理</h2><h3 id="无Master时的修复"><a href="#无Master时的修复" class="headerlink" title="无Master时的修复"></a>无Master时的修复</h3><p>如果切换失败或其它原因导致集群中没有Master，可以参考下面的步骤修复</p>
<h4 id="方法1：使用cleanup修复"><a href="#方法1：使用cleanup修复" class="headerlink" title="方法1：使用cleanup修复"></a>方法1：使用cleanup修复</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cls_cleanup</span><br></pre></td></tr></table></figure>

<p>大部分情况，cleanup就可以找到Master。而且应该首先使用cleanup。如果不成功，再采用下面的方法</p>
<h4 id="方法2：人工修复复制关系"><a href="#方法2：人工修复复制关系" class="headerlink" title="方法2：人工修复复制关系"></a>方法2：人工修复复制关系</h4><ol>
<li><p>将资源脱离集群管理</p>
<p>cls_unmanage</p>
</li>
<li><p>人工修复PostgreSQL，建立复制关系<br>至于master的选取，可以选择<code>pgsql_REPL_INFO</code>中的master节点，或根据xlog位置确定。</p>
</li>
<li><p>在所有节点上停止PostgreSQL</p>
</li>
<li><p>清除状态并恢复集群管理</p>
<p>cls_manage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_reset_master</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="方法3：快速恢复Master节点再恢复Slave"><a href="#方法3：快速恢复Master节点再恢复Slave" class="headerlink" title="方法3：快速恢复Master节点再恢复Slave"></a>方法3：快速恢复Master节点再恢复Slave</h4><p>可以明确指定将哪个节点作为Master，省略则通过xlog位置比较确定master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_reset_master [master]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="疑难的Pacemaker问题的处理"><a href="#疑难的Pacemaker问题的处理" class="headerlink" title="疑难的Pacemaker问题的处理"></a>疑难的Pacemaker问题的处理</h3><p>有时候可能会遇到一些顽固的问题，Pacemaker不按期望的动作，或某个资源处于错误状态却无法清除。<br>这时最简单的办法就是清除CIB重新设置。可执行下面的命令完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./setup.sh [master]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不指定master，并且PostgreSQL进程是活动的，通过当前PostgreSQL进程的主备关系决定谁是master。<br>如果当前没有处于主的PostgreSQL进程，通过比较xlog位置确定谁作为master。</p>
<p>在PostgreSQL服务启动期间，正常情况下，执行setup.sh不会使服务停止。</p>
<p>setup.sh还可以完全取代前面的<code>cls_reset_master</code>。</p>
<h3 id="fail-count的清除"><a href="#fail-count的清除" class="headerlink" title="fail-count的清除"></a>fail-count的清除</h3><p>如果某个节点上有资源的fail-count不为0，最好将其清除，即使当前资源是健康的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_cleanup</span><br><span class="line">ps resource cleanup msPostgresql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>.&#x2F;setup.sh会清除CIB，对Pacemaker资源定义的修改应该写到config.pcs里，防止下次执行setup.sh丢失。</li>
<li>有些包装后的脚本容易超时，比如<code>cls_rebuild_slave</code>。此时可能执行还没有完成的，需要通过<code>cls_status</code>或日志进行确认。</li>
</ol>
<h3 id="pg-log-和pg-xlog-和pg-clog的区别"><a href="#pg-log-和pg-xlog-和pg-clog的区别" class="headerlink" title="pg_log 和pg_xlog 和pg_clog的区别"></a>pg_log 和pg_xlog 和pg_clog的区别</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_xlog</span></span><br><span class="line">这个日志是记录的Postgresql的WAL信息，也就是一些事务日志信息(transaction log)，默认单个大小是16M，源码安装的时候可以更改其大小。这些信息通常名字是类似&#x27;000000010000000000000013&#x27;这样的文件，这些日志会在定时回滚恢复(PITR)，流复制(Replication Stream)以及归档时能被用到，这些日志是非常重要的，记录着数据库发生的各种事务信息，不得随意删除或者移动这类日志文件，不然你的数据库会有无法恢复的风险</span><br><span class="line"></span><br><span class="line">当你的归档或者流复制发生异常的时候，事务日志会不断地生成，有可能会造成你的磁盘空间被塞满，最终导致DB挂掉或者起不来。遇到这种情况不用慌，可以先关闭归档或者流复制功能，备份pg_xlog日志到其他地方，但请不要删除。然后删除较早时间的的pg_xlog，有一定空间后再试着启动Postgres。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_clog</span></span><br><span class="line">pg_clog这个文件也是事务日志文件，但与pg_xlog不同的是它记录的是事务的元数据(metadata)，这个日志告诉我们哪些事务完成了，哪些没有完成。这个日志文件一般非常小，但是重要性也是相当高，不得随意删除或者对其更改信息。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_log记录各种Error信息，以及服务器与DB的状态信息，可由用户随意更新删除</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_xlog与pg_clog记录数据库的事务信息，不得随意删除更新，做物理备份时要记得备份着两个日志。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>postgres日常使用</title>
    <url>/knowledge-base/2018/05/31/postgressql/</url>
    <content><![CDATA[<div class="note warning"><p>主要记录本人平时使用的postgres的建库，备库和日常使用的SQL语句，其中涉及一点postgres的高可用运维内容和数据库的注意事项。</p>
</div>

<span id="more"></span>
<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PGHOME=/db/pgSQL</span><br><span class="line">export PGDATA=/db/dbc1</span><br><span class="line">export LD_LIBRARY_PATH=$PGHOME/lib</span><br><span class="line">export PATH=$PGHOME/bin:$PATH</span><br><span class="line">export PGDATABASE=atlas</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test <span class="keyword">WITH</span> OWNER <span class="operator">=</span> postgres ENCODING <span class="operator">=</span> <span class="string">&#x27;UTF8&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">user</span> corp_channel <span class="keyword">with</span> password <span class="string">&#x27;corp_channel&#x27;</span>; <span class="comment">-- 创建用户密码</span></span><br><span class="line"><span class="keyword">create</span> database corp_channel owner  corp_channel; <span class="comment">---创建用户</span></span><br><span class="line"><span class="keyword">alter</span> database corp_channel owner <span class="keyword">to</span> corp_channel;(修改数据库owner)</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> database corp_channel <span class="keyword">to</span> corp_channel; <span class="comment">---将corp_channel数据库的所有权限赋予corp_channel用户</span></span><br><span class="line"> 查看表的权限 <span class="comment">--- \z table</span></span><br></pre></td></tr></table></figure>
<h5 id="清除所有表"><a href="#清除所有表" class="headerlink" title="清除所有表"></a>清除所有表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">do $$</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		if( to_regclass(<span class="string">&#x27;tablename&#x27;</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> ) <span class="keyword">then</span></span><br><span class="line">			if( (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> pathman_config <span class="keyword">where</span> partrel <span class="operator">=</span> <span class="string">&#x27;tablename&#x27;</span>::regclass) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>) <span class="keyword">then</span></span><br><span class="line">				PERFORM drop_partitions(<span class="string">&#x27;tablename&#x27;</span>::regclass,<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">end</span> if;</span><br><span class="line">			<span class="keyword">drop</span> <span class="keyword">table</span> tablename;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure>

<h5 id="Sequence序列"><a href="#Sequence序列" class="headerlink" title="Sequence序列"></a>Sequence序列</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Sequence是一种自动增加的数字序列，一般作为行或者表的唯一标识，用作代理主键。</span><br><span class="line">例子：创建一个seq_commodity，最小值为<span class="number">1</span>，最大值为<span class="number">9223372036854775807</span>，从<span class="number">1</span>开始，增量的步长为<span class="number">1</span>，缓存为<span class="number">1</span>的循环排序Sequence。</span><br><span class="line"> <span class="keyword">CREATE</span> SEQUENCE seq_commodity</span><br><span class="line">  INCREMENT <span class="number">1</span></span><br><span class="line">  MINVALUE <span class="number">1</span></span><br><span class="line">  MAXVALUE <span class="number">9223372036854775807</span></span><br><span class="line">  <span class="keyword">START</span> <span class="number">1</span></span><br><span class="line">  CACHE <span class="number">1</span> </span><br><span class="line">  <span class="keyword">CYCLE</span>; <span class="operator">/</span><span class="operator">/</span> 循环，表示到最大值后从头开始</span><br><span class="line"><span class="number">2</span>、查找Sequence中的值</span><br><span class="line"><span class="keyword">SELECT</span> nextval(<span class="string">&#x27;seq_commodity&#x27;</span>)； </span><br><span class="line"><span class="number">3</span>、修改 Sequence</span><br><span class="line">用<span class="keyword">alter</span> sequence来修改，除了<span class="keyword">start</span>以外的所有sequence参数都可以被修改，</span><br><span class="line"><span class="keyword">alter</span> sequence 的例子 （<span class="keyword">SQL</span>语句）</span><br><span class="line"><span class="keyword">ALTER</span> SEQUENCE seq_commodity </span><br><span class="line">  INCREMENT <span class="number">10</span> </span><br><span class="line">  MAXVALUE <span class="number">10000</span> </span><br><span class="line">  <span class="keyword">CYCLE</span> </span><br><span class="line">  NOCACHE ; </span><br><span class="line">  当然如果想要修改<span class="keyword">start</span>的值，可以先用 <span class="keyword">drop</span> sequence删掉，然后再重新创建。</span><br></pre></td></tr></table></figure>

<h5 id="查看表的索引："><a href="#查看表的索引：" class="headerlink" title="查看表的索引："></a>查看表的索引：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_indexes <span class="keyword">where</span> tablename<span class="operator">=</span><span class="string">&#x27;log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="导出备份数据库："><a href="#导出备份数据库：" class="headerlink" title="导出备份数据库："></a>导出备份数据库：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres databasename <span class="operator">&gt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>databasename.bak.yyyymmdd.sql</span><br></pre></td></tr></table></figure>

<h5 id="导入恢复数据库-sql文件是pg-dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等"><a href="#导入恢复数据库-sql文件是pg-dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等" class="headerlink" title="导入恢复数据库(sql文件是pg_dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等)"></a>导入恢复数据库(sql文件是pg_dump导出的文件就行，可以是整个数据库，也可以只是单个表，也可以只是结构等)</h5><figure class="highlight sql"><figcaption><span>lite</span></figcaption><table><tr><td class="code"><pre><span class="line">psql <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>d databasename <span class="operator">&lt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>databasename.bak.yyyymmdd.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出数据结构，主要是加上参数-s："><a href="#导出数据结构，主要是加上参数-s：" class="headerlink" title="导出数据结构，主要是加上参数-s："></a>导出数据结构，主要是加上参数-s：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>U username <span class="operator">-</span>W dbname <span class="operator">-</span>f <span class="operator">/</span>tmp<span class="operator">/</span>filename.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表："><a href="#导出某个表：" class="headerlink" title="导出某个表："></a>导出某个表：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename dbname <span class="operator">&gt;</span> test.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表的结构，同样是加参数”-s”："><a href="#导出某个表的结构，同样是加参数”-s”：" class="headerlink" title="导出某个表的结构，同样是加参数”-s”："></a>导出某个表的结构，同样是加参数”-s”：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename <span class="operator">-</span>s dbname <span class="operator">&gt;</span> test_construct.sql</span><br></pre></td></tr></table></figure>

<h5 id="导出某个表的数据，加参数”-a”："><a href="#导出某个表的数据，加参数”-a”：" class="headerlink" title="导出某个表的数据，加参数”-a”："></a>导出某个表的数据，加参数”-a”：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>U postgres <span class="operator">-</span>t tablename <span class="operator">-</span>a dbname <span class="operator">&gt;</span> test_data.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看序列：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.sequences <span class="keyword">where</span> sequence_schema <span class="operator">=</span> <span class="string">&#x27;public&#x27;</span>;</span><br><span class="line">查看数据库大小：<span class="keyword">select</span> pg_size_pretty(pg_database_size(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">查看表的大小：<span class="keyword">select</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;test&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="由于-copy-命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作-而-copy-命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在-DBA-手中。"><a href="#由于-copy-命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作-而-copy-命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在-DBA-手中。" class="headerlink" title="由于 copy 命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作;而 \copy 命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在 DBA 手中。"></a>由于 copy 命令始终是到数据库服务端找文件，当以文件形式导入导出数据时需以超级用户执行，权限要求很高，适合数据库管理员操作;而 \copy 命令可在客户端执行导入客户端的数据文件，权限要求没那么高，适合开发人员，测试人员使用，因为生产库的权限掌握在 DBA 手中。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename) <span class="keyword">to</span> <span class="string">&#x27;/tmp/1.txt&#x27;</span> (format csv,delimiter <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">\<span class="keyword">copy</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename) <span class="keyword">to</span> <span class="string">&#x27;/tmp/1.txt&#x27;</span> <span class="keyword">with</span> delimiter <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">\<span class="keyword">copy</span> <span class="keyword">table</span> 	 <span class="keyword">from</span> <span class="string">&#x27;/tmp/1.txt&#x27;</span> <span class="keyword">with</span> delimiter <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line"></span><br><span class="line">psql <span class="operator">-</span>c &quot;\copy (select * from PBX_CASH_RCV_REG where TRAN_DATE=&#x27;20170913&#x27;) to &#x27;PBX_CASH_RCV_REG.txt&#x27; with delimiter &#x27;|&#x27; NULL &#x27; &#x27;&quot;</span><br></pre></td></tr></table></figure>

<h5 id="清除所有表-1"><a href="#清除所有表-1" class="headerlink" title="清除所有表"></a>清除所有表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> aaa() <span class="keyword">RETURNS</span> void <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    tmp <span class="type">VARCHAR</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> names <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> </span><br><span class="line">    <span class="keyword">select</span> tablename <span class="keyword">from</span> pg_tables <span class="keyword">where</span> schemaname<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> ;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> stmt <span class="keyword">IN</span> names LOOP</span><br><span class="line">    tmp :<span class="operator">=</span> <span class="string">&#x27;DROP TABLE &#x27;</span><span class="operator">||</span> quote_ident(stmt.tablename) <span class="operator">||</span> <span class="string">&#x27; CASCADE;&#x27;</span>;</span><br><span class="line">RAISE NOTICE <span class="string">&#x27;notice: %&#x27;</span>, tmp;</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">&#x27;DROP TABLE &#x27;</span><span class="operator">||</span> quote_ident(stmt.tablename) <span class="operator">||</span> <span class="string">&#x27; CASCADE;&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line">  RAISE NOTICE <span class="string">&#x27;finished .....&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line">调用时用：</span><br><span class="line"><span class="keyword">select</span> aaa();</span><br></pre></td></tr></table></figure>

<h5 id="获取系统表中字段信息"><a href="#获取系统表中字段信息" class="headerlink" title="获取系统表中字段信息"></a>获取系统表中字段信息</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.attnum,a.attname <span class="keyword">AS</span> field,t.typname <span class="keyword">AS</span> type,a.attlen <span class="keyword">AS</span> length,a.atttypmod <span class="keyword">AS</span> lengthvar,a.attnotnull <span class="keyword">AS</span> notnull <span class="keyword">FROM</span> pg_class c,pg_attribute a,pg_type t</span><br><span class="line"><span class="keyword">WHERE</span> c.relname <span class="operator">=</span> <span class="string">&#x27;dbmanager_hostlist&#x27;</span> <span class="keyword">and</span> a.attnum <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> a.attrelid <span class="operator">=</span> c.oid <span class="keyword">and</span> a.atttypid <span class="operator">=</span> t.oid <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.attnum;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\dtS   <span class="comment">--- 查看系统表</span></span><br><span class="line">\dtS<span class="operator">+</span>  <span class="comment">---  查看详细信息</span></span><br><span class="line">comment <span class="keyword">on</span> <span class="keyword">table</span> t <span class="keyword">IS</span> <span class="string">&#x27;this is a test&#x27;</span>; <span class="comment">--- 添加表注释</span></span><br><span class="line">\<span class="keyword">set</span> AUTOCOMMIT off <span class="comment">--- 关闭自动更新</span></span><br></pre></td></tr></table></figure>

<h5 id="指定去重的列排序"><a href="#指定去重的列排序" class="headerlink" title="指定去重的列排序"></a>指定去重的列排序</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">on</span> (subject) id,name,subject,score <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> subject,score <span class="keyword">desc</span>;</span><br><span class="line">扫描<span class="number">10</span>行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h5 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence seq</span><br><span class="line"><span class="keyword">select</span> nextval(<span class="string">&#x27;seq&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> nextval(<span class="string">&#x27;seq&#x27;</span>) <span class="keyword">from</span> window_test;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">function</span> nextval(regclass) volatile; <span class="comment">-- 只执行一遍 </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">function</span> nextval(regclass) stable; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> generate_series(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">as</span> g(i) <span class="keyword">where</span> i <span class="operator">=</span> nextval(<span class="string">&#x27;seq&#x27;</span>::regclass);</span><br></pre></td></tr></table></figure>

<h5 id="锁表问题"><a href="#锁表问题" class="headerlink" title="锁表问题"></a>锁表问题</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询是否锁表了                                       </span></span><br><span class="line"><span class="keyword">select</span> oid <span class="keyword">from</span> pg_class <span class="keyword">where</span> relname<span class="operator">=</span><span class="string">&#x27;可能锁表了的表&#x27;</span></span><br><span class="line"><span class="keyword">select</span> pid <span class="keyword">from</span> pg_locks <span class="keyword">where</span> relation<span class="operator">=</span><span class="string">&#x27;上面查出的oid&#x27;</span></span><br><span class="line"><span class="comment">--如果查询到了结果，表示该表被锁 则需要释放锁定        </span></span><br><span class="line"><span class="keyword">select</span> pg_cancel_backend(上面查到的pid) </span><br><span class="line"><span class="keyword">select</span> pg_terminate_backend(上面查到pid);</span><br></pre></td></tr></table></figure>

<h5 id="增删改查的操作"><a href="#增删改查的操作" class="headerlink" title="增删改查的操作"></a>增删改查的操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 修改字段名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ubb_model rename <span class="keyword">column</span> hostname <span class="keyword">to</span> hostgroup;</span><br><span class="line"><span class="comment">--- 删除唯一约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> ubb_services <span class="keyword">drop</span> <span class="keyword">constraint</span> ubb_services_services_key;</span><br><span class="line"><span class="comment">--- 增加一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype;                   </span><br><span class="line"><span class="comment">--- 删除一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span>  column_name;                           </span><br><span class="line"><span class="comment">--- 更改列的数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span>  column_name TYPE datatype;              </span><br><span class="line"><span class="comment">--- 表的重命名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME <span class="keyword">TO</span> new_name;                           </span><br><span class="line"><span class="comment">--- 更改列的名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME column_name <span class="keyword">to</span> new_column_name;          </span><br><span class="line"><span class="comment">--- 字段的not null设置</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> column_name &#123;<span class="keyword">SET</span><span class="operator">|</span><span class="keyword">DROP</span>&#125; <span class="keyword">NOT</span> <span class="keyword">NULL</span>;          </span><br><span class="line"><span class="comment">--- 给列添加default</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> column_name <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> expression;</span><br><span class="line"><span class="comment">--- 添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> <span class="keyword">primary</span> key(sid);</span><br><span class="line"><span class="comment">--- 添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orders <span class="keyword">add</span> <span class="keyword">foreign</span> key(goods_id) <span class="keyword">references</span> goods(sid)  <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade: <span class="comment">--- 被引用行更新时，引用行自动更新； </span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> restrict: <span class="comment">--- 被引用的行禁止更新；</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade: <span class="comment">--- 被引用行删除时，引用行也一起删除；</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict: <span class="comment">--- 被引用的行禁止删除；</span></span><br><span class="line"><span class="comment">--- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> orders <span class="keyword">drop</span> <span class="keyword">constraint</span> orders_goods_id_fkey;</span><br><span class="line"><span class="comment">--- 添加唯一约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> <span class="keyword">constraint</span> unique_goods_sid <span class="keyword">unique</span>(sid);</span><br><span class="line"><span class="comment">--- 删除默认值</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods  <span class="keyword">alter</span> <span class="keyword">column</span> sid <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">---  修改字段的数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">alter</span> <span class="keyword">column</span> sid type <span class="type">character</span> <span class="type">varying</span>;</span><br><span class="line"><span class="comment">--- 重命名字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods rename <span class="keyword">column</span> sid <span class="keyword">to</span> ssid;</span><br></pre></td></tr></table></figure>

<h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">单列索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX salary_index <span class="keyword">ON</span> COMPANY (salary); <span class="comment">-- 例子</span></span><br><span class="line">组合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column1_name, column2_name);</span><br><span class="line">唯一索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column_name);</span><br><span class="line">局部索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (conditional_expression);</span><br><span class="line">删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h5 id="时间的使用方法"><a href="#时间的使用方法" class="headerlink" title="时间的使用方法:"></a>时间的使用方法:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select  to_char(CURRENT_DATE,&#x27;YYYYMMDD&#x27;);</span><br><span class="line">select  to_char(CURRENT_TIMESTAMP,&#x27;YYYYMMDD&#x27;);</span><br><span class="line">select  to_char(CURRENT_TIMESTAMP,&#x27;YYYYMMDDMSUS&#x27;);	</span><br><span class="line">select  to_char(CURRENT_TIMESTAMP,&#x27;HH24MISS&#x27;);</span><br><span class="line">select  to_char(number,&#x27;00000000&#x27;)</span><br><span class="line">--- 时间的计算</span><br><span class="line">select CURRENT_DATE  + integer &#x27;7&#x27;;</span><br><span class="line">select CURRENT_TIME  + interval &#x27;1 hour&#x27;;</span><br><span class="line">select CURRENT_TIME  + time &#x27;03:00&#x27;;</span><br></pre></td></tr></table></figure>

<p>####类型转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- numeric转化为字符串</span><br><span class="line">select cast(transamt as varchar) from ol_transdetail where cast(transamt as varchar) like &#x27;%.50&#x27;;</span><br></pre></td></tr></table></figure>



<h5 id="如何找到postgreSQL数据库中占空间最大的表？"><a href="#如何找到postgreSQL数据库中占空间最大的表？" class="headerlink" title="如何找到postgreSQL数据库中占空间最大的表？"></a>如何找到postgreSQL数据库中占空间最大的表？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> relname,relpages <span class="keyword">FROM</span> pg_class <span class="keyword">ORDER</span> <span class="keyword">BY</span> relpages <span class="keyword">DESC</span>;</span><br><span class="line">如果你只想要最大的那个表，可以用limit参数来限制结果的数量，就像这样：</span><br><span class="line"><span class="keyword">SELECT</span> relname, relpages <span class="keyword">FROM</span> pg_class <span class="keyword">ORDER</span> <span class="keyword">BY</span> relpages <span class="keyword">DESC</span> limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>relname <span class="operator">-</span> 关系名<span class="operator">/</span>表名</span><br><span class="line"><span class="number">2.</span>relpages <span class="operator">-</span> 关系页数（默认情况下一个页大小是<span class="number">8</span>kb）</span><br><span class="line"><span class="number">3.</span>pg_class <span class="operator">-</span> 系统表, 维护着所有relations的详细信息</span><br><span class="line"><span class="number">4.</span>limit <span class="number">1</span> <span class="operator">-</span> 限制返回结果只显示一行</span><br></pre></td></tr></table></figure>

<h5 id="如何计算postgreSQL数据库所占用的硬盘大小？"><a href="#如何计算postgreSQL数据库所占用的硬盘大小？" class="headerlink" title="如何计算postgreSQL数据库所占用的硬盘大小？"></a>如何计算postgreSQL数据库所占用的硬盘大小？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_database_size 这个方法是专门用来查询数据库大小的，它返回的结果单位是字节（bytes）。:</span><br><span class="line"><span class="keyword">SELECT</span> pg_database_size(<span class="string">&#x27;geekdb&#x27;</span>);</span><br><span class="line">如果你想要让结果更直观一点，那就使用pg_size_pretty方法，它可以把字节数转换成更友好易读的格式。</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_database_size(<span class="string">&#x27;geekdb&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="如何计算postgreSQL表所占用的硬盘大小？"><a href="#如何计算postgreSQL表所占用的硬盘大小？" class="headerlink" title="如何计算postgreSQL表所占用的硬盘大小？"></a>如何计算postgreSQL表所占用的硬盘大小？</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">下面这个命令查出来的表大小是包含索引和toasted data的，如果你对除去索引外仅仅是表占的大小感兴趣，可以 使用后面提供的那个命令。</span><br><span class="line"><span class="keyword">SELECT</span> pg_size_pretty(pg_total_relation_size(<span class="string">&#x27;big_table&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="类别一、-如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法："><a href="#类别一、-如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法：" class="headerlink" title="类别一、 如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法："></a>类别一、 如果两张张表（导出表和目标表）的字段一致，并且希望插入全部数据，可以用这种方法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  目标表  SELECT  * FROM  来源表 ;</span><br></pre></td></tr></table></figure>

<h5 id="要将-articles-表插入到-newArticles-表中，则可以通过如下SQL语句实现："><a href="#要将-articles-表插入到-newArticles-表中，则可以通过如下SQL语句实现：" class="headerlink" title="要将 articles 表插入到 newArticles 表中，则可以通过如下SQL语句实现："></a>要将 articles 表插入到 newArticles 表中，则可以通过如下SQL语句实现：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  newArticles  SELECT  * FROM  articles ;</span><br></pre></td></tr></table></figure>

<h5 id="如果只希望导入指定字段，可以用这种方法："><a href="#如果只希望导入指定字段，可以用这种方法：" class="headerlink" title="如果只希望导入指定字段，可以用这种方法："></a>如果只希望导入指定字段，可以用这种方法：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO  目标表 (字段1, 字段2, ...)  SELECT   字段1, 字段2, ...   FROM  来源表 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TPersonnelChange(  </span><br><span class="line">    UserId,  </span><br><span class="line">    DepId,  </span><br><span class="line">    SubDepId,  </span><br><span class="line">    PostionType,  </span><br><span class="line">    AuthorityId,  </span><br><span class="line">    ChangeDateS,  </span><br><span class="line">    InsertDate,  </span><br><span class="line">    UpdateDate,  </span><br><span class="line">    SakuseiSyaId  </span><br><span class="line">)<span class="keyword">SELECT</span>  </span><br><span class="line">    UserId,  </span><br><span class="line">    DepId,  </span><br><span class="line">    SubDepId,  </span><br><span class="line">    PostionType,  </span><br><span class="line">    AuthorityId,  </span><br><span class="line">    DATE_FORMAT(EmployDate, <span class="string">&#x27;%Y%m%d&#x27;</span>),  </span><br><span class="line">    NOW(),  </span><br><span class="line">    NOW(),  </span><br><span class="line">    <span class="number">1</span>  </span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    TUserMst  </span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">    `Status` <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">AND</span> QuitFlg <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">AND</span> UserId <span class="operator">&gt;</span> <span class="number">2</span>  </span><br></pre></td></tr></table></figure>

<h5 id="generate-series函数应用"><a href="#generate-series函数应用" class="headerlink" title="generate_series函数应用"></a><a href="http://www.cnblogs.com/mchina/archive/2013/04/03/2997722.html">generate_series函数应用</a></h5><h5 id="批量添加数据"><a href="#批量添加数据" class="headerlink" title="批量添加数据"></a>批量添加数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> generate_series(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">--- int</span></span><br><span class="line"><span class="keyword">select</span> generate_series(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>); <span class="comment">--- 如果step 是正数，而start 大于stop，那么返回零行。相反，如果step 是负数，start 小于stop，则返回零行。如果是NULL 输入，也产生零行。step 为零则是一个错误。</span></span><br><span class="line"><span class="keyword">select</span> generate_series(<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">select</span> generate_series(now(), now() <span class="operator">+</span> <span class="string">&#x27;7 days&#x27;</span>, <span class="string">&#x27;1 day&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> generate_series(to_date(<span class="string">&#x27;20130403&#x27;</span>,<span class="string">&#x27;yyyymmdd&#x27;</span>), to_date(<span class="string">&#x27;20130404&#x27;</span>,<span class="string">&#x27;yyyymmdd&#x27;</span>), <span class="string">&#x27;3 hours&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<h4 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.如何锁一个表的某一行</span><br><span class="line">select * from table rowlock where id =1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> localdatetime,retcode,respinfo <span class="keyword">from</span>  ol_transdetail <span class="keyword">where</span> localdatetime<span class="operator">&gt;</span> <span class="string">&#x27;20180109100000&#x27;</span> <span class="keyword">and</span> receprodcode<span class="operator">=</span><span class="string">&#x27;612020&#x27;</span> <span class="keyword">and</span> retcode<span class="operator">=</span><span class="string">&#x27;09209999&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span>  localdatetime<span class="operator">&gt;</span><span class="string">&#x27;20180109163000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时 <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span> localdate <span class="operator">=</span><span class="string">&#x27;20180329&#x27;</span>  <span class="keyword">and</span> localdatetime <span class="operator">&gt;</span> <span class="string">&#x27;20180329170300&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">DISTINCT</span>(logip) <span class="keyword">from</span> ol_transdetail  ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时  <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span> localdatetime <span class="operator">&gt;=</span> to_char(now() <span class="operator">-</span> <span class="type">interval</span> <span class="string">&#x27;1 min&#x27;</span>,<span class="string">&#x27;YYYYMMDDHHMMSS&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span>  logip ,retcode;</span><br></pre></td></tr></table></figure>

<h4 id="每分钟查询结果"><a href="#每分钟查询结果" class="headerlink" title="每分钟查询结果"></a>每分钟查询结果</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode,<span class="built_in">count</span>(<span class="operator">*</span>),round(<span class="built_in">avg</span>(protime),<span class="number">2</span>) <span class="keyword">as</span> 渠道耗时,round(<span class="built_in">avg</span>(backtime),<span class="number">2</span>) <span class="keyword">as</span> 后台耗时 <span class="keyword">from</span> ol_transdetail <span class="keyword">where</span>  localdatetime <span class="operator">&gt;</span> to_char(now() <span class="operator">-</span> <span class="type">interval</span> <span class="string">&#x27;1 min&#x27;</span>,<span class="string">&#x27;YYYYMMDDHHMISS&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),logip,retcode <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUBSTR(localdatetime,<span class="number">9</span>,<span class="number">4</span>),渠道耗时 <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建基础备份"><a href="#创建基础备份" class="headerlink" title="创建基础备份"></a>创建基础备份</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">	vi pg_hba.conf</span><br><span class="line">	host <span class="keyword">all</span> <span class="keyword">all</span>  <span class="number">192.168</span><span class="number">.67</span><span class="number">.35</span><span class="operator">/</span><span class="number">24</span>             md5</span><br><span class="line">	host replication postgres <span class="number">192.168</span><span class="number">.67</span><span class="number">.35</span><span class="operator">/</span><span class="number">24</span> trust</span><br><span class="line">	pg_basebackup <span class="operator">-</span>h node1 <span class="operator">-</span>U replication <span class="operator">-</span>D <span class="operator">/</span>data<span class="operator">/</span>postgresql<span class="operator">/</span>data<span class="operator">/</span> <span class="operator">-</span>X stream <span class="operator">-</span>P</span><br><span class="line">查看主备关系</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_stat_replication ;</span><br></pre></td></tr></table></figure>

<h3 id="用pg-rewind命令同步新备库"><a href="#用pg-rewind命令同步新备库" class="headerlink" title="用pg_rewind命令同步新备库"></a>用pg_rewind命令同步新备库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pg_rewind --target-pgdata $PGDATA --source-server=&#x27;host=192.168.1.203 port=5432 user=postgres dbname=postgres&#x27; -P</span><br><span class="line">mv recovery.done recovery.conf</span><br><span class="line">vi recovery.conf</span><br></pre></td></tr></table></figure>

<h3 id="高可用（pcs-corosync-postgres）修复旧Master"><a href="#高可用（pcs-corosync-postgres）修复旧Master" class="headerlink" title="高可用（pcs+corosync+postgres）修复旧Master"></a>高可用（pcs+corosync+postgres）修复旧Master</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检查集群状态   </span><br><span class="line">由于设置了migration-threshold=&quot;3&quot;，发生一次普通的错误，Pacemaker会在原地重新启动postgres进程，不发生主从切换。</span><br><span class="line">（如果Master的物理机或网络发生故障，直接进行failover。）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一种方法：可通过<code>pg_basebackup</code>修复旧Master（需要强行恢复的情况下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># su - postgres</span><br><span class="line">$ rm -rf /data/postgresql/data</span><br><span class="line">$ pg_basebackup -h 192.168.41.136 -U postgres -D /data/postgresql/data -X stream -P</span><br><span class="line">$ exit</span><br><span class="line"># pcs resource cleanup msPostgresql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种方法：通过<code>pg_baseback</code>修复旧Master。<code>cls_rebuild_slave</code>是对<code>pg_basebackup</code>的包装，主要多了执行结果状态的检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# rm -rf /data/postgresql/data</span><br><span class="line">[root@node1 pha4pgsql]# cls_rebuild_slave </span><br><span class="line">22636/22636 kB (100%), 1/1 tablespace</span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">wait for recovery complete</span><br><span class="line">.....</span><br><span class="line">slave recovery of node1 successed</span><br><span class="line">[root@node1 pha4pgsql]# cls_status</span><br><span class="line">Last updated: Fri Apr 22 02:40:48 2016</span><br><span class="line">Last change: Fri Apr 22 02:40:36 2016 by root via crm_resource on node1</span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (2) - partition with quorum</span><br><span class="line">Version: 1.1.12-a14efad</span><br><span class="line">2 Nodes configured</span><br><span class="line">4 Resources configured</span><br></pre></td></tr></table></figure>

<p>第三种方法: 9.5以上版本还可以通过<code>pg_rewind</code>修复旧Master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# cls_repair_by_pg_rewind </span><br><span class="line">connected to server</span><br><span class="line">servers diverged at WAL position 0/7000410 on timeline 2</span><br><span class="line">rewinding from last common checkpoint at 0/7000368 on timeline 2</span><br><span class="line">reading source file list</span><br><span class="line">reading target file list</span><br><span class="line">reading WAL in target</span><br><span class="line">need to copy 67 MB (total source directory size is 85 MB)</span><br><span class="line">69591/69591 kB (100%) copied</span><br><span class="line">creating backup label and updating control file</span><br><span class="line">syncing target data directory</span><br><span class="line">Done!</span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">wait for recovery complete</span><br><span class="line">....</span><br><span class="line">slave recovery of node1 successed </span><br></pre></td></tr></table></figure>

<h3 id="高可用（pcs-corosync-postgres）Slave上进程故障"><a href="#高可用（pcs-corosync-postgres）Slave上进程故障" class="headerlink" title="高可用（pcs+corosync+postgres）Slave上进程故障"></a>高可用（pcs+corosync+postgres）Slave上进程故障</h3><p>再强制杀死Master上的postgres进程2次后检查集群状态。</p>
<p>fail-count增加到3后，Pacemaker不再启动PostgreSQL，保持其为停止状态。</p>
<p>同时，Master(node1)(VIP所在的主机)上的复制模式被自动切换到异步复制，防止写操作hang住。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# tail /var/lib/pgsql/tmp/rep_mode.conf</span><br><span class="line">synchronous_standby_names = &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="修复Salve"><a href="#修复Salve" class="headerlink" title="修复Salve"></a>修复Salve</h4><p>在node2上执行<code>cls_cleanup</code>，清除fail-count后，Pacemaker会再次启动PostgreSQL进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# cls_cleanup </span><br><span class="line">All resources/stonith devices successfully cleaned up</span><br><span class="line">[root@node2 ~]# cls_status </span><br><span class="line">Last updated: Sun May  8 01:43:13 2016</span><br><span class="line">Last change: Sun May  8 01:43:08 2016 by root via crm_resource on node1</span><br><span class="line">Stack: corosync</span><br><span class="line">Current DC: node2 (2) - partition with quorum</span><br><span class="line">Version: 1.1.12-a14efad</span><br><span class="line">2 Nodes configured</span><br><span class="line">4 Resources configured</span><br></pre></td></tr></table></figure>

<p>同时，Master(node1)上的复制模式又自动切换回到同步复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node1 pha4pgsql]# tail /var/lib/pgsql/tmp/rep_mode.conf</span><br><span class="line">synchronous_standby_names = &#x27;node2&#x27;(只会有同步流复制)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><p>出现故障时，可通过以下方法排除故障</p>
<ol>
<li><p>确认集群服务是否OK</p>
<p>pcs status</p>
</li>
<li><p>查看错误日志</p>
<p>PostgreSQL的错误日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/messages</span><br><span class="line">/var/log/cluster/corosync.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Pacemaker输出的日志非常多，可以进行过滤。</p>
<p>只看Pacemaker的资源调度（在Current DC节点上执行)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep Initiating /var/log/messages </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只查看expgsql RA的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep expgsql /var/log/messages</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其它故障的处理"><a href="#其它故障的处理" class="headerlink" title="其它故障的处理"></a>其它故障的处理</h2><h3 id="无Master时的修复"><a href="#无Master时的修复" class="headerlink" title="无Master时的修复"></a>无Master时的修复</h3><p>如果切换失败或其它原因导致集群中没有Master，可以参考下面的步骤修复</p>
<h4 id="方法1：使用cleanup修复"><a href="#方法1：使用cleanup修复" class="headerlink" title="方法1：使用cleanup修复"></a>方法1：使用cleanup修复</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cls_cleanup</span><br></pre></td></tr></table></figure>

<p>大部分情况，cleanup就可以找到Master。而且应该首先使用cleanup。如果不成功，再采用下面的方法</p>
<h4 id="方法2：人工修复复制关系"><a href="#方法2：人工修复复制关系" class="headerlink" title="方法2：人工修复复制关系"></a>方法2：人工修复复制关系</h4><ol>
<li><p>将资源脱离集群管理</p>
<p>cls_unmanage</p>
</li>
<li><p>人工修复PostgreSQL，建立复制关系<br>至于master的选取，可以选择<code>pgsql_REPL_INFO</code>中的master节点，或根据xlog位置确定。</p>
</li>
<li><p>在所有节点上停止PostgreSQL</p>
</li>
<li><p>清除状态并恢复集群管理</p>
<p>cls_manage</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_reset_master</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="方法3：快速恢复Master节点再恢复Slave"><a href="#方法3：快速恢复Master节点再恢复Slave" class="headerlink" title="方法3：快速恢复Master节点再恢复Slave"></a>方法3：快速恢复Master节点再恢复Slave</h4><p>可以明确指定将哪个节点作为Master，省略则通过xlog位置比较确定master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_reset_master [master]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="疑难的Pacemaker问题的处理"><a href="#疑难的Pacemaker问题的处理" class="headerlink" title="疑难的Pacemaker问题的处理"></a>疑难的Pacemaker问题的处理</h3><p>有时候可能会遇到一些顽固的问题，Pacemaker不按期望的动作，或某个资源处于错误状态却无法清除。<br>这时最简单的办法就是清除CIB重新设置。可执行下面的命令完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./setup.sh [master]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不指定master，并且PostgreSQL进程是活动的，通过当前PostgreSQL进程的主备关系决定谁是master。<br>如果当前没有处于主的PostgreSQL进程，通过比较xlog位置确定谁作为master。</p>
<p>在PostgreSQL服务启动期间，正常情况下，执行setup.sh不会使服务停止。</p>
<p>setup.sh还可以完全取代前面的<code>cls_reset_master</code>。</p>
<h3 id="fail-count的清除"><a href="#fail-count的清除" class="headerlink" title="fail-count的清除"></a>fail-count的清除</h3><p>如果某个节点上有资源的fail-count不为0，最好将其清除，即使当前资源是健康的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls_cleanup</span><br><span class="line">ps resource cleanup msPostgresql</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>.&#x2F;setup.sh会清除CIB，对Pacemaker资源定义的修改应该写到config.pcs里，防止下次执行setup.sh丢失。</li>
<li>有些包装后的脚本容易超时，比如<code>cls_rebuild_slave</code>。此时可能执行还没有完成的，需要通过<code>cls_status</code>或日志进行确认。</li>
</ol>
<h3 id="pg-log-和pg-xlog-和pg-clog的区别"><a href="#pg-log-和pg-xlog-和pg-clog的区别" class="headerlink" title="pg_log 和pg_xlog 和pg_clog的区别"></a>pg_log 和pg_xlog 和pg_clog的区别</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_xlog</span></span><br><span class="line">这个日志是记录的Postgresql的WAL信息，也就是一些事务日志信息(transaction log)，默认单个大小是16M，源码安装的时候可以更改其大小。这些信息通常名字是类似&#x27;000000010000000000000013&#x27;这样的文件，这些日志会在定时回滚恢复(PITR)，流复制(Replication Stream)以及归档时能被用到，这些日志是非常重要的，记录着数据库发生的各种事务信息，不得随意删除或者移动这类日志文件，不然你的数据库会有无法恢复的风险</span><br><span class="line"></span><br><span class="line">当你的归档或者流复制发生异常的时候，事务日志会不断地生成，有可能会造成你的磁盘空间被塞满，最终导致DB挂掉或者起不来。遇到这种情况不用慌，可以先关闭归档或者流复制功能，备份pg_xlog日志到其他地方，但请不要删除。然后删除较早时间的的pg_xlog，有一定空间后再试着启动Postgres。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_clog</span></span><br><span class="line">pg_clog这个文件也是事务日志文件，但与pg_xlog不同的是它记录的是事务的元数据(metadata)，这个日志告诉我们哪些事务完成了，哪些没有完成。这个日志文件一般非常小，但是重要性也是相当高，不得随意删除或者对其更改信息。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_log记录各种Error信息，以及服务器与DB的状态信息，可由用户随意更新删除</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pg_xlog与pg_clog记录数据库的事务信息，不得随意删除更新，做物理备份时要记得备份着两个日志。</span></span><br></pre></td></tr></table></figure>

<h1 id="PostgreSQL避免OOM发生方法"><a href="#PostgreSQL避免OOM发生方法" class="headerlink" title="PostgreSQL避免OOM发生方法"></a>PostgreSQL避免OOM发生方法</h1><p><strong>操作系统层：</strong></p>
<p>如前面所述，主要设置以下两点：</p>
<ul>
<li>vm.overcommit_memory设置为2：sysctl -w vm.overcommit_memory&#x3D;2</li>
<li>修改postgres进程的oom_score：echo -1000 &gt; &#x2F;proc&#x2F;self&#x2F;oom_score_adj</li>
</ul>
<p><strong>数据库层：</strong></p>
<p>数据库中可以进行以下调整来降低OOM发生的可能：</p>
<ul>
<li>分区表特别多, 需要注意分区的catalog cache占用大量内存（PG12之后基本可以避免，或者使用pg_pathman）</li>
<li>避免长连接，连接时间越长, 访问的元数据积累越多, 导致每个会话的私有内存较大。可以通过降低总连接数或者使用连接池</li>
<li>使用HUGEPAGE, 避免page table占用较大内存. 最终引起OOM</li>
<li>避免使用较大的work_mem或hash_mem_multiplier，优化SQL，减少hash agg、hash join的使用</li>
</ul>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 全方位入门使用</title>
    <url>/knowledge-base/2022/09/17/git-study/</url>
    <content><![CDATA[<div class="note primary"><p>本文是慕课教程的学习笔记，记录git的基本使用，还有简述在项目中独自开发和多人协同开发遇到到问题及解决方法。git现在已经成为面试和工作中必备必会的一项技能，希望大家学会后融会贯通，在工作当中游刃有余。</p>
</div>
<span id="more"></span>

<h2 id="一-git-基础操作"><a href="#一-git-基础操作" class="headerlink" title="一 git 基础操作"></a>一 git 基础操作</h2><h3 id="1-图解git提交流程"><a href="#1-图解git提交流程" class="headerlink" title="1.  图解git提交流程"></a>1.  图解git提交流程</h3><p><img src="/knowledge-base/git.jpg"></p>
<h3 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2.  git常用命令"></a>2.  git常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.初始化仓库：  git init</span><br><span class="line"></span><br><span class="line">2.设置远程仓库：git remote add origin https://github.com/self-contained/self-contained.github.io</span><br><span class="line">要管理当前仓库配置的远程仓库，可以使用 git remote -v 来查看：</span><br><span class="line">git remote -v</span><br><span class="line">origin  https://github.com/self-contained/self-contained.github.io (fetch)</span><br><span class="line">origin  https://github.com/self-contained/self-contained.github.io (push)</span><br><span class="line"></span><br><span class="line">3.从远程仓库克隆</span><br><span class="line">git clone https://github.com/self-contained/self-contained.github.io</span><br><span class="line">git clone --recursive  https://github.com/self-contained/self-contained.github.io</span><br><span class="line"></span><br><span class="line">4. 检查文件状态</span><br><span class="line">git status   ---- 无文件可提交</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">--------------------------------------------------</span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">  README</span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">这告诉我们发现了一个新的文件（untracked file）,它还从没被 git 版本仓库记录过。</span><br><span class="line">该命令还可以使用 -s 参数，生成一个简略列表。</span><br><span class="line">git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br><span class="line">偏右的 M 表示修改了尚未暂存，偏左的 M 表示修改并已暂存。A 表示一个新加入追踪的文件，最后 ?? 表示新检测到的未追踪的文件。你也可以使用 -sb 参数，这会显示你当前的分支信息</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">5. 暂存文件</span><br><span class="line">利用 git add 命令来将新文件（untracked）或未暂存（unstaged）文件提交到暂存区。下例</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file: README</span><br><span class="line">    modified: test.py</span><br><span class="line">你也可以通过 git add * 来暂存所有文件：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"></span><br><span class="line">6. 抓取与拉取</span><br><span class="line">使用 fetch 命令来抓取远程仓库的内容：</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote-name&gt;</span></span><br><span class="line">但这个命令需要你手动进行文件合并操作。如果存在一个分支跟踪远程分支（详见下文分支部分的内容），那么一般使用 pull 指令拉取内容；该指令会自动尝试合并文件：</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull &lt;remote-name&gt;</span></span><br><span class="line">如果你从某一远程仓库将其 clone 到本地，会自动设置跟踪其远程仓库的默认分支（通常叫 master）。之后你的 pull 命令会自动从该地址取得数据并尝试合并。</span><br><span class="line"></span><br><span class="line">7.清理仓库：clean</span><br><span class="line">如果你确认要使用 clean 这个危险的命令，可以配合 -d 移除未追踪文件以及所有空的子目录。添加 -f 选项则意味着强制移除。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -f -d   <span class="comment"># 危险的命令！</span></span></span><br><span class="line">安全选项 -n （或 --dry-run ）来执行一次预演，即告诉你这个操作实际上将会移除哪些文件，但此次并不执行移除操作：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git clean -d --dry-run   <span class="comment"># 显示 git clean -d 将会移除的内容</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-上传代码到github、gitlab，gitee"><a href="#2-上传代码到github、gitlab，gitee" class="headerlink" title="2.  上传代码到github、gitlab，gitee"></a>2.  上传代码到github、gitlab，gitee</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建项目的执行流程</span><br><span class="line">git init   //初始化一个git的本地仓库</span><br><span class="line">git add .  //将我的文件装上武器，准备发射</span><br><span class="line">git commit -m &quot;test&quot; //第一次发射，我的README.md 宝贝已经成功进入到本地仓库</span><br><span class="line">git branch -M master // 建立一个master分支</span><br><span class="line">git remote add origin https://github.com/test.git //将第一个git address命名为 origin</span><br><span class="line">git push -u origin master  推送到远程仓库</span><br></pre></td></tr></table></figure>
<h2 id="二-独自使用git的基本操作"><a href="#二-独自使用git的基本操作" class="headerlink" title="二 独自使用git的基本操作"></a>二 独自使用git的基本操作</h2><h3 id="1-想要找到所有的操作记录时如何进行操作"><a href="#1-想要找到所有的操作记录时如何进行操作" class="headerlink" title="1.  想要找到所有的操作记录时如何进行操作"></a>1.  想要找到所有的操作记录时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log 产看提交记录</span><br><span class="line">git log --author=&quot;名字&quot; 这个人的提交记录</span><br></pre></td></tr></table></figure>
<h3 id="2-配置用户名和邮箱"><a href="#2-配置用户名和邮箱" class="headerlink" title="2.  配置用户名和邮箱"></a>2.  配置用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;用户邮箱&quot;</span><br><span class="line">git config --global --list 查看全局配置</span><br></pre></td></tr></table></figure>
<h3 id="3-想要修改项目中的文件时如何进行操作"><a href="#3-想要修改项目中的文件时如何进行操作" class="headerlink" title="3.  想要修改项目中的文件时如何进行操作"></a>3.  想要修改项目中的文件时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add demo.html</span><br><span class="line">git status</span><br><span class="line">git commit demo.html</span><br></pre></td></tr></table></figure>
<h3 id="4-想要删除不需要的文件时如何进行操作"><a href="#4-想要删除不需要的文件时如何进行操作" class="headerlink" title="4.  想要删除不需要的文件时如何进行操作"></a>4.  想要删除不需要的文件时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 手动删除 (删除之后做提交)</span><br><span class="line">rm -f file.c</span><br><span class="line">git status 这是状态是deleted</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;file.c xxx &quot; file.c</span><br><span class="line">2. git 删除(删除之后做提交)</span><br><span class="line">git rm file.c</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;file.c delete&quot; </span><br></pre></td></tr></table></figure>
<h3 id="5-想要给文件重命名时如何进行操作"><a href="#5-想要给文件重命名时如何进行操作" class="headerlink" title="5.  想要给文件重命名时如何进行操作"></a>5.  想要给文件重命名时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv home.html home_new.html 重命名文件</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h3 id="6-想要移动文件到其他位置时如何进行操作"><a href="#6-想要移动文件到其他位置时如何进行操作" class="headerlink" title="6.  想要移动文件到其他位置时如何进行操作"></a>6.  想要移动文件到其他位置时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv home.html home/home.html 重命名文件</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>
<h4 id="7-删除远程仓库"><a href="#7-删除远程仓库" class="headerlink" title="7. 删除远程仓库"></a>7. 删除远程仓库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm  url   -- 只能删除本地远程库</span><br></pre></td></tr></table></figure>



<h2 id="三-独自使用git的常用问题及解决方法"><a href="#三-独自使用git的常用问题及解决方法" class="headerlink" title="三 独自使用git的常用问题及解决方法"></a>三 独自使用git的常用问题及解决方法</h2><h3 id="1-文件有变化时如何查看文件前后变化"><a href="#1-文件有变化时如何查看文件前后变化" class="headerlink" title="1.  文件有变化时如何查看文件前后变化"></a>1.  文件有变化时如何查看文件前后变化</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这种情况，可以使用以下两种方法:</span><br><span class="line">1. git log --pretty=oneline source\_posts\redis-conf.md 每条日志都只显示一行</span><br><span class="line">多屏显示控制方式空格向下翻页 b向上翻页 q退出,显示如下</span><br><span class="line">da31b8a82404efba1bcfc7a1a5fd03fc14e803d8 blog gitee</span><br><span class="line">git show da31b8a82404efba1bcfc7a1a5fd03fc14e803d8 查看具体的提交内容</span><br><span class="line"></span><br><span class="line">2. git log -p source\_posts\redis-conf.md 查看具体修改内容</span><br></pre></td></tr></table></figure>
<h3 id="2-操作失误的情况下如何实现一键还原（文件未commit）"><a href="#2-操作失误的情况下如何实现一键还原（文件未commit）" class="headerlink" title="2.  操作失误的情况下如何实现一键还原（文件未commit）"></a>2.  操作失误的情况下如何实现一键还原（文件未commit）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开发者修改文件内容，还未提交的情况</span><br><span class="line">1.使用git diff </span><br><span class="line">可以使用git diff 找到不同的地方，修改文件就可以了（针对单个文件比较方便，多个就别考虑了）</span><br><span class="line">2. 使用checkout命令</span><br><span class="line">git checkout -- source\_posts\redis-conf.md 执行此操做，文件就会恢复到你提交前的版本</span><br></pre></td></tr></table></figure>
<h3 id="3-不再追踪时如何实现撤销追踪操作（文件已经commit）"><a href="#3-不再追踪时如何实现撤销追踪操作（文件已经commit）" class="headerlink" title="3.  不再追踪时如何实现撤销追踪操作（文件已经commit）"></a>3.  不再追踪时如何实现撤销追踪操作（文件已经commit）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件加入到暂存区中，git就会追踪到提交的文件</span><br><span class="line">git status --- 在暂存区，文件状态时绿的</span><br><span class="line">git reset HEAD source\_posts\redis-conf.md  --- 文件从暂存区撤销了</span><br><span class="line">git status --- 不在暂存区，文件状态时红的</span><br><span class="line">git checkout -- source/_posts/redis-conf.md ---- 文件就会恢复到上个版本</span><br></pre></td></tr></table></figure>
<h3 id="4-想要回到上一版本或者指定版本时如何进行操作"><a href="#4-想要回到上一版本或者指定版本时如何进行操作" class="headerlink" title="4.  想要回到上一版本或者指定版本时如何进行操作"></a>4.  想要回到上一版本或者指定版本时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.修改文件之后，生成一个版本，如下</span><br><span class="line">git add file/file.c</span><br><span class="line">git commit -m &quot;file/file.c change&quot; file/file.c  -- 这时候就会生成一个版本</span><br><span class="line">git log file/file.c 可以查看</span><br><span class="line">=================================================</span><br><span class="line">commit da31b8a82404efba1bcfc7a1a5fd03fc14e803d8 -- 版本号</span><br><span class="line">Author: </span><br><span class="line">Date:   Sat Oct 2 16:48:39 2021 +0800</span><br><span class="line">    blog gitee</span><br><span class="line">=================================================</span><br><span class="line">2. 回退版本</span><br><span class="line">git reset  --hard HEAD^ 回退到上个版本 ^^ 代表回退到前两个版本，几个^代表回退到几个版本前。</span><br><span class="line">git reset  --hard da31b8a82404efba1bcfc7a1a5fd03fc14e803d8 指定版本号回退内容（回退所有文件）。</span><br></pre></td></tr></table></figure>
<h3 id="5-想要将某一文件回到指定版本时如何进行操作"><a href="#5-想要将某一文件回到指定版本时如何进行操作" class="headerlink" title="5.  想要将某一文件回到指定版本时如何进行操作"></a>5.  想要将某一文件回到指定版本时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log  -- 找到指定版本号</span><br><span class="line">git checkout da31b8a8  -- file/file.c 恢复指定文件到指定版本</span><br></pre></td></tr></table></figure>
<h3 id="6-想要修改内容之后推送至远程仓库时如何进行操作"><a href="#6-想要修改内容之后推送至远程仓库时如何进行操作" class="headerlink" title="6.  想要修改内容之后推送至远程仓库时如何进行操作"></a>6.  想要修改内容之后推送至远程仓库时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">新建项目的执行流程</span><br><span class="line">git init   //初始化一个git的本地仓库</span><br><span class="line">git add .  //将我的文件装上武器，准备发射</span><br><span class="line">git commit -m &quot;test&quot; //第一次发射，我的README.md 宝贝已经成功进入到本地仓库</span><br><span class="line">git branch -M master // 建立一个master分支</span><br><span class="line">git remote add origin https://github.com/test.git //将第一个git address命名为 origin</span><br><span class="line">git push -u origin master  推送到远程仓库</span><br></pre></td></tr></table></figure>
<h3 id="7-想要给每个版本创建一个独特标签，做所有版本标签管理时如何操作"><a href="#7-想要给每个版本创建一个独特标签，做所有版本标签管理时如何操作" class="headerlink" title="7.  想要给每个版本创建一个独特标签，做所有版本标签管理时如何操作"></a>7.  想要给每个版本创建一个独特标签，做所有版本标签管理时如何操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br><span class="line">git tag 默认是加到最新的提交上</span><br><span class="line">git tag v2.0 版本号（git log 查询）</span><br><span class="line">git tag -d v2.0 删除标签</span><br><span class="line">git push origin v1.0  推送标签到远程仓库</span><br><span class="line"></span><br><span class="line">查看所有tag命令：git tag</span><br><span class="line">指定标签信息命令：git tag -a &lt;tagname&gt; -m &quot;gittag标签备注&quot;</span><br><span class="line"></span><br><span class="line">当忘了给某个提交打标签，又将它发布了，我们可以给它追加标签：</span><br><span class="line">命令：git tag -a 版本号 版本的十六进制编码</span><br><span class="line">例如：git tag -a v1.0 39090b5</span><br></pre></td></tr></table></figure>
<h3 id="8-想要切换、删除分支时如何进行操作"><a href="#8-想要切换、删除分支时如何进行操作" class="headerlink" title="8.  想要切换、删除分支时如何进行操作"></a>8.  想要切换、删除分支时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch dev 创建分支</span><br><span class="line">git checkout dev 切换分支</span><br><span class="line">git checkout -b dev 创建并切换分支</span><br><span class="line">git branch -d dev 删除分支（不能删除当前所在的分支/如果有未提交的文件，也不能删除）</span><br><span class="line">git branch -D dev 强制删除</span><br></pre></td></tr></table></figure>
<h3 id="9-想要合并分支时如何进行操作"><a href="#9-想要合并分支时如何进行操作" class="headerlink" title="9.  想要合并分支时如何进行操作"></a>9.  想要合并分支时如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git add ./file.c  --- 对于开发者，正对文件提交</span><br><span class="line">git commit -m &quot;file.c&quot;</span><br><span class="line">现在dev的分支功能已经开发完，需要合并到主分支</span><br><span class="line">git checkout master 切换到主分支</span><br><span class="line">git merge dev  ----- 合并dev分支到master分支</span><br><span class="line">git merge --no-ff dev (&quot;尽量使用这个&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="Git-工作流还建议使用三种支持性的分支，分别是："><a href="#Git-工作流还建议使用三种支持性的分支，分别是：" class="headerlink" title="Git 工作流还建议使用三种支持性的分支，分别是："></a>Git 工作流还建议使用三种支持性的分支，分别是：</h4><ol>
<li><h5 id="特性分支（Feature-branches）：用来添加特性。这类分支从-dev-分支分岔出来，并在合适的时候合并回-dev-分支（或者被抛弃）。特性分支-不应当被推送到远程仓库-。一个典型的特性分支操作流程是："><a href="#特性分支（Feature-branches）：用来添加特性。这类分支从-dev-分支分岔出来，并在合适的时候合并回-dev-分支（或者被抛弃）。特性分支-不应当被推送到远程仓库-。一个典型的特性分支操作流程是：" class="headerlink" title="特性分支（Feature branches）：用来添加特性。这类分支从 dev 分支分岔出来，并在合适的时候合并回 dev 分支（或者被抛弃）。特性分支 不应当被推送到远程仓库 。一个典型的特性分支操作流程是："></a>特性分支（Feature branches）：用来添加特性。这类分支从 dev 分支分岔出来，并在合适的时候合并回 dev 分支（或者被抛弃）。特性分支 <strong>不应当被推送到远程仓库</strong> 。一个典型的特性分支操作流程是：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建特性分支进行开发</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout feature-foo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit ...</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并回 dev 分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff feature-foo</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地 feature 分支，并将本地 dev 分支推送到远程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d feature-foo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="发布分支（Release-branches）：用来确定分布版本，一般以-release-x-y-z-来命名。发布分支上可能进行较小的修复，以及元数据的更新（比如版本号）。一个典型的发布分支操作是："><a href="#发布分支（Release-branches）：用来确定分布版本，一般以-release-x-y-z-来命名。发布分支上可能进行较小的修复，以及元数据的更新（比如版本号）。一个典型的发布分支操作是：" class="headerlink" title="发布分支（Release branches）：用来确定分布版本，一般以 release-x.y.z 来命名。发布分支上可能进行较小的修复，以及元数据的更新（比如版本号）。一个典型的发布分支操作是："></a>发布分支（Release branches）：用来确定分布版本，一般以 release-x.y.z 来命名。发布分支上可能进行较小的修复，以及元数据的更新（比如版本号）。一个典型的发布分支操作是：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建发布分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b release-1.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./update-version.py 1.1 <span class="comment"># 一些元数据更改</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Update to v1.1&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并到 master 并添加标签，以完成发布</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将这部分更改更新到 dev 分支</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.1</span></span><br><span class="line">... (修复可能存在的冲突)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d release-1.1</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="热修复分支（Hotfix-branches）：热修复分支是从-master-分支分岔出的，为了对生产环境（即-master-分支）的问题进行修复。因此，它在结束时会被直接合并到-master-分支来完成热修复。它一般用-hotfix-x-y-z-的方式命名，并在完成后更新生产环境的版本号。"><a href="#热修复分支（Hotfix-branches）：热修复分支是从-master-分支分岔出的，为了对生产环境（即-master-分支）的问题进行修复。因此，它在结束时会被直接合并到-master-分支来完成热修复。它一般用-hotfix-x-y-z-的方式命名，并在完成后更新生产环境的版本号。" class="headerlink" title="热修复分支（Hotfix branches）：热修复分支是从 master 分支分岔出的，为了对生产环境（即 master 分支）的问题进行修复。因此，它在结束时会被直接合并到 master 分支来完成热修复。它一般用 hotfix-x.y.z 的方式命名，并在完成后更新生产环境的版本号。"></a>热修复分支（Hotfix branches）：热修复分支是从 master 分支分岔出的，为了对生产环境（即 master 分支）的问题进行修复。因此，它在结束时会被直接合并到 master 分支来完成热修复。它一般用 hotfix-x.y.z 的方式命名，并在完成后更新生产环境的版本号。</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建热修复分支，指定从 master 分岔</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix-1.1.1 master</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得更新版本号元数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./update-version.py 1.1.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">... (进行热修复)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Hotfix a severe bug of ...&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将热修复分支部署到 master 分支生产环境，并添加标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.1.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.1.1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将热修分分支的更新合并到 dev 分支（或发行分支，视情形而定）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout dev</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.1.1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix-1.1.1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-当合并分支有冲突时如何正确的合并分支"><a href="#10-当合并分支有冲突时如何正确的合并分支" class="headerlink" title="10.  当合并分支有冲突时如何正确的合并分支"></a>10.  当合并分支有冲突时如何正确的合并分支</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.git merge --abort dev 忽略冲突，保留当前分支的内容 (最好不要这样，不然可能被砍)</span><br><span class="line">2. 删除文件的特殊符号，保留代码，找到同时修改的人，协商修改，再提交</span><br><span class="line">git add .</span><br><span class="line">git commit    --- 这个命令会打开一个文件</span><br><span class="line">输入 结局信息</span><br><span class="line">git status</span><br><span class="line">git commit  -m &quot;解决冲突&quot;</span><br></pre></td></tr></table></figure>
<h2 id="四-git-对人分支集成协作时的常见场景-针对的是远程仓库"><a href="#四-git-对人分支集成协作时的常见场景-针对的是远程仓库" class="headerlink" title="四 git 对人分支集成协作时的常见场景(针对的是远程仓库)"></a>四 git 对人分支集成协作时的常见场景(针对的是远程仓库)</h2><h3 id="1-不同人想要查看版本路线如何进行操作"><a href="#1-不同人想要查看版本路线如何进行操作" class="headerlink" title="1.  不同人想要查看版本路线如何进行操作"></a>1.  不同人想要查看版本路线如何进行操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --oneline 查看所有提交记录</span><br><span class="line">git log --oneline --graph 查看版本路线，有分支合并会特别明显</span><br></pre></td></tr></table></figure>
<h3 id="2-不同人想要删除不想要的分支如何操作"><a href="#2-不同人想要删除不想要的分支如何操作" class="headerlink" title="2.  不同人想要删除不想要的分支如何操作"></a>2.  不同人想要删除不想要的分支如何操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git brach -av   查看远程仓库</span><br><span class="line">git push origin --delete test_xxx 删除远程分支 （确认分支已经合并到主分支）</span><br></pre></td></tr></table></figure>
<h3 id="3-不同人修改了不同文件如何处理"><a href="#3-不同人修改了不同文件如何处理" class="headerlink" title="3.  不同人修改了不同文件如何处理"></a>3.  不同人修改了不同文件如何处理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git fetch</span><br><span class="line">git add .</span><br><span class="line">git commit  -m &quot;change 1&quot;  </span><br><span class="line">git push  --这个时候出现冲突，远程已经有人修改提交过了，需要我们先解决冲突再提交。</span><br><span class="line">git branch -av 查看本地分支和远程分支的关系</span><br><span class="line">git merge origin/dev  --- 这时候会打开一个文档</span><br><span class="line">写入修改信息保存</span><br><span class="line">之后再执行</span><br><span class="line">git push </span><br></pre></td></tr></table></figure>
<h3 id="4-不同人修改相同的文件如何处理"><a href="#4-不同人修改相同的文件如何处理" class="headerlink" title="4.  不同人修改相同的文件如何处理"></a>4.  不同人修改相同的文件如何处理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b test remotes/origin/test 创建分支，切换分支，关联远程分支</span><br><span class="line">git branch -av 查看本地分支和远程分支的关系</span><br><span class="line">git fetch 把远端分支拉取下来 （不同的人都可以使用想同分支）</span><br><span class="line">git add .</span><br><span class="line">git commit .</span><br></pre></td></tr></table></figure>

<h3 id="五-常用设置"><a href="#五-常用设置" class="headerlink" title="五 常用设置"></a>五 常用设置</h3><p>####1. 设置脚本权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查看文件权限 </span><br><span class="line">git ls-tree HEAD</span><br><span class="line">2. 指定目录 查看文件权限 </span><br><span class="line"> git ls-tree HEAD ./tcp/pre/</span><br><span class="line">3. 修改 仓库中文件的权限</span><br><span class="line">git update-index --chmod=+x tcp/pre/build.sh</span><br><span class="line">5 再次查看 文件权限</span><br><span class="line">git ls-tree HEAD ./tcp/pre/</span><br><span class="line"></span><br><span class="line">abcdefghijklmnopqrstuvwxyz123456isisisisisissiisisisisisisi</span><br></pre></td></tr></table></figure>



<h4 id="2-设置文件格式"><a href="#2-设置文件格式" class="headerlink" title="2. 设置文件格式"></a>2. 设置文件格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本</span><br><span class="line">CRLF: Carriage-Return Line-Feed的缩写，意思是回车换行，即\r\n;</span><br><span class="line">LF: Line-Feed的缩写,意思是换行，即\n;</span><br><span class="line">CR: Carriage-Return的缩写，回车，即\r;</span><br><span class="line">进阶</span><br><span class="line">当我们敲击回车键(Enter)时，操作系统会插入不可见的字符表示换行，不同的操作系统插入不同</span><br><span class="line"></span><br><span class="line">Windows: 插入\r\n,回车换行；</span><br><span class="line">Linux\Unix: 插入\n,换行；</span><br><span class="line">MacOS: 插入\r，回车；</span><br><span class="line">Git</span><br><span class="line">1. AutoCRLF</span><br><span class="line">提交时转换为LF，检出时转换为CRLF</span><br><span class="line">git config --global core.autocrlf true</span><br><span class="line">提交时转换为LF，检出时不转换</span><br><span class="line">git config --global core.autocrlf input</span><br><span class="line">提交检出均不转换</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">2.SafeCRLF</span><br><span class="line">拒绝提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf true</span><br><span class="line">允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false</span><br><span class="line">提交包含混合换行符的文件时给出警告</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>

<h4 id="3-设置子目录"><a href="#3-设置子目录" class="headerlink" title="3. 设置子目录"></a>3. 设置子目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add 需要存在的 url 本地目录</span><br><span class="line"></span><br><span class="line">克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行如下命令完成子模块的下载：</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">或者</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">子模块的更新</span><br><span class="line">子模块的维护者提交了更新后，使用子模块的项目必须手动更新才能包含最新的提交。</span><br><span class="line"></span><br><span class="line">在项目中，进入到子模块目录下，执行 git pull更新，查看git log查看相应提交。</span><br><span class="line"></span><br><span class="line">完成后返回到项目目录，可以看到子模块有待提交的更新，使用git add，提交即可。</span><br><span class="line"></span><br><span class="line">删除子模块</span><br><span class="line">有时子模块的项目维护地址发生了变化，或者需要替换子模块，就需要删除原有的子模块。</span><br><span class="line"></span><br><span class="line">删除子模块较复杂，步骤如下：</span><br><span class="line"></span><br><span class="line">rm -rf 子模块目录 删除子模块目录及源码</span><br><span class="line">vi .gitmodules 删除项目目录下.gitmodules文件中子模块相关条目</span><br><span class="line">vi .git/config 删除配置项中子模块相关条目</span><br><span class="line">rm .git/module/* 删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可</span><br><span class="line"></span><br><span class="line">执行完成后，再执行添加子模块命令即可，如果仍然报错，执行如下：</span><br><span class="line"></span><br><span class="line">git rm --cached 子模块名称</span><br><span class="line"></span><br><span class="line">完成删除后，提交到仓库即可。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 常用内容</title>
    <url>/knowledge-base/2022/02/06/nginx/</url>
    <content><![CDATA[<div class="note primary"><p>nginx 常用内容</p>
</div>
<span id="more"></span>

<h3 id="1-nginx指定配置文件启动及重启"><a href="#1-nginx指定配置文件启动及重启" class="headerlink" title="1. nginx指定配置文件启动及重启"></a>1. nginx指定配置文件启动及重启</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、验证配置文件</span><br><span class="line"></span><br><span class="line">/usr/local/nginx/sbin/nginx -tc /usr/local/nginx/conf/nginx.conf</span><br><span class="line">or</span><br><span class="line">/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">2、指定配置文件启动</span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">3、指定配置文件重启</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>


<h3 id="2-nginx配置webservice"><a href="#2-nginx配置webservice" class="headerlink" title="2. nginx配置webservice"></a>2. nginx配置webservice</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用的用户和组</span><br><span class="line">#user  nobody;</span><br><span class="line">#指定工作衍生进程数（一般等于CPU的总核数或者总核数的两倍），每个进程耗费10MB-12MB内存</span><br><span class="line">worker_processes  2;</span><br><span class="line">#指定错误日志存放的路径，错误日志记录级别可选项为：[debug | info | noticd | warn | error ]</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#指定错误日志级别</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">#指定pid存放的路径，文件内记录当前nginx主进程的ID，kill -HUP &#x27;logs/nginx.pid&#x27;</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #允许最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #mimie.types 浏览器请求的文件媒体类型</span><br><span class="line">    include       mime.types;</span><br><span class="line">    #用来告诉浏览器请求的文件媒体类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #日志记录格式</span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    </span><br><span class="line">    #日志名称，和日志记录格式采用main</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    #设置客户端能够上传的文件大小，默认为1m</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #该指令允许或禁止使用FreeBSD上的TCP_NOPUSH,或者Linux上的TCP_CORK套接字选项。</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #keepalive_timeout  0该指令可以使客户端到服务器端的连接持续有效</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #开启gzip压缩,对网页文件、css、js、xml等启动gzip压缩，减少数据传输量，提高访问速度。</span><br><span class="line">    #gzip  on;</span><br><span class="line">    </span><br><span class="line">    #设置要代理的服务</span><br><span class="line">    upstream test1 &#123;</span><br><span class="line">        #ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器。</span><br><span class="line">        #但无法保证后端服务器的负载均衡，所以建议后端服务器能做到session共享来代替nginx的ip_hash方式。</span><br><span class="line">        #ip_hash;</span><br><span class="line">        server 192.168.0.1:8080;</span><br><span class="line">        server 192.168.0.2:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #第一个虚拟主机，反向代理php_server_pool这组服务器</span><br><span class="line">    server &#123;</span><br><span class="line">        #该指令用于设置虚拟主机监听的服务器地址和端口号。server_name最好使用IP或域名，不要使用localhost</span><br><span class="line">        listen       8087;</span><br><span class="line">        server_name  127.0.0.1;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            #该指令用于设置被代理服务器端口或套接字，以及URI</span><br><span class="line">            proxy_pass        http://test1;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            #使用$host变量，它的值相当于服务器的主机名（如果使用域名访问，则该值为域名；如果使用IP访问，则该值为IP）。</span><br><span class="line">            #此外可以将主机名和被代理服务器的端口一起传递  $host:$proxy_port,在设置webservice一定要设置$host:$proxy_port，不然会找不到端口</span><br><span class="line">            proxy_set_header   Host $host：$server_port;</span><br><span class="line">            proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Murmurhast c 和 java 版 介绍和实现</title>
    <url>/knowledge-base/2019/11/01/murmurhash/</url>
    <content><![CDATA[<div class="note primary"><p>MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。 由Austin Appleby在2008年发明， 并出现了多个变种，都已经发布到了公有领域(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。—摘自wiki</p>
</div>
<span id="more"></span>

<p> Redis在实现字典时用到了两种不同的哈希算法，MurmurHash便是其中一种（另一种是djb），在Redis中应用十分广泛，包括数据库、集群、哈希键、阻塞操作等功能都用到了这个算法。发明算法的作者被邀到google工作，该算法最新版本是MurmurHash3，基于MurmurHash2改进了一些小瑕疵，使得速度更快，实现了32位（低延时）、128位HashKey，尤其对大块的数据，具有较高的平衡性与低碰撞率。</p>
<pre><code>MurmurHash2的实现，可以放到自己的工程中使用。
</code></pre>
<h2 id="java-代码"><a href="#java-代码" class="headerlink" title="java 代码"></a>java 代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MurmurHash</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MurmurHash</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="type">byte</span>[] toBytesWithoutEncoding(String str) &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">		<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[len &lt;&lt; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">			buf[pos++] = (<span class="type">byte</span>) (c &amp; <span class="number">0xFF</span>);</span><br><span class="line">			buf[pos++] = (<span class="type">byte</span>) (c &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buf;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashcode</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] bytes = toBytesWithoutEncoding(str);</span><br><span class="line">		<span class="comment">////System.out.println(&quot;bytes length&quot;+bytes.length);</span></span><br><span class="line">		<span class="keyword">return</span> hash32(bytes, bytes.length);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  * Generates 32 bit hash from byte array of the given length and  * seed.</span></span><br><span class="line"><span class="comment">	 *  *  * <span class="doctag">@param</span> data byte array to hash  * <span class="doctag">@param</span> length length of the array</span></span><br><span class="line"><span class="comment">	 * to hash  * <span class="doctag">@param</span> seed initial seed value  * <span class="doctag">@return</span> 32 bit hash of the</span></span><br><span class="line"><span class="comment">	 * given array  </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash32</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, <span class="type">int</span> length, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">		<span class="comment">// &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span></span><br><span class="line">		<span class="comment">// They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0x5bd1e995</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">		<span class="comment">// Initialize the hash to a random value</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> seed ^ length;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;h:&quot;+h);</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">length4</span> <span class="operator">=</span> length / <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length4; i++) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> i * <span class="number">4</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (data[i4 + <span class="number">0</span>] &amp; <span class="number">0xff</span>) + ((data[i4 + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">					+ ((data[i4 + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">					+ ((data[i4 + <span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">			k *= m;</span><br><span class="line">			k ^= k &gt;&gt;&gt; r;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;k:&quot;+k);</span></span><br><span class="line">			k *= m;</span><br><span class="line">			h *= m;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;hsss&quot;+h);</span></span><br><span class="line">			h ^= k;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;hsss1&quot;+h);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;h2::&quot;+h);</span></span><br><span class="line">		<span class="comment">// Handle the last few bytes of the input array</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;length::&quot;+(length%4));</span></span><br><span class="line">		<span class="keyword">switch</span> (length % <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			h ^= (data[(length &amp; ~<span class="number">3</span>) + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h33::&quot;+h);</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			h ^= (data[(length &amp; ~<span class="number">3</span>) + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h22::&quot;+h);</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="comment">//System.out.println(&quot;length::&quot;+(length &amp; ~3));</span></span><br><span class="line">			<span class="comment">//System.out.println(&quot;data::&quot;+data[length &amp; ~3]);</span></span><br><span class="line">			<span class="comment">//System.out.println(&quot;data::&quot;+(data[length &amp; ~3] &amp;0xff));</span></span><br><span class="line">			h ^= (data[length &amp; ~<span class="number">3</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h10::&quot;+h);</span></span><br><span class="line">			h *= m;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h11::&quot;+h);</span></span><br><span class="line">		&#125;</span><br><span class="line">		h ^= h &gt;&gt;&gt; <span class="number">13</span>;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h13::&quot;+h);</span></span><br><span class="line">		h *= m;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;hm::&quot;+h);</span></span><br><span class="line">		h ^= h &gt;&gt;&gt; <span class="number">15</span>;</span><br><span class="line">			<span class="comment">//System.out.println(&quot;h15::&quot;+h);</span></span><br><span class="line">		<span class="keyword">return</span> h;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  * Generates 32 bit hash from byte array with default seed value.  *  * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">	 * data byte array to hash  * <span class="doctag">@param</span> length length of the array to hash  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * 32 bit hash of the given array  </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash32</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hash32(data, length, <span class="number">0x9747b28c</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash32</span><span class="params">(<span class="keyword">final</span> String data)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] bytes = toBytesWithoutEncoding(data);</span><br><span class="line">		<span class="comment">////System.out.println(&quot;bytes length&quot;+bytes.length);</span></span><br><span class="line">		<span class="keyword">return</span> hash32(bytes, bytes.length, <span class="number">0x9747b28c</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  * Generates 64 bit hash from byte array of the given length and seed.  *</span></span><br><span class="line"><span class="comment">	 *  * <span class="doctag">@param</span> data byte array to hash  * <span class="doctag">@param</span> length length of the array to</span></span><br><span class="line"><span class="comment">	 * hash  * <span class="doctag">@param</span> seed initial seed value  * <span class="doctag">@return</span> 64 bit hash of the</span></span><br><span class="line"><span class="comment">	 * given array  </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hash64</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, <span class="type">int</span> length, <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0xc6a4a7935bd1e995L</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> (seed &amp; <span class="number">0xffffffffL</span>) ^ (length * m);</span><br><span class="line">		<span class="type">int</span> <span class="variable">length8</span> <span class="operator">=</span> length / <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length8; i++) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">int</span> <span class="variable">i8</span> <span class="operator">=</span> i * <span class="number">8</span>;</span><br><span class="line">			<span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> ((<span class="type">long</span>) data[i8 + <span class="number">0</span>] &amp; <span class="number">0xff</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>)</span><br><span class="line">					+ (((<span class="type">long</span>) data[i8 + <span class="number">7</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">56</span>);</span><br><span class="line">			k *= m;</span><br><span class="line">			k ^= k &gt;&gt;&gt; r;</span><br><span class="line">			k *= m;</span><br><span class="line">			h ^= k;</span><br><span class="line">			h *= m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (length % <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">6</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">48</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">5</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">40</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">4</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[(length &amp; ~<span class="number">7</span>) + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			h ^= (<span class="type">long</span>) (data[length &amp; ~<span class="number">7</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">			h *= m;</span><br><span class="line">		&#125;</span><br><span class="line">		;</span><br><span class="line">		h ^= h &gt;&gt;&gt; r;</span><br><span class="line">		h *= m;</span><br><span class="line">		h ^= h &gt;&gt;&gt; r;</span><br><span class="line">		<span class="keyword">return</span> h;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  * Generates 64 bit hash from byte array with default seed value.  *  * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">	 * data byte array to hash  * <span class="doctag">@param</span> length length of the array to hash  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * 64 bit hash of the given string  </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hash64</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> hash64(data, length, <span class="number">0xe17a1465</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hash64</span><span class="params">(<span class="keyword">final</span> String data)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] bytes = toBytesWithoutEncoding(data);</span><br><span class="line">		<span class="keyword">return</span> hash64(bytes, bytes.length);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span> &#123;</span><br><span class="line">            <span class="comment">//System.out.println(args[0]);</span></span><br><span class="line">        <span class="type">MurmurHash</span> <span class="variable">mur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MurmurHash</span>();</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">            a=mur.hash32(args[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">&quot;h:&quot;</span>+a);</span><br><span class="line">	<span class="comment">/*byte[] bytes = mur.toBytesWithoutEncoding(args[0]);</span></span><br><span class="line"><span class="comment">	String stmp=&quot;&quot;;</span></span><br><span class="line"><span class="comment">        for (int i=0;i&lt; bytes.length;i++)&#123;</span></span><br><span class="line"><span class="comment">                stmp = Integer.toHexString(bytes[i]);</span></span><br><span class="line"><span class="comment">                //System.out.println(stmp);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="C-版-32位实现"><a href="#C-版-32位实现" class="headerlink" title="C 版 32位实现"></a>C 版 32位实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">murmurhash32</span><span class="params">(<span class="type">const</span>  <span class="type">char</span> *key)</span>&#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)key;</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(data);</span><br><span class="line">                <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="type">char</span> buf[len &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                        <span class="type">char</span> c = data[i];</span><br><span class="line">                        <span class="comment">////printf(&quot;c:%c\n&quot;,c);</span></span><br><span class="line">                        <span class="comment">////printf(&quot;c FF %x\n&quot;,(c &amp;0xFF));</span></span><br><span class="line">                        <span class="comment">////printf(&quot;c 8 %x\n&quot;,c &gt;&gt; 8 );</span></span><br><span class="line">                        buf[pos++] = (c &amp; <span class="number">0xFF</span>);</span><br><span class="line">                        buf[pos++] = c &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;(len &lt;&lt; <span class="number">1</span> );i++)&#123;</span><br><span class="line">                 <span class="comment">////printf(&quot;%x &quot;,buf[i]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">////printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> seed=<span class="number">0x9747b28c</span>;</span><br><span class="line">                <span class="type">int</span> len_two=len &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span></span><br><span class="line">                <span class="comment">// They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.</span></span><br><span class="line">                 <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> m = <span class="number">0x5bd1e995</span>;</span><br><span class="line">                 <span class="type">int</span> r = <span class="number">24</span>;</span><br><span class="line">                <span class="comment">// Initialize the hash to a random value</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> h = seed ^ len_two;</span><br><span class="line">		<span class="comment">//printf(&quot;h:[%d]\n&quot;,h);</span></span><br><span class="line">                <span class="type">int</span> length4 = len_two / <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; length4; i++) &#123;</span><br><span class="line">                        <span class="type">int</span> i4 = i * <span class="number">4</span>;</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">int</span> k = (buf[i4 + <span class="number">0</span>] &amp; <span class="number">0xff</span>) + ((buf[i4 + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                                        + ((buf[i4 + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                                        + ((buf[i4 + <span class="number">3</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">                        k *= m;</span><br><span class="line">                        k ^= k &gt;&gt; r;</span><br><span class="line">			<span class="comment">//printf(&quot;k:[%d]\n&quot;,k);</span></span><br><span class="line">                        k *= m;</span><br><span class="line">                        h *= m;</span><br><span class="line">			<span class="comment">//printf(&quot;hsss:[%d]\n&quot;,h);</span></span><br><span class="line">                        h ^= k;</span><br><span class="line">			<span class="comment">//printf(&quot;hsss1:[%d]\n&quot;,h);</span></span><br><span class="line">                &#125;</span><br><span class="line">		<span class="comment">//printf(&quot;h2:[%d]\n&quot;,h);</span></span><br><span class="line">                <span class="comment">// Handle the last few bytes of the input array</span></span><br><span class="line">		<span class="comment">//printf(&quot;len_tow%4&#123;%d&#125;\n&quot;,len_two%4);</span></span><br><span class="line">                <span class="keyword">switch</span> (len_two % <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        h ^= (buf[(len_two &amp; ~<span class="number">3</span>) + <span class="number">2</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;h33:[%d]\n&quot;,h);</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        h ^= (buf[(len_two &amp; ~<span class="number">3</span>) + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;h22:[%d]\n&quot;,h);</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        h ^= (buf[len_two &amp; ~<span class="number">3</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">			<span class="comment">//printf(&quot;h10:[%d]\n&quot;,h);</span></span><br><span class="line">                        h *= m;</span><br><span class="line">			<span class="comment">//printf(&quot;h11:[%d]\n&quot;,h);</span></span><br><span class="line">                &#125;</span><br><span class="line">                h ^= h &gt;&gt; <span class="number">13</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;13:[%d]\n&quot;,h);</span></span><br><span class="line">                h *= m;</span><br><span class="line">			<span class="comment">//printf(&quot;hm:[%d]\n&quot;,h);</span></span><br><span class="line">                h ^= h &gt;&gt; <span class="number">15</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;h15:[%d]\n&quot;,h);</span></span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">         <span class="type">int</span> b =  murmurhash32(argv[<span class="number">1</span>]);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;h:%d\n&quot;</span>,b);</span><br><span class="line">	 <span class="type">int</span> tmp= <span class="built_in">abs</span>(b);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;tmp:[%d]\n&quot;</span>,tmp);</span><br><span class="line">	 <span class="type">int</span> hash=tmp%<span class="number">4096</span>;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;hash:[%d]\n&quot;</span>,hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>murmurhash</tag>
      </tags>
  </entry>
  <entry>
    <title>pathman安装使用</title>
    <url>/knowledge-base/2019/10/23/pathman-install/</url>
    <content><![CDATA[<div class="note primary"><p>pathman 安装详解</p>
</div>
<span id="more"></span>

<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon opt]# tar -zxvf pg_pathman.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入pg安装的环境变量</span></span><br><span class="line">vi .bash_profile </span><br><span class="line">添加内容</span><br><span class="line">====================</span><br><span class="line">PBLIB=/usr/local/pgsql/lib</span><br><span class="line">PATH=$PATH:/usr/local/pgsql/bin</span><br><span class="line">MANPATH=$MANPATH:/usr/local/pgsql/man</span><br><span class="line">export PGLIB MANPATH</span><br><span class="line">===================</span><br><span class="line">[root@bogon opt]#  source /home/postgres/.bash_profile</span><br><span class="line">[root@bogon opt]# cd pg_pathman-1.5.3</span><br><span class="line">[root@bogon pg_pathman-1.5.3]# make USE_PGXS=1</span><br><span class="line">[root@bogon pg_pathman-1.5.3]# make USE_PGXS=1 install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更改pg的配置文件</span></span><br><span class="line">[root@bogon pg_pathman]# cd /home/postgres/data</span><br><span class="line">[root@bogon data]# vi postgresql.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将shared_preload_libraries注释取消，将下面变量赋值进去</span></span><br><span class="line">shared_preload_libraries = &#x27;pg_pathman&#x27; -- pg_stat_statements 这个插件也可以安装</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">esc退出，wq!保存退出！</span></span><br></pre></td></tr></table></figure>

<h2 id="2、postgres用户，修改参数、创建扩展："><a href="#2、postgres用户，修改参数、创建扩展：" class="headerlink" title="2、postgres用户，修改参数、创建扩展："></a><strong>2、postgres用户，修改参数、创建扩展：</strong></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ cd $PGDATA</span><br><span class="line">$ vi postgresql.conf</span><br><span class="line">shared_preload_libraries <span class="operator">=</span> <span class="string">&#x27;pg_pathman&#x27;</span></span><br><span class="line">注意，如果还有其它的扩展参数，要把pg_pathman放到第一个。</span><br><span class="line"></span><br><span class="line">重启pg库：</span><br><span class="line">$ pg_ctl restart <span class="operator">-</span>m fast</span><br><span class="line"> </span><br><span class="line">连接进去所需要做分区的database里面，创建扩展：</span><br><span class="line"></span><br><span class="line">$ psql</span><br><span class="line">postgres<span class="operator">=</span># \c rocky</span><br><span class="line">rocky<span class="operator">=</span># <span class="keyword">create</span> extension pg_pathman;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION</span><br><span class="line"></span><br><span class="line">rocky<span class="operator">=</span># \dx</span><br><span class="line">List <span class="keyword">of</span> installed extensions</span><br><span class="line">Name <span class="operator">|</span> Version <span class="operator">|</span> Schema <span class="operator">|</span> Description </span><br><span class="line"><span class="comment">------------+---------+------------+------------------------------</span></span><br><span class="line">pg_pathman <span class="operator">|</span> <span class="number">1.1</span> <span class="operator">|</span> public <span class="operator">|</span> Partitioning tool ver. <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">rocky<span class="operator">=</span># \d</span><br><span class="line">List <span class="keyword">of</span> relations</span><br><span class="line">Schema <span class="operator">|</span> Name <span class="operator">|</span> Type <span class="operator">|</span> Owner </span><br><span class="line"><span class="comment">--------+-------------------------------+-------+----------</span></span><br><span class="line">public <span class="operator">|</span> pathman_concurrent_part_tasks <span class="operator">|</span> <span class="keyword">view</span> <span class="operator">|</span> postgres</span><br><span class="line">public <span class="operator">|</span> pathman_config <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> postgres</span><br><span class="line">public <span class="operator">|</span> pathman_config_params <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> postgres</span><br><span class="line">public <span class="operator">|</span> pathman_partition_list <span class="operator">|</span> <span class="keyword">view</span> <span class="operator">|</span> postgres</span><br></pre></td></tr></table></figure>

<p>##3、开始对表分区(先对该表做pg_dump备份，以备万一要回退。)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rocky<span class="operator">=</span># \d tabname</span><br><span class="line"> <span class="keyword">Table</span> &quot;public.tabname&quot;</span><br><span class="line"> <span class="keyword">Column</span> <span class="operator">|</span> Type <span class="operator">|</span> Modifiers </span><br><span class="line"> <span class="comment">--------+--------------------------+--------------------------------------------------</span></span><br><span class="line"> id <span class="operator">|</span> <span class="type">integer</span> <span class="operator">|</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> nextval(<span class="string">&#x27;tabname_id_seq&#x27;</span>::regclass)</span><br><span class="line"> loc <span class="operator">|</span> <span class="type">character</span> <span class="type">varying</span>(<span class="number">255</span>) <span class="operator">|</span> </span><br><span class="line"> dat <span class="operator">|</span> jsonb <span class="operator">|</span> </span><br><span class="line"> <span class="type">timestamp</span> <span class="operator">|</span> <span class="type">timestamp</span> <span class="keyword">with</span> <span class="type">time</span> zone <span class="operator">|</span> </span><br><span class="line"> Indexes:</span><br><span class="line"> &quot;tabname_pkey&quot; <span class="keyword">PRIMARY</span> KEY, btree (id)</span><br><span class="line"></span><br><span class="line">rocky<span class="operator">=</span>#</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">------分区键上必须要有非空约束</span></span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> tabname <span class="keyword">alter</span> <span class="type">timestamp</span> <span class="keyword">set</span> <span class="keyword">not</span> <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">------确定分区起始时间</span></span><br><span class="line"> <span class="keyword">select</span> <span class="built_in">min</span>(<span class="type">timestamp</span>) <span class="keyword">from</span> tabname;</span><br><span class="line"></span><br><span class="line"><span class="comment">------创建分区表</span></span><br><span class="line"> <span class="keyword">select</span> </span><br><span class="line"> create_range_partitions(<span class="string">&#x27;tabname&#x27;</span>::regclass, </span><br><span class="line"> <span class="string">&#x27;tim&#x27;</span>, </span><br><span class="line"> <span class="string">&#x27;2016-12-01 00:00:00&#x27;</span>::<span class="type">timestamp</span>, </span><br><span class="line"> <span class="type">interval</span> <span class="string">&#x27;1 month&#x27;</span>, </span><br><span class="line"> <span class="number">24</span>, </span><br><span class="line"> <span class="literal">false</span>) ; <span class="comment">------不立即将数据从主表迁移到分区</span></span><br><span class="line"></span><br><span class="line">NOTICE: sequence &quot;tabname_seq&quot; does <span class="keyword">not</span> exist, skipping</span><br><span class="line"> CONTEXT: <span class="keyword">SQL</span> statement &quot;DROP SEQUENCE IF EXISTS public.tabname_seq&quot;</span><br><span class="line"> PL<span class="operator">/</span>pgSQL <span class="keyword">function</span> create_or_replace_sequence(regclass) line <span class="number">5</span> <span class="keyword">at</span> <span class="keyword">EXECUTE</span></span><br><span class="line"> <span class="keyword">SQL</span> statement &quot;SELECT public.create_or_replace_sequence(parent_relid)</span><br><span class="line"> FROM public.get_plain_schema_and_relname(parent_relid)&quot;</span><br><span class="line"> PL<span class="operator">/</span>pgSQL <span class="keyword">function</span> create_range_partitions(regclass,text,anyelement,<span class="type">interval</span>,<span class="type">integer</span>,<span class="type">boolean</span>) line <span class="number">73</span> <span class="keyword">at</span> PERFORM</span><br><span class="line"> create_range_partitions </span><br><span class="line"> <span class="comment">-------------------------</span></span><br><span class="line"> <span class="number">24</span></span><br><span class="line"> (<span class="number">1</span> <span class="type">row</span>)</span><br><span class="line"></span><br><span class="line">rocky<span class="operator">=</span>#</span><br></pre></td></tr></table></figure>


<h2 id="4、迁移主表数据到分区表（非堵塞式）"><a href="#4、迁移主表数据到分区表（非堵塞式）" class="headerlink" title="4、迁移主表数据到分区表（非堵塞式）"></a>4、迁移主表数据到分区表（非堵塞式）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select partition_table_concurrently(&#x27;tabname&#x27;::regclass,</span><br><span class="line"> 10000,</span><br><span class="line"> 1.0);</span><br><span class="line">NOTICE: worker started, you can stop it with the following command: select public.stop_concurrent_part_task(&#x27;tabname&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="5、查看迁移状态"><a href="#5、查看迁移状态" class="headerlink" title="5、查看迁移状态"></a>5、查看迁移状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> select * from pathman_concurrent_part_tasks;</span><br><span class="line"></span><br><span class="line">rocky=# select * from pathman_concurrent_part_tasks; </span><br><span class="line"> userid | pid | dbid | relid | processed | status </span><br><span class="line"> ----------+-------+-------+-------+-----------+---------</span><br><span class="line"> postgres | 12428 | 16393 | tabname | 3970000 | working</span><br><span class="line"> (1 row)</span><br><span class="line"></span><br><span class="line">rocky=# select * from pathman_concurrent_part_tasks; </span><br><span class="line"> userid | pid | dbid | relid | processed | status </span><br><span class="line"> ----------+-------+-------+-------+-----------+---------</span><br><span class="line"> postgres | 12428 | 16393 | tabname | 7250000 | working</span><br><span class="line"> (1 row)</span><br><span class="line"></span><br><span class="line">rocky=#</span><br><span class="line"></span><br><span class="line">------迁移完毕后，查询pathman_concurrent_part_tasks表无数据返回。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="6、迁移完毕后，查看主表only，数据量为0："><a href="#6、迁移完毕后，查看主表only，数据量为0：" class="headerlink" title="6、迁移完毕后，查看主表only，数据量为0："></a>6、迁移完毕后，查看主表only，数据量为0：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rocky=# select count(*) from only tabname ;</span><br><span class="line"> count </span><br><span class="line"> -------</span><br><span class="line"> 0</span><br><span class="line"> (1 row)</span><br></pre></td></tr></table></figure>

<h2 id="7、数据迁移完成后，建议禁用主表，这样执行计划就不会出现主表了"><a href="#7、数据迁移完成后，建议禁用主表，这样执行计划就不会出现主表了" class="headerlink" title="7、数据迁移完成后，建议禁用主表，这样执行计划就不会出现主表了"></a>7、数据迁移完成后，建议禁用主表，这样执行计划就不会出现主表了</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">postgres=# select set_enable_parent(&#x27;tabname&#x27;::regclass, false);</span><br></pre></td></tr></table></figure>

<h2 id="8、数据迁移完成后，要对主表进行vacuum-full，才会回收主表的空间"><a href="#8、数据迁移完成后，要对主表进行vacuum-full，才会回收主表的空间" class="headerlink" title="8、数据迁移完成后，要对主表进行vacuum full，才会回收主表的空间:"></a>8、数据迁移完成后，要对主表进行vacuum full，才会回收主表的空间:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VACUUM (FULL,VERBOSE, ANALYZE) tabname;</span><br></pre></td></tr></table></figure>

<h2 id="9、其它常见分区表的维护操作"><a href="#9、其它常见分区表的维护操作" class="headerlink" title="9、其它常见分区表的维护操作"></a>9、其它常见分区表的维护操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---向后添加新分区</span><br><span class="line"> select append_range_partition(&#x27;tabname&#x27;::regclass);</span><br><span class="line"></span><br><span class="line">---在前面添加新分区</span><br><span class="line"> select prepend_range_partition(&#x27;tabname&#x27;::regclass);</span><br><span class="line"></span><br><span class="line">---删除某个分区，不删数据，数据被移动到主表</span><br><span class="line"> select drop_range_partition(&#x27;tabname_13&#x27;,false);</span><br><span class="line"></span><br><span class="line">---删除某个分区，同时删除数据</span><br><span class="line"> select drop_range_partition(&#x27;tabname_13&#x27;,true);</span><br><span class="line">  </span><br><span class="line"> ---设置为自动扩展分区(默认就是true)</span><br><span class="line"> select set_auto(&#x27;tabname&#x27;::regclass,true);</span><br><span class="line"> 只针对范围分区表，允许自动扩展分区。</span><br><span class="line"> 如果新插入的数据不在已有的分区范围内，会自动创建分区。</span><br><span class="line"></span><br><span class="line">rocky=# select * from pathman_config_params;</span><br><span class="line"> partrel | enable_parent | auto | init_callback | spawn_using_bgw </span><br><span class="line"> ---------+---------------+------+---------------+-----------------</span><br><span class="line"> tabname2 | f | t | | f</span><br><span class="line"> (1 row)</span><br><span class="line"></span><br><span class="line">rocky=# select auto from pathman_config_params; </span><br><span class="line"> auto </span><br><span class="line"> ------</span><br><span class="line"> t</span><br><span class="line"> (1 row)</span><br><span class="line"></span><br><span class="line"> ------删除所有分区表，并将数据迁移到主表。（即：回退分区操作）</span><br><span class="line"> select drop_partitions(&#x27;tabname&#x27;::regclass, false);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis5 集群搭建 版本5.0以上</title>
    <url>/knowledge-base/2019/10/22/redis-cluster/</url>
    <content><![CDATA[<div class="note primary"><p>搭建Redis集群</p>
</div>
<span id="more"></span>

<h2 id="1-创建集群步骤"><a href="#1-创建集群步骤" class="headerlink" title="1. 创建集群步骤"></a>1. 创建集群步骤</h2><p>IP地址：</p>
<table>
<thead>
<tr>
<th align="center">分组</th>
<th align="center">IP地址</th>
<th align="center">端口</th>
<th align="center">主备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分片一</td>
<td align="center">172.16.214.142</td>
<td align="center">7000</td>
<td align="center">主</td>
</tr>
<tr>
<td align="center">分片一</td>
<td align="center">172.16.214.142</td>
<td align="center">7001</td>
<td align="center">主</td>
</tr>
<tr>
<td align="center">分片一</td>
<td align="center">172.16.214.142</td>
<td align="center">7002</td>
<td align="center">主</td>
</tr>
<tr>
<td align="center">分片二</td>
<td align="center">172.16.214.143</td>
<td align="center">7000</td>
<td align="center">备</td>
</tr>
<tr>
<td align="center">分片二</td>
<td align="center">172.16.214.143</td>
<td align="center">7001</td>
<td align="center">备</td>
</tr>
<tr>
<td align="center">分片二</td>
<td align="center">172.16.214.143</td>
<td align="center">7002</td>
<td align="center">备</td>
</tr>
</tbody></table>
<ol>
<li>下载源码并解压编译</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xzf redis-5.0.0.tar.gz</span><br><span class="line">cd redis-5.0.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建9个Redis配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在172.16.213.142创建文件</span><br><span class="line">redis/7000/redis.conf	</span><br><span class="line">redis/7001/redis.conf</span><br><span class="line">redis/7002/redis.conf</span><br><span class="line"></span><br><span class="line">在172.16.213.143创建文件</span><br><span class="line">redis/7000/redis.conf</span><br><span class="line">redis/7001/redis.conf</span><br><span class="line">redis/7002/redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 7001  #端口</span><br><span class="line">cluster-enabled yes #启用集群模式</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 10000 #超时时间</span><br><span class="line">appendonly yes</span><br><span class="line">daemonize yes #后台运行</span><br><span class="line"># 数据存放目录 </span><br><span class="line">dir /usr/local/redis-cluster/data/redis-$&#123;自定义&#125; </span><br><span class="line"># 进程文件 </span><br><span class="line">pidfile /var/run/redis-cluster/$&#123;自定义&#125;.pid </span><br><span class="line"># 日志文件 </span><br><span class="line">logfile /usr/local/redis-cluster/log/$&#123;自定义&#125;.log </span><br><span class="line"></span><br><span class="line">其中 port 和 pidfile 需要随着 文件夹的不同调增。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server $HOME/redis/7000/redis.conf</span><br><span class="line">redis-server $HOME/redis/7001/redis.conf</span><br><span class="line">redis-server $HOME/redis/7002/redis.conf</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新建集群（如果需要手动指定人工指定主从关系 redis cluster 请参考<a href="https://blog.csdn.net/tianshi_rain/article/details/86612193%EF%BC%89">https://blog.csdn.net/tianshi_rain/article/details/86612193）</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--replicas 1 1其实代表的是一个比例，就是主节点数/从节点数的比例。那么想一想，在创建集群的时候，哪些节点是主节点呢？哪些节点是从节点呢？答案是将按照命令中IP:PORT的顺序，先是3个主节点，然后是3个从节点。</span><br><span class="line">其次，注意到图中slot的概念。slot对于Redis集群而言，就是一个存放数据的地方，就是一个槽。对于每一个Master而言，会存在一个slot的范围，而Slave则没有。在Redis集群中，依然是Master可以读、写，而Slave只读。</span><br><span class="line">数据的写入，实际上是分布的存储在slot中，这和以前1.X的主从模式是不一样的（主从模式下Master/Slave数据存储是完全一致的），因为Redis集群中3台Master的数据存储并不一样。</span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 172.16.214.142:7000 172.16.214.142:7001 172.16.214.142:7002 172.16.214.143:7000 172.16.214.143:7001 172.16.214.143:7002  172.16.214.142:8000 172.16.214.142:8001 172.16.214.142:8002  --cluster-replicas 2	</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 9 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 172.16.214.143:7002 to 172.16.214.142:7000</span><br><span class="line">Adding replica 172.16.214.143:7001 to 172.16.214.142:7000</span><br><span class="line">Adding replica 172.16.214.142:7002 to 172.16.214.143:7000</span><br><span class="line">Adding replica 172.16.214.142:8000 to 172.16.214.143:7000</span><br><span class="line">Adding replica 172.16.214.142:8001 to 172.16.214.142:7001</span><br><span class="line">Adding replica 172.16.214.142:8002 to 172.16.214.142:7001</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002</span><br><span class="line">   replicates 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee</span><br><span class="line">M: 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001</span><br><span class="line">   replicates 3e15ea6a5e5624c4d49e3c042430a5816148beb2</span><br><span class="line">S: 7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002</span><br><span class="line">   replicates 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee</span><br><span class="line">S: de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000</span><br><span class="line">   replicates 3e15ea6a5e5624c4d49e3c042430a5816148beb2</span><br><span class="line">S: 55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">S: 46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 172.16.214.142:7000)</span><br><span class="line">M: 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: 55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">M: 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: 8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3e15ea6a5e5624c4d49e3c042430a5816148beb2</span><br><span class="line">S: f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee</span><br><span class="line">S: de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3e15ea6a5e5624c4d49e3c042430a5816148beb2</span><br><span class="line">S: 7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee</span><br><span class="line">S: 46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>集群操作命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">集群</span><br><span class="line">cluster info ：打印集群的信息</span><br><span class="line">cluster nodes ：列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</span><br><span class="line">节点</span><br><span class="line">cluster meet &lt;ip&gt; &lt;port&gt; ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</span><br><span class="line">cluster forget &lt;node_id&gt; ：从集群中移除 node_id 指定的节点。</span><br><span class="line">cluster replicate &lt;master_node_id&gt; ：将当前从节点设置为 node_id 指定的master节点的slave节点。只能针对slave节点操作。</span><br><span class="line">cluster saveconfig ：将节点的配置文件保存到硬盘里面。</span><br><span class="line">槽(slot)</span><br><span class="line">cluster addslots &lt;slot&gt; [slot ...] ：将一个或多个槽（ slot）指派（ assign）给当前节点。</span><br><span class="line">cluster delslots &lt;slot&gt; [slot ...] ：移除一个或多个槽对当前节点的指派。</span><br><span class="line">cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</span><br><span class="line">cluster setslot &lt;slot&gt; node &lt;node_id&gt; ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给</span><br><span class="line">另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。</span><br><span class="line">cluster setslot &lt;slot&gt; migrating &lt;node_id&gt; ：将本节点的槽 slot 迁移到 node_id 指定的节点中。</span><br><span class="line">cluster setslot &lt;slot&gt; importing &lt;node_id&gt; ：从 node_id 指定的节点中导入槽 slot 到本节点。</span><br><span class="line">cluster setslot &lt;slot&gt; stable ：取消对槽 slot 的导入（ import）或者迁移（ migrate）。</span><br><span class="line">键</span><br><span class="line">cluster keyslot &lt;key&gt; ：计算键 key 应该被放置在哪个槽上。</span><br><span class="line">cluster countkeysinslot &lt;slot&gt; ：返回槽 slot 目前包含的键值对数量。</span><br><span class="line">cluster getkeysinslot &lt;slot&gt; &lt;count&gt; ：返回 count 个 slot 槽中的键 。</span><br><span class="line">----------</span><br><span class="line">使用redis-trib.rb工具 需要先安装 ruby</span><br><span class="line">yum install ruby</span><br></pre></td></tr></table></figure>

<h2 id="2-集群中Master的下线及恢复"><a href="#2-集群中Master的下线及恢复" class="headerlink" title="2. 集群中Master的下线及恢复"></a>2. 集群中Master的下线及恢复</h2><ol>
<li>Master下线后，其对应的Slaver节点会自动变为Master节点，如下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line">3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001@17001 master - 0 1571799879731 2 connected 10923-16383</span><br><span class="line">55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001@18001 slave 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 0 1571799878510 13 connected</span><br><span class="line">20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000@17000 master - 0 1571799879116 13 connected 5461-10922</span><br><span class="line">8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001@17001 slave 3e15ea6a5e5624c4d49e3c042430a5816148beb2 0 1571799878000 5 connected</span><br><span class="line">7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000@17000 myself,slave 7c00a2f323812a2838220c9ace4f2d387289f647 0 1571799877000 1 connected ---  主节点</span><br><span class="line">f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002@17002 slave 7c00a2f323812a2838220c9ace4f2d387289f647 0 1571799878510 10 connected</span><br><span class="line">de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000@18000 slave 3e15ea6a5e5624c4d49e3c042430a5816148beb2 0 1571799877600 7 connected</span><br><span class="line">7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002@17002 master - 0 1571799878000 10 connected 0-5460</span><br><span class="line">46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002@18002 slave 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 0 1571799878712 13 connected</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>原来的Master重启后变成Slaver节点，并是原来Master节点的Slaver节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002@18002 slave 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 0 1571799898000 13 connected</span><br><span class="line">3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001@17001 myself,master - 0 1571799898000 2 connected 10923-16383</span><br><span class="line">f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002@17002 slave 7c00a2f323812a2838220c9ace4f2d387289f647 0 1571799899502 10 connected</span><br><span class="line">8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001@17001 slave 3e15ea6a5e5624c4d49e3c042430a5816148beb2 0 1571799898493 5 connected</span><br><span class="line">7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002@17002 master - 0 1571799898597 10 connected 0-5460</span><br><span class="line">55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001@18001 slave 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 0 1571799898000 13 connected</span><br><span class="line">7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000@17000 slave,fail  -7c00a2f323812a2838220c9ace4f2d387289f647 1571799888388 1571799886000 10 disconnected ---节点故障</span><br><span class="line">20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000@17000 master - 0 1571799899505 13 connected 5461-10922  --- 有备库升级为主库</span><br><span class="line">de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000@18000 slave 3e15ea6a5e5624c4d49e3c042430a5816148beb2 0 1571799898596 7 connected</span><br></pre></td></tr></table></figure>

<h2 id="3-添加节点"><a href="#3-添加节点" class="headerlink" title="3. 添加节点"></a>3. 添加节点</h2><ol>
<li>添加节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis/</span><br><span class="line">mkdir 9000</span><br><span class="line">cp 7000/redis.conf 9000/redis.conf &amp;&amp; sed -i &quot;s/7000/9000/g&quot; 9000/redis.conf  </span><br><span class="line">cp 7000/redis.conf 9001/redis.conf &amp;&amp; sed -i &quot;s/7000/9001/g&quot; 9001/redis.conf</span><br><span class="line">cp 7000/redis.conf 9002/redis.conf &amp;&amp; sed -i &quot;s/7000/9002/g&quot; 9002/redis.conf</span><br><span class="line">redis-server $HOME/redis/9000/redis.conf</span><br><span class="line">redis-server $HOME/redis/9001/redis.conf</span><br><span class="line">redis-server $HOME/redis/9002/redis.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加主节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-cli --cluster add-node 172.16.214.142:9000 172.16.214.142:8002</span></span><br><span class="line">注释：</span><br><span class="line">172.16.214.142:9000是新增的节点</span><br><span class="line">172.16.214.142:8002集群任一个旧节点</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加备节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master-id 需要cluster nodes 查询</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis-cli --cluster add-node 172.16.214.142:9001 172.16.214.142:8002 --cluster-slave --cluster-master-id  d8fbb406875cff2432dc2e2fdf7a13863da34496</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis-cli --cluster add-node --cluster-slave --cluster-master-id  d8fbb406875cff2432dc2e2fdf7a13863da34496 172.16.214.142:9002 172.16.214.142:8002</span></span><br><span class="line">注释：</span><br><span class="line">--slave，表示添加的是从节点</span><br><span class="line">--master-id d8fbb406875cff2432dc2e2fdf7a13863da34496,主节点的node id，在这里是前面新添加的9000的node id</span><br><span class="line">172.16.214.142:9002,新节点</span><br><span class="line">172.16.214.142:8002集群任一个旧节点</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新分配slot</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli  --cluster reshard 172.16.214.142:9000</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 172.16.214.142:9000)</span></span><br><span class="line">M: d8fbb406875cff2432dc2e2fdf7a13863da34496 172.16.214.142:9000</span><br><span class="line">   slots:[0-999],[5461-6461],[10923-11923] (3002 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001</span><br><span class="line">   slots:[11924-16383] (4460 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002</span><br><span class="line">   slots:[1000-5460] (4461 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000</span><br><span class="line">   slots:[6462-10922] (4461 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8890a21d264622ff752fb7ae9cf679389f4f1ebe</span><br><span class="line">S: 3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8890a21d264622ff752fb7ae9cf679389f4f1ebe</span><br><span class="line">S: 10132b71a3b4820c870e63328d499d0aeac4bfbf 172.16.214.142:9002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d8fbb406875cff2432dc2e2fdf7a13863da34496</span><br><span class="line">S: f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7c00a2f323812a2838220c9ace4f2d387289f647</span><br><span class="line">S: 72b738f820fb9547d3679dc7484fa8b1e192034c 172.16.214.142:9001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d8fbb406875cff2432dc2e2fdf7a13863da34496</span><br><span class="line">S: 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7c00a2f323812a2838220c9ace4f2d387289f647</span><br><span class="line">S: 46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">S: 55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)?  200 --- 从分片中移除多少槽位</span><br><span class="line">What is the receiving node ID? d8fbb406875cff2432dc2e2fdf7a13863da34496 --移动的目的主机的ID</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: 8890a21d264622ff752fb7ae9cf679389f4f1ebe  --- 移动的第一台机器</span><br><span class="line">Source node #2: 7c00a2f323812a2838220c9ace4f2d387289f647  --- 移动的第二台机器</span><br><span class="line">Source node #3: done  --结束</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>平衡（rebalance）<strong>slot</strong> ：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> redis-cli  --cluster rebalance 172.16.214.142:9000     </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing Cluster Check (using node 172.16.214.142:9000)</span></span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Rebalancing across 4 nodes. Total weight = 4.00</span></span><br><span class="line">Moving 365 slots from 172.16.214.143:7000 to 172.16.214.142:9000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################################################################################################################################################################################################################################################################################################################################################################</span></span></span><br><span class="line">Moving 265 slots from 172.16.214.143:7001 to 172.16.214.142:9000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########################################################################################################################################################################################################################################################################</span></span></span><br><span class="line">Moving 264 slots from 172.16.214.143:7002 to 172.16.214.142:9000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#######################################################################################################################################################################################################################################################################</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>删除节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node 172.16.214.142:9000 f6a6957421b80409106cb36be3c7ba41f3b603ff</span><br><span class="line">说明：指定IP、端口和node_id 来删除一个节点，从节点可以直接删除，主节点不能直接删除，删除之后，该节点会被shutdown</span><br><span class="line"></span><br><span class="line">注意：当被删除掉的节点重新起来之后不能自动加入集群，但其和主的复制还是正常的，也可以通过该节点看到集群信息（通过其他正常节点已经看不到该被del-node节点的信息）。</span><br><span class="line">如果想要再次加入集群，则需要先在该节点执行cluster reset，再用add-node进行添加，进行增量同步复制。</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 172.16.214.142:9000 --cluster-search-multiple-owners</span><br><span class="line">说明：任意连接一个集群节点，进行集群状态检查</span><br><span class="line">172.16.214.142:9000 (d8fbb406...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7001 (8890a21d...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7002 (7c00a2f3...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7000 (20eb5f35...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">[OK] 0 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 172.16.214.142:9000)</span><br><span class="line">M: d8fbb406875cff2432dc2e2fdf7a13863da34496 172.16.214.142:9000</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br></pre></td></tr></table></figure>
</li>
<li><p>集群信息查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster info 172.16.214.143:7000</span><br><span class="line">说明：检查key、slots、从节点个数的分配情况</span><br><span class="line">172.16.214.143:7000 (20eb5f35...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.142:9000 (d8fbb406...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7001 (8890a21d...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7002 (7c00a2f3...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">[OK] 0 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复集群</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster fix 172.16.214.143:9000 --cluster-search-multiple-owners</span><br><span class="line">说明：修复集群和槽的重复分配问题</span><br><span class="line">172.16.214.142:9000 (d8fbb406...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7001 (8890a21d...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7002 (7c00a2f3...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">172.16.214.143:7000 (20eb5f35...) -&gt; 0 keys | 4096 slots | 2 slaves.</span><br><span class="line">[OK] 0 keys in 4 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 172.16.214.142:9000)</span><br><span class="line">M: d8fbb406875cff2432dc2e2fdf7a13863da34496 172.16.214.142:9000</span><br><span class="line">   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 8890a21d264622ff752fb7ae9cf679389f4f1ebe 172.16.214.143:7001</span><br><span class="line">   slots:[12288-16383] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 7c00a2f323812a2838220c9ace4f2d387289f647 172.16.214.143:7002</span><br><span class="line">   slots:[1365-5460] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">M: 20eb5f35e0ce5968932e0c8b9a3bc94294344c93 172.16.214.143:7000</span><br><span class="line">   slots:[6827-10922] (4096 slots) master</span><br><span class="line">   2 additional replica(s)</span><br><span class="line">S: de6efb3058580e787a0ca7e543cf7ec2fe71f7c5 172.16.214.142:8000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8890a21d264622ff752fb7ae9cf679389f4f1ebe</span><br><span class="line">S: 3e15ea6a5e5624c4d49e3c042430a5816148beb2 172.16.214.142:7001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8890a21d264622ff752fb7ae9cf679389f4f1ebe</span><br><span class="line">S: 10132b71a3b4820c870e63328d499d0aeac4bfbf 172.16.214.142:9002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d8fbb406875cff2432dc2e2fdf7a13863da34496</span><br><span class="line">S: f1b4992c8529356b8469ac48e9e03c1bbca54170 172.16.214.142:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7c00a2f323812a2838220c9ace4f2d387289f647</span><br><span class="line">S: 72b738f820fb9547d3679dc7484fa8b1e192034c 172.16.214.142:9001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d8fbb406875cff2432dc2e2fdf7a13863da34496</span><br><span class="line">S: 7a1bfc2662ac52e5f38ead84e1dc4984761b92ee 172.16.214.142:7000</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7c00a2f323812a2838220c9ace4f2d387289f647</span><br><span class="line">S: 46cd3b6e687d6e4f3391d675e724e2393bd37974 172.16.214.142:8002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">S: 55fdb07650b7fb8f43c19bc7ffbe25378ff2e775 172.16.214.142:8001</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 20eb5f35e0ce5968932e0c8b9a3bc94294344c93</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Check for multiple slot owners...</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置集群的超时时间 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster set-timeout 172.16.214.142:8001 10000</span><br><span class="line">说明：连接到集群的任意一节点来设置集群的超时时间参数cluster-node-timeout</span><br></pre></td></tr></table></figure>
</li>
<li><p>集群中执行相关命令</p>
<figure class="highlight plaintext"><figcaption><span>l</span></figcaption><table><tr><td class="code"><pre><span class="line">redis-cli --cluster call 192.168.163.132:6381 config set requirepass cc  -- 设置请求密码</span><br><span class="line">redis-cli -a cc --cluster call 192.168.163.132:6381 config set masterauth cc --master配置了密码进行主从同步</span><br><span class="line">redis-cli -a cc --cluster call 192.168.163.132:6381 config rewrite-- 命令对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写。</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>redis-cli --cluster create 172.16.214.143:6379 172.16.214.142:6380 172.16.214.144:6381 --cluster-replicas 0
                                                                    从                    主
redis-cli --cluster add-node  172.16.214.142:6379 172.16.214.143:6379  --cluster-slave --cluster-master-id 248697cc36b13bd5987f6aef43f2255a47348163
redis-cli --cluster add-node  172.16.214.144:6380 172.16.214.142:6380 --cluster-slave --cluster-master-id 844463de071e31da1107f8260892334bb61dc979
redis-cli --cluster add-node  172.16.214.143:6381 172.16.214.144:6381 --cluster-slave --cluster-master-id 900b5cfc908c64d8b6889cd7447522dea2337233
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis keepalived 集群搭建</title>
    <url>/knowledge-base/2019/10/22/redis-keepalived/</url>
    <content><![CDATA[<div class="note primary"><p>搭建Redis集群</p>
</div>
<span id="more"></span>


<h2 id="一、-Redis使用数据结构-Hash类型"><a href="#一、-Redis使用数据结构-Hash类型" class="headerlink" title="一、 Redis使用数据结构-Hash类型"></a>一、 Redis使用数据结构-Hash类型</h2><p><strong>Hash类型</strong>是String类型的field和value映射表，或者说是一个String集合，它特别适合存储对象，相比较而言，将一个对象类型存储在Hash类型里要比存储在String类型类，占用 更小的内存空间，并方便存取整个对象。</p>
<blockquote>
<p>适合场景为数据库表迁移到redis数据库中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hash数据键值使用规则：【表名+索引值】，为确保键值的唯一性。</span><br><span class="line">Hash类型相关命令：</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 -- 连接redis</span><br><span class="line">1. 设置值</span><br><span class="line">hset 键值             域      值   域   值</span><br><span class="line">hset ol_deptinfo123456 operno xxxx dept asdsa</span><br><span class="line">2. 获取值</span><br><span class="line">hget ol_deptinfo123456  dept</span><br><span class="line">3. 删除field</span><br><span class="line">hdel ol_deptinfo123456  dept</span><br><span class="line">4. 计算field个数</span><br><span class="line">hlen ol_deptinfo123456</span><br><span class="line">5. 批量设置或者获取field-value</span><br><span class="line">hmset ol_deptinfo123456 operno xxxx dept asdfsaf time 201923</span><br><span class="line">hmget ol_deptinfo123456 operno dept time</span><br><span class="line">6. 判断field是否存在</span><br><span class="line">hexists ol_deptinfo123456 dept</span><br><span class="line">7. 获取所有的field</span><br><span class="line">hkeys ol_deptinfo123456</span><br><span class="line">8. 获取所有的value</span><br><span class="line">hvals ol_deptinfo123456</span><br><span class="line">9. 获取所有的field-value</span><br><span class="line">hgetall ol_deptinfo123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis生产危险命令,禁止在生产上运行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. keys *</span><br><span class="line">虽然其模糊匹配功能使用非常方便也很强大，在小数据量情况下使用没什么问题，数据量大会导致 Redis 锁住及 CPU 飙升，</span><br><span class="line">2. flushdb </span><br><span class="line">删除 Redis 中当前所在数据库中的所有记录，并且此命令从不会执行失败</span><br><span class="line">3. flushall</span><br><span class="line">删除 Redis 中所有数据库中的所有记录，不只是当前所在数据库，并且此命令从不会执行失败。</span><br><span class="line">4. config</span><br><span class="line">客户端可修改 Redis 配置。</span><br></pre></td></tr></table></figure>

<h2 id="二、redis高可用方案"><a href="#二、redis高可用方案" class="headerlink" title="二、redis高可用方案"></a>二、redis高可用方案</h2><h3 id="1-基本构建与原理"><a href="#1-基本构建与原理" class="headerlink" title="1. 基本构建与原理"></a>1. 基本构建与原理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">渠道采用的是Redis Master-Slave + Keepalived + VIP</span><br><span class="line">1）Keepalived + VIP : 在redis master-slave上部署keepalived、redis instance存活检测脚本、以及告警通知脚本。</span><br><span class="line">2）当redis master失效的时候，VIP从master上漂移到slave上，完成m-s角色和配置更改。3）客户端连接redis的参数中host设置的是VIP，整个切换过程对客户端透明。</span><br></pre></td></tr></table></figure>

<h3 id="2-keepalived的选择"><a href="#2-keepalived的选择" class="headerlink" title="2. keepalived的选择"></a>2. keepalived的选择</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果使用的红旗AX4 SP4的系统，请安装系统自带的keepalived的版本，使用网上下载的版本可能存在不兼容的情况，特别是在用keepavlied stop命令的时候，会存在无法停止的现象。</span><br></pre></td></tr></table></figure>

<h3 id="3-keepalived-Redis（一主三备）-的部署"><a href="#3-keepalived-Redis（一主三备）-的部署" class="headerlink" title="3. keepalived + Redis（一主三备） 的部署"></a>3. keepalived + Redis（一主三备） 的部署</h3><p>部署实例IP地址</p>
<table>
<thead>
<tr>
<th align="center">IP地址</th>
<th align="center">端口</th>
<th align="center">VIP</th>
<th align="center">主备关系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">20.200.21.3</td>
<td align="center">6379</td>
<td align="center">20.200.21.100</td>
<td align="center">主</td>
</tr>
<tr>
<td align="center">20.200.21.4</td>
<td align="center">6379</td>
<td align="center"></td>
<td align="center">备</td>
</tr>
<tr>
<td align="center">20.200.21.5</td>
<td align="center">6379</td>
<td align="center"></td>
<td align="center">备</td>
</tr>
<tr>
<td align="center">20.200.21.6</td>
<td align="center">6379</td>
<td align="center"></td>
<td align="center">备</td>
</tr>
</tbody></table>
<h4 id="3-1-redis-安装"><a href="#3-1-redis-安装" class="headerlink" title="3.1 redis 安装"></a>3.1 redis 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1. 首先从官网（http://download.redis.io/releases/）下载redis正式版的压缩包redis-3.2.8.tar.gz   </span><br><span class="line">分别在20.200.21.3/4/5/6机器上执行</span><br><span class="line">2. 编译源码安装： </span><br><span class="line">tar -xzvf redis-3.2.8.tar.gz </span><br><span class="line">cd redis-3.2.8</span><br><span class="line">make </span><br><span class="line">安装在普通用户</span><br><span class="line">mkdir $HOME/bin</span><br><span class="line">cp redis-3.2.8/src/redis-* $HOME/bin</span><br><span class="line">mkdir $HOME/redis</span><br><span class="line">cp redis-3.2.8/redis.conf $HOME/redis</span><br><span class="line">=================================</span><br><span class="line">编写启动脚本</span><br><span class="line">vi start.sh</span><br><span class="line">reids-server $HOME/redis/redis.conf</span><br><span class="line">添加环境变量</span><br><span class="line">vi ～/.bash_profile</span><br><span class="line">export PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure>

<h4 id="3-2-修改redis配置文件"><a href="#3-2-修改redis配置文件" class="headerlink" title="3.2 修改redis配置文件"></a>3.2 修改redis配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim redis.conf </span><br><span class="line">修改相关配置项，这里仅做DOME演示，其他配置项默认。 </span><br><span class="line">修改redis master的redis.conf </span><br><span class="line">daemonize yes </span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 6379</span><br><span class="line">logfile &quot;/var/log/redis-6379.log&quot;</span><br><span class="line">dir &quot;/app/chredis/redis/&quot; --- “家目录/redis/”</span><br></pre></td></tr></table></figure>

<h4 id="3-3-启动Redis"><a href="#3-3-启动Redis" class="headerlink" title="3.3 启动Redis"></a>3.3 启动Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在20.200.21.3/4/5/6上启动</span><br><span class="line">sh start.sh</span><br></pre></td></tr></table></figure>

<h4 id="3-4-keepalived-配置主从公共脚本"><a href="#3-4-keepalived-配置主从公共脚本" class="headerlink" title="3.4 keepalived 配置主从公共脚本"></a>3.4 keepalived 配置主从公共脚本</h4><h5 id="3-4-1-Redis-监控脚本"><a href="#3-4-1-Redis-监控脚本" class="headerlink" title="3.4.1 Redis 监控脚本"></a>3.4.1 Redis 监控脚本</h5><p>该脚本检测redis的运行状态,如果启动失败则停止keepalived，准备让其它机器接管。</p>
<p>&#x2F;etc&#x2F;keepalived&#x2F;scripts&#x2F;check_redis.sh:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">ALIVE=`/app/chredis/bin/redis-cli -h $1 -p $2 PING`</span><br><span class="line">LOGFILE=&quot;/var/log/keepalived-redis-check.log&quot;</span><br><span class="line">echo &quot;[CHECK]&quot; &gt;&gt; $LOGFILE</span><br><span class="line">date &gt;&gt; $LOGFILE</span><br><span class="line">if [ $ALIVE == &quot;PONG&quot; ]; then :</span><br><span class="line">   echo &quot;Success: redis-cli -h $1 -p $2 PING $ALIVE&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line">   exit 0</span><br><span class="line">else</span><br><span class="line">   echo &quot;Failed:redis-cli -h $1 -p $2 PING $ALIVE &quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>keepalived根据监控脚本的返回码调整优先级：</p>
<p>☉如果脚本返回码为0，并且weight配置的值大于0，则优先级相应的增加；</p>
<p>☉如果脚本返回码为非0，并且weight配置的值小于0，则优先级相应的减少；</p>
<p>☉其他情况，原本配置的优先级不变，即配置文件中priority对应的值。</p>
<p>提示：</p>
<p>优先级不会不断的提高或者降低；</p>
<p>可以编写多个检测脚本并为每个检测脚本设置不同的weight（在配置中列出就行）；</p>
<p>不管提高优先级还是降低优先级，最终优先级的范围是在[1,254]，不会出现优先级小于等于0或者优先级大于等于255的情况；</p>
<blockquote>
<p>在vrrp_script模块中，如果不设置“weight”选项值，那么集群优先级的选择将由Keepalived配置文件中的“priority”值决定</p>
</blockquote>
<p>在MASTER节点的 vrrp_instance 中 配置 nopreempt ，当它异常恢复后，即使它 prio 更高也不会抢占，这样可以避免正常情况下做无谓的切换。</p>
<p>以上可以做到利用脚本检测业务进程的状态，并动态调整优先级从而实现主备切换。</p>
<h5 id="3-4-2-redis-fault-sh"><a href="#3-4-2-redis-fault-sh" class="headerlink" title="3.4.2 redis_fault.sh"></a>3.4.2 redis_fault.sh</h5><p>vim &#x2F;etc&#x2F;keepalived&#x2F;scripts&#x2F;redis_fault.sh </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span> </span><br><span class="line">LOGFILE=/var/log/keepalived-redis-state.log</span><br><span class="line">echo &quot;[fault]&quot; &gt;&gt; $LOGFILE</span><br><span class="line">date &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;redis 出现故障,无法ping通,请检查redis服务&quot; &gt;&gt; $LOGFILE</span><br></pre></td></tr></table></figure>

<h5 id="3-4-3-redis-stop-sh"><a href="#3-4-3-redis-stop-sh" class="headerlink" title="3.4.3 redis_stop.sh"></a>3.4.3 redis_stop.sh</h5><p>vim &#x2F;etc&#x2F;keepalived&#x2F;scripts&#x2F;redis_stop.sh  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">LOGFILE=/var/log/keepalived-redis-state.log</span><br><span class="line">echo &quot;[stop]&quot; &gt;&gt; $LOGFILE</span><br><span class="line">date &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;$2 $3&quot; &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;keepalived 出现故障,redis变为备机&quot;&gt;&gt; $LOGFILE</span><br><span class="line">REDISCLI=&quot;/app/chredis/bin/redis-cli -h $1 -p $3&quot;</span><br><span class="line">echo &quot;Being slave....&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line">echo &quot;Run SLAVEOF cmd ...&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">REDISCLI SLAVEOF <span class="variable">$2</span> <span class="variable">$3</span> &gt;&gt; <span class="variable">$LOGFILE</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-4-Redis-Master-Scripts"><a href="#3-4-4-Redis-Master-Scripts" class="headerlink" title="3.4.4 Redis Master Scripts"></a>3.4.4 Redis Master Scripts</h5><p>  在redis master配置：</p>
<p>   vim&#x2F;etc&#x2F;keepalived&#x2F;scripts&#x2F;redis_master.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">REDISCLI=&quot;/app/chredis/bin/redis-cli -h $1 -p $3&quot;</span><br><span class="line">LOGFILE=&quot;/var/log/keepalived-redis-state.log&quot;</span><br><span class="line">echo &quot;[master]&quot; &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;$2 $3&quot; &gt;&gt;$LOGFILE</span><br><span class="line">echo &quot;关闭备份,转换成主机模式&quot; &gt;&gt; $LOGFILE</span><br><span class="line">date &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;Being master....&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line">echo &quot;Run SLAVEOF NO ONE cmd ... &quot; &gt;&gt; $LOGFILE</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">REDISCLI SLAVEOF NO ONE &gt;&gt; <span class="variable">$LOGFILE</span> 2&gt;&amp;1</span></span><br><span class="line">echo &quot;close slaver ,become master &quot; &gt;&gt; $LOGFILE</span><br><span class="line">sleep 5</span><br></pre></td></tr></table></figure>

<h5 id="3-4-5-Redis-Backup-Scripts"><a href="#3-4-5-Redis-Backup-Scripts" class="headerlink" title="3.4.5 Redis Backup Scripts"></a>3.4.5 Redis Backup Scripts</h5><p>  在redis backup配置：</p>
<p>   vim &#x2F;etc&#x2F;keepalived&#x2F;scripts&#x2F;redis_backup.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">REDISCLI=&quot;/app/chredis/bin/redis-cli -h $1 -p $3&quot;</span><br><span class="line">LOGFILE=&quot;/var/log/keepalived-redis-state.log&quot;</span><br><span class="line">echo &quot;[BACKUP]&quot; &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;$1 $3&quot; &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;关闭主机模式,转为备机模式&quot; &gt;&gt; $LOGFILE</span><br><span class="line">date &gt;&gt; $LOGFILE</span><br><span class="line">echo &quot;Being slave....&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line">echo &quot;Run SLAVEOF cmd ...&quot; &gt;&gt; $LOGFILE 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">REDISCLI SLAVEOF <span class="variable">$2</span> <span class="variable">$3</span> &gt;&gt; <span class="variable">$LOGFILE</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-4-6-配置keepalived-conf"><a href="#3-4-6-配置keepalived-conf" class="headerlink" title="3.4.6 配置keepalived.conf"></a>3.4.6 配置keepalived.conf</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id test</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_redis</span><br><span class="line">&#123;</span><br><span class="line">     script &quot;/etc/keepalived/scripts/redis_check.sh 127.0.0.1 6379&quot;</span><br><span class="line">     interval 2</span><br><span class="line">     timeout 2</span><br><span class="line">     fall 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance redis &#123;</span><br><span class="line">    state BACKUP    # 主也配置成SLAVE</span><br><span class="line">    interface eth0  # 使用的网卡</span><br><span class="line">    # 这里设置VRID，这里非常重要，相同的VRID为一个组，他将决定多播的MAC地址</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    # 优先权 在不同的机器配置不一样，他决定了优先级，21.3-&gt;200 21.4-&gt;150 21.5-&gt;100 21.6-&gt;50</span><br><span class="line">    priority  200      # 注意</span><br><span class="line">    nopreempt</span><br><span class="line">    # 不抢占，注意加上，如果不加，在主停机后再重启，由于优先级高，还会抢占为主。</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass lulu</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   20.200.21.100/26 brd 20.200.21.63 dev eth0   <span class="comment"># VIP</span></span></span><br><span class="line">    20.200.21.100  dev eth0   # VIP</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">         chk_redis</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master &quot;/etc/keepalived/scripts/redis_master.sh 127.0.0.1 20.200.21.100 6379&quot;</span><br><span class="line">    notify_backup &quot;/etc/keepalived/scripts/redis_backup.sh 127.0.0.1 20.200.21.100 6379&quot;</span><br><span class="line">    #由于master的IP一直在变，所以必须使用VIP</span><br><span class="line">    notify_fault /etc/keepalived/scripts/redis_fault.sh </span><br><span class="line">    notify_stop &quot;/etc/keepalived/scripts/redis_stop.sh 127.0.0.1 20.200.21.100 6379&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在同一个网段内的，若为不同的应用做高可用，不同应用使用不同的VIP，那么vrrp_instance的名字（这里是VI_REDIS）、virtual_router_id在不同的高可用实例必须设置不同的值区分开。否则keepalived会报如下错误：</p>
<p>Aug 11 11:28:36 localhostKeepalived_vrrp[16958]: (VI_1): received an invalid ip number count 1, expected2!</p>
<p>Aug 11 11:28:36 localhostKeepalived_vrrp[16958]: bogus VRRP packet received on eth0 !!!</p>
<p>Aug 11 11:28:36 localhostKeepalived_vrrp[16958]: VRRP_Instance(VI_1) Dropping received VRRP packet…</p>
<p>以上是keepalived MASTER节点配置文件&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf的配置信息。在BACKUP节点，只需把vrrp_instance-&gt;state改为BACKUP，vrrp_instance-&gt;priority改为99即可。</p>
<p>在默认的keepalive.conf里面还有 virtual_server,real_server 这样的配置，我们这用不到，它是为lvs准备的。 notify 可以定义在切换成MASTER或BACKUP时执行的脚本，如有需求请自行google。</p>
<p>  配置选项说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global_defs</span><br><span class="line">☉notification_email： keepalived在发生诸如切换操作时需要发送email通知地址，后面的 smtp_server 相比也都知道是邮件服务器地址。也可以通过其它方式报警，毕竟邮件不是实时通知的。</span><br><span class="line">☉router_id： 机器标识，通常可设为hostname。故障发生时，邮件通知会用到</span><br><span class="line"></span><br><span class="line">vrrp_instance</span><br><span class="line">☉state ： 指定instance(Initial)的初始状态，就是说在配置好后，这台服务器的初始状态就是这里指定的，但这里指定的不算，还是得要通过竞选通过优先级来确定。如果这里设置为MASTER，但如若他的优先级不及另外一台，那么这台在发送通告时，会发送自己的优先级，另外一台发现优先级不如自己的高，那么他会就回抢占为MASTER</span><br><span class="line">☉interface： 实例绑定的网卡，因为在配置虚拟IP的时候必须是在已有的网卡上添加的，可以用ifconfig命令查看网卡。</span><br><span class="line">☉mcast_src_ip： 发送多播数据包时的源IP地址，这里注意了，这里实际上就是在那个地址上发送VRRP通告，这个非常重要，一定要选择稳定的网卡端口来发送，这里相当于heartbeat的心跳端口，如果没有设置那么就用默认的绑定的网卡的IP，也就是interface指定的IP地址</span><br><span class="line">☉virtual_router_id： 这里设置VRID，这里非常重要，相同的VRID为一个组，他将决定多播的MAC地址</span><br><span class="line">☉priority： 设置本节点的优先级，优先级高的为master</span><br><span class="line">☉advert_int： 检查间隔，默认为1秒。这就是VRRP的定时器，MASTER每隔这样一个时间间隔，就会发送一个advertisement报文以通知组内其他路由器自己工作正常</span><br><span class="line">☉authentication： 定义认证方式和密码，主从必须一样，样例用的是密码方式。</span><br><span class="line">☉virtual_ipaddress： 这里设置的就是VIP，也就是虚拟IP地址，他随着state的变化而增加删除，当state为master的时候就添加，当state为backup的时候删除，这里主要是有优先级来决定的，和state设置的值没有多大关系。这里可以设置多个虚拟IP地址，类似于一个域名可以解析对应多个IP地址。</span><br><span class="line">☉track_script： 引用VRRP脚本，即在 vrrp_script 部分指定的名字。每隔vrrp_script-&gt;interval时间运行脚本，如果监控服务有异常则改变优先级，并最终引发主备切换。</span><br><span class="line"></span><br><span class="line">vrrp_script</span><br><span class="line">告诉 keepalived 在什么情况下切换，所以尤为重要。可以有多个 vrrp_script</span><br><span class="line">☉script ： 自己写的检测脚本。</span><br><span class="line">☉interval4 ： 每4s检测一次，这里要大于监控脚本执行的时间，监控脚本会执行超时，keepalived会发送SIGTERM信号结束监控脚本的执行。</span><br><span class="line">☉weight-5 ： 检测失败（脚本返回非0）则优先级 -5</span><br><span class="line">☉fall 2： 检测连续 2 次失败才算确定是真失败。会用weight减少优先级（1-255之间）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###3.5 启动keepalived </p>
<p>在Redis Master和Redis Backup上将keepalived启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动keepalived：</span><br><span class="line">service keepalived start</span><br><span class="line">或者</span><br><span class="line">/etc/init.d/keepalived start</span><br><span class="line"></span><br><span class="line">查看进程，正常会有三个进程</span><br><span class="line">[root@localhost ~]# ps -ef | grepkeepalived</span><br><span class="line">root     3870     1  0 14:46 ?        00:00:00 keepalived -D</span><br><span class="line">root     3872  3870  0 14:46 ?        00:00:00 keepalived -D</span><br><span class="line">root     3873  3870  0 14:46 ?       00:00:00 keepalived -D</span><br><span class="line">root     3887 18774  0 14:46 pts/1    00:00:00 grep keepalived</span><br><span class="line"></span><br><span class="line">用ip命令查看VIP，ifconfig命令不能查看虚拟IP。</span><br><span class="line">[root@localhost ~]#  ip a | grep eth1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-6-测试VIP漂移"><a href="#3-6-测试VIP漂移" class="headerlink" title="3.6 测试VIP漂移"></a>3.6 测试VIP漂移</h3><p>测试时可以用命令tail -f &#x2F;var&#x2F;log&#x2F;messages查看keepalived的日志，查看主从机器状态的变化，VIP的漂移等。</p>
<p>测试前，先确定那台机器接管着VIP，使用 ip a 在每台机器执行，确定VIP地址在20.200.21.3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    inet 20.200.21.3/24 brd 20.200.21.255 scope global eth1</span><br><span class="line">    inet 20.200.21.100/32 scope global eth0</span><br></pre></td></tr></table></figure>

<p>现在，把20.200.21.3机器上redis-server杀掉，查看VIP是否漂移</p>
<p>由于21.4 的优先级为150，VIP会漂移到21.4,21.4 成为了主库。</p>
<p>20.200.21.3加入集群，登录root用户service keepalived stop,备份redis的dump 文件，重启redis ，之后进入root用户service keepalived start.</p>
<h2 id="三、Redis-切换方案"><a href="#三、Redis-切换方案" class="headerlink" title="三、Redis 切换方案"></a>三、Redis 切换方案</h2><p>&#x2F;etc&#x2F;keepalived&#x2F;start.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/keepalived start</span><br><span class="line">ps -ef|grep keepalived</span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;keepalived&#x2F;stop.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/keepalived start</span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;keepalived&#x2F;test.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/app/chredis/bin/redis-cli -p 6379 info |grep -A 5 Replication</span><br></pre></td></tr></table></figure>

<p>###场景一：模拟切换演练，手动切换主到不同中心（以分片一为例）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20.200.21.3为主，20.200.21.4为备一 20.200.21.5为备二、20.200.21.6为备三</span><br><span class="line">操作： </span><br><span class="line">1、登录到20.200.21.3的root用户，cd /etc/keepalived的目录，执行sh stop.sh ,停止keepavlied的进程，</span><br><span class="line">2、再执行sh start.sh，启动keepalived的进程，使用ip a检查VIP 20.200.21.100是否已经漂移到其他机器，</span><br><span class="line">3、使用sh test.sh 检查redis的状态，查看主是否为 20.200.21.100</span><br><span class="line">4、如果VIP漂移到其他中心，无须继续操作，如果漂移到同中心，需要继续操作</span><br><span class="line">5、登录到20.200.21.4的root用户，cd /etc/keepalived的目录，执行sh stop.sh ,停止keepavlied的进程，</span><br><span class="line">6、再执行sh start.sh，启动keepalived的进程，使用ip a检查VIP 20.200.21.100是否已经漂移到其他机器，</span><br><span class="line">7、使用sh test.sh 检查redis的状态，查看主是否为 20.200.21.100</span><br></pre></td></tr></table></figure>

<p>###场景二：物理主机宕机，启动后需要回复redis为备库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.登录到chredis用户，cd redis/端口号/</span><br><span class="line">2.为使备库顺利加入集群移除源数据，mv dump.db dump.rdb.20190810（日期） mv appendonly_端口.aof appendonly_端口.aof.20190810</span><br><span class="line">3. 启动 redis; cd bin; sh start.sh</span><br><span class="line">4. 登录到root用户，cd /etc/keepalived/,sh start.sh</span><br><span class="line">5. 检查redis的状态，sh test.sh 显示如下为正确状态，否启动不正常。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:20.200.21.100</span><br><span class="line">master_port</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">6. 再不正常 的情况下，重新启动keepalived ;sh stop.sh ;sh start.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#  由于客户端是读写分离会有部分交易找不数据。主要表现在柜员无权限</span></span></span><br></pre></td></tr></table></figure>

<p>###场景三：redis的主备库已经不存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 如果是这样，首先启动的为主，以分片一为例，登录|20.200.21.3chredis用户||</span><br><span class="line">cd bin;sh start.sh启动redis（停机redis的数据会存在dump.rdb中，一般不会出现数据丢失）</span><br><span class="line">登录root用户</span><br><span class="line">cd /etc/keepalived; sh start.sh 启动 keepalived</span><br><span class="line"></span><br><span class="line">====================注意事项===================================</span><br><span class="line">---- 再回复主的时间由于要重新读取dump.rdb的数据，会有一段时间的数据加载过程，这期间客户端会出现错误；</span><br><span class="line">主要体现在报错返回 r-&gt;str[LOADING Redis is loading the dataset in memory].</span><br><span class="line">测试 420万的数据需要3-4分钟完成。</span><br><span class="line">====================注意事项===================================</span><br><span class="line"></span><br><span class="line">2.登录到20.200.21.4 chredis用户，cd redis/6379/</span><br><span class="line">为使备库顺利加入集群移除源数据，mv dump.db dump.rdb.20190810（日期） mv appendonly_6379.aof appendonly_6379.aof.20190810</span><br><span class="line">启动 redis; cd bin; sh start.sh</span><br><span class="line">登录到root用户，cd /etc/keepalived/,sh start.sh</span><br><span class="line">检查redis的状态，sh test.sh 显示如下为正确状态，否启动不正常。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:20.200.21.100</span><br><span class="line">master_port</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">再不正常 的情况下，重新启动keepalived ;sh stop.sh ;sh start.sh</span><br><span class="line"></span><br><span class="line">3.登录到20.200.21.5 chredis用户，cd redis/6379/</span><br><span class="line">为使备库顺利加入集群移除源数据，mv dump.db dump.rdb.20190810（日期） mv appendonly_6379.aof appendonly_6379.aof.20190810</span><br><span class="line">启动 redis; cd bin; sh start.sh</span><br><span class="line">登录到root用户，cd /etc/keepalived/,sh start.sh</span><br><span class="line">检查redis的状态，sh test.sh 显示如下为正确状态，否启动不正常。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:20.200.21.100</span><br><span class="line">master_port</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">再不正常 的情况下，重新启动keepalived ;sh stop.sh ;sh start.sh</span><br><span class="line"></span><br><span class="line">4.登录到20.200.21.6 chredis用户，cd redis/6379/</span><br><span class="line">为使备库顺利加入集群移除源数据，mv dump.db dump.rdb.20190810（日期） mv appendonly_6379.aof appendonly_6379.aof.20190810</span><br><span class="line">启动 redis; cd bin; sh start.sh</span><br><span class="line">登录到root用户，cd /etc/keepalived/,sh start.sh</span><br><span class="line">检查redis的状态，sh test.sh 显示如下为正确状态，否启动不正常。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:20.200.21.100</span><br><span class="line">master_port</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">再不正常 的情况下，重新启动keepalived ;sh stop.sh ;sh start.sh</span><br><span class="line"></span><br><span class="line">5.最后在到主库上查询redis的状态</span><br><span class="line">登录到20.200.21.3 root用户，cd /etc/keepalived 执行 sh test.sh</span><br><span class="line">查看状态</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=20.200.21.4,port=6379,state=online,offset=88688496,lag=0</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 日常维护</title>
    <url>/knowledge-base/2019/10/20/linux7/</url>
    <content><![CDATA[<div class="note primary"><p>主要是linux 7.xx的常用设置</p>
</div>
<span id="more"></span>

<h2 id="Linux6-和Linux7-以及Ubuntu关闭防火墙iptables命令区别"><a href="#Linux6-和Linux7-以及Ubuntu关闭防火墙iptables命令区别" class="headerlink" title="Linux6.和Linux7  以及Ubuntu关闭防火墙iptables命令区别"></a>Linux6.和Linux7  以及Ubuntu关闭防火墙iptables命令区别</h2><ol>
<li>Linux7.x系统关闭防火墙iptables命令如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看防火墙的状态：firewall-cmd --state或者使用iptables -L</span><br><span class="line">关闭防火墙：systemctl stop firewalld.service，但是开机之后还会启动防火墙</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">查看防火墙配置：cat /etc/sysconfig/iptables-config</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Linux6.x系统关闭防火墙iptables命令如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看防火墙的状态：service iptables status 或者使用iptables -L</span><br><span class="line">关闭防火墙：service iptables stop ，但是开机之后还会启动防火墙</span><br><span class="line">chkconfig  iptables  off   #禁止firewall开机启动</span><br><span class="line">查看防火墙配置：cat /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>介绍如何使用在Ubuntu16.04中开启和关闭防火墙</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启防火墙  ：ufw enable</span><br><span class="line">关闭防火墙：  ufw disable</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ安装方法和日常使用</title>
    <url>/knowledge-base/2019/10/20/rabbitmq-install/</url>
    <content><![CDATA[<div class="note primary"><p>描述rabbitmq安装方法和日常使用</p>
</div>
<span id="more"></span>

<h2 id="红旗7-系统配置"><a href="#红旗7-系统配置" class="headerlink" title="红旗7 系统配置"></a>红旗7 系统配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核参数优化</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统参数需要留有swap空间，rabbitmq 启动进程用户打开文件数至少需要5万，yum安装时rabbitmq启动，源码安装时root启动。修改方法如下：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS5/6.X</span></span><br><span class="line">cat /etc/security/limits.conf</span><br><span class="line">* soft nofile 100000</span><br><span class="line">* hard nofile 100000</span><br><span class="line">* soft nproc 100000</span><br><span class="line">* hard nproc 100000</span><br><span class="line">* soft core 100000</span><br><span class="line">* hard core 100000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在CentOS 7 / RHEL 7的系统中，使用Systemd替代了之前的SysV，因此 /etc/security/limits.conf 文件的配置作用域缩小了一些。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">limits.conf这里的配置，只适用于通过PAM认证登录用户的资源限制，它对systemd的service的资源限制不生效。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录用户的限制，通过 /etc/security/limits.conf 和 limits.d 来配置。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS7.X</span></span><br><span class="line">cat /etc/security/limits.conf</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line"></span><br><span class="line">cat /etc/security/limits.d/20-nproc.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">*          soft    <span class="built_in">nproc</span>     4096</span></span><br><span class="line">* soft nproc unlimited</span><br><span class="line">* hard nproc unlimited</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemd service的资源限制配置：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要修改两个配置文件：</span></span><br><span class="line">- /etc/security/limits.d/20-nproc.conf</span><br><span class="line">- /etc/systemd/system.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局的配置，放在文件 /etc/systemd/system.conf 和 /etc/systemd/user.conf。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时，也会加载两个对应的目录中的所有.conf文件 /etc/systemd/system.conf.d/*.conf 和 /etc/systemd/user.conf.d/*.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中，system.conf 是系统实例使用的，user.conf用户实例使用的。一般的sevice，使用system.conf中的配置即可。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemd.conf.d/*.conf 中配置会覆盖system.conf。</span></span><br><span class="line"></span><br><span class="line">cat /etc/systemd/system.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DefaultLimitNOFILE= <span class="comment">#这里需要修改</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DefaultLimitNPROC=  <span class="comment">#这里也需要修改</span></span></span><br><span class="line"></span><br><span class="line">DefaultLimitCORE=infinity</span><br><span class="line">DefaultLimitNOFILE=655360</span><br><span class="line">DefaultLimitNPROC=655360</span><br><span class="line"></span><br><span class="line">sed -i &#x27;/^#DefaultLimitNOFILE=/aDefaultLimitNOFILE=655350&#x27; /etc/systemd/system.conf </span><br><span class="line">sed -i &#x27;/^#DefaultLimitNPROC=/aDefaultLimitNPROC=655350&#x27; /etc/systemd/system.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：修改了system.conf后，需要重启系统才会生效。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">针对单个Service，也可以设置，以nginx为例。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 /usr/lib/systemd/system/nginx.service 文件，或者 /usr/lib/systemd/system/nginx.service.d/my-limit.conf 文件，做如下配置：</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">LimitNOFILE=100000</span><br><span class="line">LimitNPROC=100000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看一个进程的<span class="built_in">limit</span>设置：<span class="built_in">cat</span> /proc/YOUR-PID/limits</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/security/limits.d/20-nproc.conf文件坑过，里面默认设置了非root用户的最大进程数为4096</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核优化</span></span><br><span class="line"></span><br><span class="line">vi /etc/sysctl.d/99.sysctl.conf(相当于linux6 中/etc/sysctl.conf)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭ipv6</span></span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">避免放大攻击</span></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启恶意icmp错误消息保护</span></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭路由转发</span></span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启反向路径过滤</span></span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">处理无源路由的包</span></span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭sysrq功能</span></span><br><span class="line">kernel.sysrq = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">core文件名中添加pid作为扩展名</span></span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启SYN洪水攻击保护</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改消息队列长度</span></span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置最大内存共享段大小bytes</span></span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">timewait的数量，默认180000</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 16384 4194304</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</span></span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">限制仅仅是为了防止简单的DoS 攻击</span></span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">未收到客户端确认信息的连接请求的最大值</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内核放弃建立连接之前发送SYNACK 包的数量</span></span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内核放弃建立连接之前发送SYN 包的数量</span></span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用timewait 快速回收</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line">net.ipv4.tcp_fin_timeout = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许系统打开的端口范围</span></span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改防火墙表大小，默认65536</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.netfilter.nf_conntrack_max=655350</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.netfilter.nf_conntrack_tcp_timeout_established=1200</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保无人能修改路由表</span></span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.all.secure_redirects = 0</span><br><span class="line">net.ipv4.conf.default.secure_redirects = 0</span><br><span class="line">vm.max_map_count=655360</span><br><span class="line"></span><br><span class="line">操作系统配置修改,然后用root执行sysctl -p让修改生效：</span><br></pre></td></tr></table></figure>

<h2 id="配置yum本地源"><a href="#配置yum本地源" class="headerlink" title="配置yum本地源"></a>配置yum本地源</h2><ol>
<li><p>确保光盘挂载点有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/cdrom /media/cdrom</span><br></pre></td></tr></table></figure>
</li>
<li><p>yum的一切配置信息都存储在&#x2F;etc&#x2F;yum.repos.d目录下的配置文件中。所以跳转到&#x2F;etc&#x2F;yum.repo.d目录下</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repo.d</span><br><span class="line">mv *repo tmp</span><br><span class="line">vi local.repo 填写</span><br><span class="line">[AX7]                  //yum的ID，本地唯一，用于区分不同yum源</span><br><span class="line">name=AX7-server                //描述信息</span><br><span class="line">baseurl=file:///media/cdrom                   //前面的file://是协议，后面的/mnt是光盘挂载点</span><br><span class="line">enabled=1                  //1启用yum源，0禁用yum源</span><br><span class="line">gpgcheck=0               //1使用公钥验证rpm包的正确性，0不验证</span><br></pre></td></tr></table></figure>

<h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  查看防火墙的状态：firewall-cmd --state或者使用iptables -L</span><br><span class="line">  关闭防火墙：systemctl stop firewalld.service，但是开机之后还会启动防火墙</span><br><span class="line"> systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">查看防火墙配置：cat /etc/sysconfig/iptables-config</span><br></pre></td></tr></table></figure>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">首先，在node1服务器上，修改vi /etc/hostname：</span><br><span class="line">node1</span><br><span class="line">在node2服务器上，修改vi /etc/hostname：</span><br><span class="line">node2</span><br><span class="line"></span><br><span class="line">然后在node1服务器上，修改vi /etc/hosts：</span><br><span class="line">192.168.1.50 node1</span><br><span class="line">192.168.1.51 node2</span><br><span class="line"></span><br><span class="line">在node2服务器上，修改vi /etc/hosts：</span><br><span class="line">192.168.1.50 node1</span><br><span class="line">192.168.1.51 node2</span><br><span class="line"></span><br><span class="line">然后查看下hostnamectl status，如果不正确的话，需要再进行设置下：</span><br><span class="line">[root@node1 ~]# hostnamectl status</span><br><span class="line">   Static hostname: node1</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: 241163503ce842c489360d0a48a606fc</span><br><span class="line">           Boot ID: cdb59c025cb447e3afed7317af78979e</span><br><span class="line">    Virtualization: oracle</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-229.el7.x86_64</span><br><span class="line">      Architecture: x86_64</span><br><span class="line">[root@node1 ~]# hostnamectl --static set-hostname node1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 安装依赖库</span><br><span class="line">yum install gcc glibc-devel make ncurses-devel openssl-devel autoconf -y</span><br><span class="line">yum install unixODBC unixODBC-devel -y</span><br><span class="line">yum -y install wxWidgets --- 是否需要</span><br><span class="line"></span><br><span class="line">wxWidgets如果yum安装不成功，就用源码安装，需要先安装gk2：</span><br><span class="line"></span><br><span class="line">yum -y install gtk2-devel binutils-devel gk2</span><br><span class="line">(1).tar -zxvf wxWidgets-2.8.12.tar.gz</span><br><span class="line">(2).cd wxWidgets-2.8.12</span><br><span class="line">(3). ./configure  (遇到权限不够时使用【chmod +x configure】，然后再执行此命令)</span><br><span class="line">(4).make (编译过程遇到某些文件权限不够时，找到提示的文件，使用【chmod + x 提示文件】 来提升权限之后再回到当前目录make)</span><br><span class="line">(5).sudo make install (需要root权限执行)</span><br><span class="line">(6).ldconfig</span><br><span class="line"></span><br><span class="line">2. 安装 erlang</span><br><span class="line">tar -xvf OTP-22.0.7.tar.gz </span><br><span class="line">cd otp-OTP-22.0.7</span><br><span class="line">./otp_build autoconf</span><br><span class="line">./configure </span><br><span class="line">make --jobs=5</span><br><span class="line">make install(需要root权限)</span><br><span class="line">ln -s /usr/local/erlang/bin/erl /usr/local/bin/</span><br><span class="line"></span><br><span class="line">3. 安装RabbitMQ</span><br><span class="line">tar -xvf rabbitmq-server-generic-unix-3.6.3.tar</span><br><span class="line">cd ./rabbitmq_server-3.6.3/sbin/</span><br><span class="line">1. 服务启动</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用web管理界面</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line">2. 服务停止</span><br><span class="line">rabbitmqctl stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加用户</span></span><br><span class="line">   rabbitmqctl add_user admin admin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置权限</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给新建的用户配置权限、读权限和写权限</span></span><br><span class="line">rabbitmqctl set_permissions admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  </span><br><span class="line">浏览器访问</span><br><span class="line">ip:15672</span><br><span class="line"></span><br><span class="line">==================================命令行--创建用户与权限=========================</span><br><span class="line">登录Web界面后在admin菜单里可以创建新的管理账户，与使用命令行效果是一样的。主要需要注意的地方就是tags有以下几种：</span><br><span class="line">administrator：超级管理员，什么权限都有</span><br><span class="line">monitoring：可以登录控制台和查看节点信息，比如内存、进程数、磁盘使用等</span><br><span class="line">policymaker：可以登录控制台和制定策略，但是无法查看节点信息</span><br><span class="line">management：仅能登录控制台</span><br><span class="line">其他：无法登录控制台，一般是提供者和消费者</span><br><span class="line">1 	rabbitmqctl add_user admin RABBIT_PASSWORD  #创建一个用户，密码请自定义</span><br><span class="line">2 	rabbitmqctl set_permissions admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  #给新建的用户配置权限、读权限和写权限</span><br><span class="line">3 	rabbitmqctl set_user_tags admin administrator  #用户分组</span><br><span class="line">===============================================================================</span><br><span class="line">默认路径LOG路径是：</span><br><span class="line">RABBITMQ_LOG_BAS=$HOME/rabbitmq/var/log/rabbitmq</span><br><span class="line">mnesia数据库，默认路径是：</span><br><span class="line">RABBITMQ_MNESIA_BASE=$HOME/rabbitmq/var/lib/rabbitmq/mnesia</span><br><span class="line">插件的路径</span><br><span class="line">RABBITMQ_PLUGINS_DIR=$HOME/rabbitmq/plugins </span><br><span class="line"></span><br><span class="line">RABBITMQ_MNESIA_BASE=/data/rabbitmq/mnesia</span><br><span class="line">RABBITMQ_LOG_BASE=/data/rabbitmq/log</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ的常用命令"><a href="#RabbitMQ的常用命令" class="headerlink" title="RabbitMQ的常用命令"></a>RabbitMQ的常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-server // 同时启动erlang节点和应用程序</span><br><span class="line">rabbitmqctl是管理虚拟主机和用户权限的工具</span><br><span class="line">rabbitmq-plugins 是管理插件的工具</span><br><span class="line">查看状态：rabbitmqctl status</span><br><span class="line">关闭服务：rabbitmqctl stop</span><br><span class="line">列出角色：rabbitmqctl list_users</span><br><span class="line">开启某个插件：rabbitmq-pluginsenable xxx</span><br><span class="line">关闭某个插件：rabbitmq-pluginsdisablexxx</span><br><span class="line">注意：重启服务器后生效。</span><br><span class="line"></span><br><span class="line">1. rabrabbitmqctl 管理</span><br><span class="line">// 查看rabrabbitmqctl所支持的命令</span><br><span class="line">rabrabbitmqctl</span><br><span class="line"></span><br><span class="line">// 查看状态</span><br><span class="line">rabbitmqctl status</span><br><span class="line"></span><br><span class="line">//停止erlang node，同时关闭erlang节点和应用程序</span><br><span class="line">rabbitmqctl stop  </span><br><span class="line"></span><br><span class="line">// 停止RabbitMQ服务，仅关闭erlang节点上的rabbit应用程序</span><br><span class="line">rabbitmqctl stop_app </span><br><span class="line"></span><br><span class="line">// 启动RabbitMQ服务</span><br><span class="line">rabbitmqctl start_app </span><br><span class="line"></span><br><span class="line">// 格式化rabbitmq node(在集群中需要满足一定的条件才能关闭)</span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line">// 强制格式化rabbitmq node</span><br><span class="line">rabbitmqctl force_reset</span><br><span class="line"></span><br><span class="line">// 清除某个队列的所有消息</span><br><span class="line">rabbitmqctl purge_queue &lt;name&gt;</span><br><span class="line"></span><br><span class="line">// 添加用户</span><br><span class="line">rabbitmqctl add_user &lt;username&gt; &lt;password&gt;</span><br><span class="line"></span><br><span class="line">// 设置权限</span><br><span class="line">rabbitmqctl set_permissions -p / &lt;username&gt; &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"></span><br><span class="line">// 列举权限</span><br><span class="line">rabbitmqctl list_permissions -p &lt;vhost&gt;</span><br><span class="line"></span><br><span class="line">// 列举用户的所有权限</span><br><span class="line">rabbitmqctl list_user_permissions &lt;username&gt;</span><br><span class="line"></span><br><span class="line">// 清除权限</span><br><span class="line">rabbitmqctl clear_permissions -p &lt;vhost&gt; &lt;username&gt;</span><br><span class="line"></span><br><span class="line">// 认证用户</span><br><span class="line">rabbitmqctl authenticate_user &lt;username&gt; &lt;password&gt;</span><br><span class="line"></span><br><span class="line">// 修改密码</span><br><span class="line">rabbitmqctl change_password &lt;username&gt; &lt;password&gt;</span><br><span class="line"></span><br><span class="line">// 列举用户</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"></span><br><span class="line">// 删除用户（删除用户时也会把用户相关的权限都删除）</span><br><span class="line">rabbitmqctl delete_user &lt;username&gt;</span><br><span class="line"></span><br><span class="line">// 设置tag, tag可以为none最小权限角色，management 管理员角色，policymaker决策者，monitoring 监控，administrator  超级管理员 </span><br><span class="line">rabbitmqctl set_user_tags &lt;username&gt; &lt;tag&gt;</span><br><span class="line"></span><br><span class="line">// 添加虚拟主机</span><br><span class="line">rabbitmqctl add_vhost &lt;name&gt; </span><br><span class="line"></span><br><span class="line">// 删除虚拟主机</span><br><span class="line">rabbitmqctl delete_vhost &lt;name&gt; </span><br><span class="line"></span><br><span class="line">// 查看所有虚拟主机</span><br><span class="line">rabbitmqctl list_vhost [&lt;vhostinfoitem&gt; ...]</span><br><span class="line"></span><br><span class="line">// 列举默认虚拟机上的所有队列</span><br><span class="line">rabbitmqctl list_queues</span><br><span class="line"></span><br><span class="line">// 列出指定虚拟机上的队列</span><br><span class="line">rabbitmqctl list_queues -p &lt;vhost&gt;</span><br><span class="line"></span><br><span class="line">// 列举队列，包含队列名称、消息数目、消费者数目、内存使用情况、是否持久化、是否自动删除</span><br><span class="line">rabbitmqctl list_queues name messages counsumers memory durable auto_delete</span><br><span class="line"></span><br><span class="line">// 查看交换机</span><br><span class="line">rabbitmqctl list_exchanges [name] [type] [durable] [auto_delete]</span><br><span class="line"></span><br><span class="line">// 列举所有绑定</span><br><span class="line">rabbitmqctl list_bindings [-p &lt;vhost&gt;]</span><br><span class="line">===================================================</span><br><span class="line">2. rabbitmqadmin 管理</span><br><span class="line">rabbitmqadmin 目录在./rabbitmq/var/lib/rabbitmq/mnesia/rabbit@one-plugins-expand/rabbitmq_management-3.7.16/priv/www/cli/rabbitmqadmin</span><br><span class="line">chmod u+x rabbitmqadmin</span><br><span class="line">// 列出服务器上的队列</span><br><span class="line">rabbitmqadmin list queues</span><br><span class="line"></span><br><span class="line">// 清空队列上的消息</span><br><span class="line">rabbitmqadmin purge queue name=&lt;queue_name&gt;</span><br><span class="line"></span><br><span class="line">rabbitmqadmin -u &lt;username&gt; -p &lt;password&gt; declare exchange name=&lt;exchange_name&gt; type=&lt;type&gt;</span><br><span class="line"></span><br><span class="line">// 列举所有连接</span><br><span class="line">rabbitmqadmin list connections name</span><br><span class="line"></span><br><span class="line">// 关闭某个连接</span><br><span class="line">rabbitmqadmin close connection name=&lt;name&gt;</span><br><span class="line">3. command line  tool</span><br><span class="line">通过curl命令行来访问RabbitMQ Management 中的HTTP API（http://localhost:15672/api/), 返回的格式是json格式</span><br><span class="line">curl -i -u admin:admin http://localhost:15672/api/vhosts</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-Server-高可用集群"><a href="#RabbitMQ-Server-高可用集群" class="headerlink" title="RabbitMQ Server 高可用集群"></a>RabbitMQ Server 高可用集群</h2><h3 id="Erlang-Cookie"><a href="#Erlang-Cookie" class="headerlink" title="Erlang Cookie"></a>Erlang Cookie</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Erlang Cookie 是保证不同节点可以相互通信的密钥，要保证集群中的不同节点相互通信必须共享相同的 Erlang Cookie。具体的目录存放在 $HOME/.erlang.cookie</span><br></pre></td></tr></table></figure>

<h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>RabbitMQ 的 Cluster 集群模式一般分为两种，普通模式和镜像模式。</p>
<ul>
<li><strong>普通模式</strong>：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于  Queue 来说，消息实体只存在于其中一个节点 rabbit01（或者 rabbit02），rabbit01 和 rabbit02  两个节点仅有相同的元数据，即队列的结构。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02  节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给  consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论  consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01  节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01  节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</li>
<li><strong>镜像模式</strong>：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现 RabbitMQ 的 HA  高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在 consumer  消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</li>
</ul>
<h2 id="搭建-RabbitMQ-Server-高可用集群-普通模式"><a href="#搭建-RabbitMQ-Server-高可用集群-普通模式" class="headerlink" title="搭建 RabbitMQ Server 高可用集群(普通模式)"></a>搭建 RabbitMQ Server 高可用集群(普通模式)</h2><p>默认<code>.erlang.cookie</code>文件是隐藏的，<code>ls -lart</code>命令并查看，你也可以手动搜索下文件路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# find / -name &quot;.erlang.cookie&quot;</span><br><span class="line">/app/snow/.erlang.cookie</span><br><span class="line">[root@node1 ~]# cat /app/snow/.erlang.cookie</span><br><span class="line">LBOTELUJAMXDMIXNTZMB</span><br></pre></td></tr></table></figure>

<p>将<code>node1</code>服务器中的<code>.erlang.cookie</code>文件，拷贝到<code>node2</code>服务器上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# scp /app/snow/.erlang.cookie root@node2:.</span><br></pre></td></tr></table></figure>

<p>先停止运行节点，然后以后台方式启动 RabbitMQ Server（<code>node1</code>和<code>node2</code>分别执行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl stop</span><br><span class="line">[root@node1 ~]# rabbitmq-server -detached</span><br><span class="line">[root@node1 ~]# netstat -nap|grep 5672</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务监听在5672端口，而Web端是15672。直接运行rabbitmq-server命令可以让服务在前台启动，并且能看到日志信息等提示，当然更多情况我们都是后台启动的</span></span><br></pre></td></tr></table></figure>

<p>然后我们以<code>node1</code>作为集群中心，在<code>node2</code>上执行加入集群中心命令（节点类型为磁盘节点）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl stop_app</span><br><span class="line">[root@node1 ~]# rabbitmqctl reset </span><br><span class="line">[root@node1 ~]# rabbitmqctl join_cluster --ram rabbit@node1 ####这里集群的名字一定不要写错了</span><br><span class="line">//默认是磁盘节点，如果是内存节点的话，需要加--ram参数</span><br><span class="line">[root@node1 ~]# rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>查看集群的状态（包含<code>node1</code>和<code>node2</code>节点）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@node1</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@node1&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>添加用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加虚拟主机</span></span><br><span class="line">rabbitmqctl add_vhost test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加用户</span></span><br><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置权限</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给新建的用户配置权限、读权限和写权限</span></span><br><span class="line">rabbitmqctl set_permissions -p qywy admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="RabiitMQ创建队列"><a href="#RabiitMQ创建队列" class="headerlink" title="RabiitMQ创建队列"></a>RabiitMQ创建队列</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux环境，下载后直接将路径添加到path变量中</span><br><span class="line">windows环境，通过python来运行。</span><br><span class="line">这里是使用了Windows环境</span><br><span class="line">执行命令</span><br><span class="line">执行rabbitmqadmin list queues指令，可以查看所创建的队列信息。</span><br><span class="line">查看命令帮助信息：</span><br><span class="line">python rabbitmqadmin help subcommands</span><br><span class="line">添加队列</span><br><span class="line"></span><br><span class="line">declare queue name=... [auto_delete=... durable=... arguments=... node=...]</span><br><span class="line"></span><br><span class="line">创建指定vhost的队列(默认是/)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--vhost=javashop 指定vhost，vhost去做第一层的区分，虚拟主机，工作组等，把用户添加到对应的VHost组里，注意连接时也要使用VHost参数，如果没有特别设置，可以不指定它，默认就是/</span></span><br><span class="line">python rabbitmqadmin declare queue name=hello auto_delete=false durable=true --vhost=/ --node=rabbit@node2 --username=admin --password=admin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="设置镜像队列策略"><a href="#设置镜像队列策略" class="headerlink" title="设置镜像队列策略"></a>设置镜像队列策略</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy -p qywy  ha-all &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">&quot;coresystem&quot; vhost名称， &quot;^&quot;匹配所有的队列， ha-all 策略名称为ha-all, &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27; 策略模式为 all 即复制到所有节点，包含新增节点。</span><br><span class="line">则此时镜像队列设置成功。（这里的虚拟主机coresystem是代码中需要用到的虚拟主机，虚拟主机的作用是做一个消息的隔离，本质上可认为是一个rabbitmq-server，是否增加虚拟主机，增加几个，这是由开发中的业务决定，即有哪几类服务，哪些服务用哪一个虚拟主机，这是一个规划）。</span><br><span class="line"></span><br><span class="line">rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</span><br><span class="line"> </span><br><span class="line">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span><br><span class="line">Name: policy的名称</span><br><span class="line">Pattern: queue的匹配模式(正则表达式)</span><br><span class="line">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span><br><span class="line">    ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span><br><span class="line">        all：表示在集群中所有的节点上进行镜像</span><br><span class="line">        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="line">        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br><span class="line">    ha-params：ha-mode模式需要用到的参数</span><br><span class="line">    ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span><br><span class="line">priority：可选参数，policy的优先级</span><br><span class="line">将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一直。完成这 6 个步骤后，RabbitMQ 高可用集群就已经搭建好了，最后一个步骤就是搭建均衡器。</span><br><span class="line">1.以下示例声明名为ha-all的策略，它与名称以&quot;ha&quot;开头的队列相匹配，并将镜像配置到集群中的所有节点.</span><br><span class="line">rabbitmqctl set_policy ha-all &quot;^ha.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br><span class="line">2.策略的名称以&quot;two&quot;开始的队列镜像到群集中的任意两个节点，并进行自动同步：</span><br><span class="line">rabbitmqctl set_policy ha-two &quot;^two.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br><span class="line">3.以&quot;node&quot;开头的队列镜像到集群中的特定节点的策略：</span><br><span class="line">rabbitmqctl set_policy ha-nodes &quot;^nodes.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;],&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>##RabbitMQ 集群问题急解决</p>
<p><strong>问题一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl join_cluster --ram rabbit@node1</span><br><span class="line">Clustering node rrabbit@rabbitmq-node1 with rabbit@rabbitmq-node1...</span><br><span class="line">Error: unable to connect to nodes rabbit@rabbitmq-node1]: nodedown</span><br><span class="line"></span><br><span class="line">DIAGNOSTICS</span><br><span class="line">===========</span><br><span class="line">attempted to contact: [rabbit@node1]</span><br><span class="line">rabbit@rabbitmq-node1:</span><br><span class="line">  * unable to connect to epmd (port 4369) on rabbitmq-node1: nxdomain (non-existing domain)</span><br><span class="line">current node details:</span><br><span class="line">- node name: &#x27;rabbitmqctl-526rabbitmq-node1&#x27;</span><br><span class="line">- home dir: /var/lib/rabbitmq</span><br><span class="line">- cookie hash: 50YO3zK+HJHos0tab1vHjg==</span><br></pre></td></tr></table></figure>

<p>解决之道：<br>集群节点间需能互相访问，故每个集群节点的hosts文件应包含集群内所有节点的信息以保证互相解析</p>
<pre><code>vim /etc/hosts
1 IP    rabbit@node1
2 IP    rabbit@node2
</code></pre>
<p>之后重启各节点中的rabbitmq<br><strong>问题二：</strong></p>
<p>cluster搭建起来后若在web管理工具中rabbitmq_management的Overview的Nodes部</p>
<pre><code>“Node statistics not available”
</code></pre>
<p>说明在该节点上web管理插件还未启用。</p>
<p>直接在显示提示信息的节点上运行</p>
<pre><code>rabbitmq-plugins enable rabbitmq_management
有可能启动不成功，报Error: mnesia_unexpectedly_running
rabbitmq-plugins enable rabbitmq_management
原因：忘记先停止stop_app
解决：rabbitmqctl stop_app
</code></pre>
<p><strong>问题三：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[rabbit@rabbitmq-node2 ~]$ rabbitmqctl start_app</span><br><span class="line">Starting node rabbit@rabbitmq-node2 ...</span><br><span class="line">BOOT FAILED</span><br><span class="line">===========</span><br><span class="line">Error description:</span><br><span class="line">   &#123;error,&#123;inconsistent_cluster,&quot;Node rabbit@rabbitmq-node1  thinks it&#x27;s clustered with node rabbit@rabbitmq-node1, but rabbit@rabbitmq-node2 disagrees&quot;&#125;&#125;</span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@VMS00782.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@VMS00782-sasl.log</span><br><span class="line">Stack trace:</span><br><span class="line">   [&#123;rabbit_mnesia,check_cluster_consistency,0&#125;,</span><br><span class="line">    &#123;rabbit,&#x27;-start/0-fun-0-&#x27;,0&#125;,</span><br><span class="line">    &#123;rabbit,start_it,1&#125;,</span><br><span class="line">    &#123;rpc,&#x27;-handle_call_call/6-fun-0-&#x27;,5&#125;]</span><br><span class="line">Error: &#123;rabbit,failure_during_boot,</span><br><span class="line">           &#123;error,</span><br><span class="line">               &#123;inconsistent_cluster,</span><br><span class="line">                   &quot;Node rabbit@rabbitmq-node2 thinks it&#x27;s clustered with node rabbit@rabbitmq-node1, but rabbit@rabbitmq-node2 disagrees&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>需要重置一下配置</p>
<p>执行 rabbitmqctl reset，重启 rabbitmqctl start_app</p>
<p><strong>问题四：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RabbitMQ GUI上显示</span><br><span class="line"></span><br><span class="line">Network partition detected</span><br><span class="line">Mnesia reports that this RabbitMQ  cluster has experienced a network partition. There is a risk of losing  data. Please read RabbitMQ documentation about network partitions and  the possible solutions.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因分析：</span><br><span class="line">这是由于网络问题导致集群出现了脑裂临时解决办法：</span><br><span class="line">在 相对不怎么信任的分区里，对那个分区的节点实行 </span><br><span class="line">   在出现问题的节点上执行:  sbin/rabbitmqctl stop_app </span><br><span class="line">   在出现问题的节点上执行:  sbin/rabbitmqctl start_app </span><br><span class="line">注意：mq集群不能采用kill -9 杀死进程，否则生产者和消费者不能及时识别mq的断连，会影响生产者和消费者正常的业务处理。 </span><br></pre></td></tr></table></figure>

<h1 id="rabbitmq集群节点操作"><a href="#rabbitmq集群节点操作" class="headerlink" title="rabbitmq集群节点操作"></a><a href="https://www.cnblogs.com/nulige/p/8874893.html">rabbitmq集群节点操作</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节点恢复过程中把数据删掉很重要，恢复一单结点，再清数据</span><br><span class="line"></span><br><span class="line">节点增加：</span><br><span class="line">\1. rabbitmq-server -detached  --- .erlang.cooike的权限，400 属主rabbitmq</span><br><span class="line">\2. rabbitmqctl stop_app</span><br><span class="line">\3. rabbitmqctl join_cluster --ram rabbit@rabbitmq1</span><br><span class="line">\4. rabbitmqctl start_app</span><br><span class="line">\5. rabbitmqctl  cluster_status</span><br><span class="line"></span><br><span class="line">节点删除</span><br><span class="line">\1.  rabbitmq-server -detached</span><br><span class="line">以上为基础，正常运行的mq节点直接进行2、3两步；4可省略或更改为rabbitmqctl stop</span><br><span class="line">\2. rabbitmqctl stop_app</span><br><span class="line">\3. rabbitmqctl reset </span><br><span class="line">\4. rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line">硬删除：</span><br><span class="line">直接删掉集群中的某个节点：</span><br><span class="line">rabbitmqctl forget_cluster_node  node_name </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##修改磁盘节点为内存节点</p>
<p>注：从中我们可以看出这些几点都是disc（磁盘节点），我们可以手动把集群节点模式调成内存节点的，当然三台磁盘节点是最安全的，但是比较浪费资源，正常我们调整为两台磁盘一台内存即可*</p>
<hr>
<p>下面将介绍下如何设置集群的节点模式：<br>ram：内存<br>disc：磁盘<br>默认节点加入集群都是disc节点，设置ram节点两种方式：<br>方法一：<br>加入集群时设置type：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster --ram rabbit@node1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>方法二：<br>加入集群后，修改disc节点为ram节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl change_cluster_node_type ram</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>##镜像队列的恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提：两个节点A和B组成以镜像队列。</span><br><span class="line"></span><br><span class="line">场景1：A先停，B后停</span><br><span class="line">该场景下B是master，只要先启动B，再启动A即可。或者先启动A，再在30s之内启动B即可恢复镜像队列。（如果没有在30s内回复B，那么A自己就停掉自己）</span><br><span class="line"></span><br><span class="line">场景2：A，B同时停</span><br><span class="line">该场景下可能是由掉电等原因造成，只需在30s内联系启动A和B即可恢复镜像队列。</span><br><span class="line"></span><br><span class="line">场景3：A先停，B后停，且A无法恢复。</span><br><span class="line">因为B是master，所以等B起来后，在B节点上调用rabbitmqctl forget_cluster_node A以接触A的cluster关系，再将新的slave节点加入B即可重新恢复镜像队列。</span><br><span class="line"></span><br><span class="line">场景4：A先停，B后停，且B无法恢复</span><br><span class="line">该场景比较难处理，旧版本的RabbitMQ没有有效的解决办法，在现在的版本中，因为B是master，所以直接启动A是不行的，当A无法启动时，也就没版本在A节点上调用rabbitmqctl forget_cluster_node B了，新版本中forget_cluster_node支持-offline参数，offline参数允许rabbitmqctl在离线节点上执行forget_cluster_node命令，迫使RabbitMQ在未启动的slave节点中选择一个作为master。当在A节点执行rabbitmqctl forget_cluster_node -offline B时，RabbitMQ会mock一个节点代表A，执行forget_cluster_node命令将B提出cluster，然后A就能正常启动了。最后将新的slave节点加入A即可重新恢复镜像队列</span><br><span class="line"></span><br><span class="line">场景5：A先停，B后停，且A和B均无法恢复，但是能得到A或B的磁盘文件</span><br><span class="line">这个场景更加难以处理。将A或B的数据库文件（$RabbitMQ_HOME/var/lib目录中）copy至新节点C的目录下，再将C的hostname改成A或者B的hostname。如果copy过来的是A节点磁盘文件，按场景4处理，如果拷贝过来的是B节点的磁盘文件，按场景3处理。最后将新的slave节点加入C即可重新恢复镜像队列。</span><br><span class="line"></span><br><span class="line">场景6：A先停，B后停，且A和B均无法恢复，且无法得到A和B的磁盘文件</span><br><span class="line">无解。</span><br><span class="line">当镜像队列不能同步消息时，需要使用sync_queue</span><br><span class="line">rabbitmqctl sync_queue hello</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">于是发现AMQP的管道同样有一个closed。于是参考源码封装出来判断连接的函数。 </span><br></pre></td></tr></table></figure>
<p>connect.go<br>func (c *Connection) IsClosed() bool { return (atomic.LoadInt32(&amp;c.closed) &#x3D;&#x3D; 1) }<br>channel.go<br>func (c *Channel) IsClosed() bool { return (atomic.LoadInt32(&amp;c.closed) &#x3D;&#x3D; 1) } </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if conn.IsClosed() || ch.IsClosed() &#123; </span><br><span class="line">log.Println(&quot;连接断开，重新连接&quot;) </span><br><span class="line">err = InitRabbitmq(Url) log.Println(err) </span><br><span class="line">&#125; ``` **修改后稳定性增强，自己的问题没有仔细看源码。**</span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-加入集群失败问题"><a href="#1-加入集群失败问题" class="headerlink" title="1. 加入集群失败问题"></a>1. 加入集群失败问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@rabbitmq-102 rabbitmq]# rabbitmqctl join_cluster rabbit@rabbitmq-101 --ram</span><br><span class="line">Clustering node &#x27;rabbit@rabbitmq-102&#x27; with &#x27;rabbit@rabbitmq-101&#x27;</span><br><span class="line">Error: &#123;inconsistent_cluster,&quot;Node &#x27;rabbit@rabbitmq-101&#x27; thinks it&#x27;s clustered with node &#x27;rabbit@rabbitmq-102&#x27;, but &#x27;rabbit@rabbitmq-102&#x27; disagrees&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修复步骤执行："><a href="#修复步骤执行：" class="headerlink" title="修复步骤执行："></a>修复步骤执行：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rabbitmq-102 停 app</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"># rabbitmq-102 重置</span><br><span class="line">rabbitmqctl reset</span><br><span class="line"># 在 rabbitmq-101 上将异常节点剔除</span><br><span class="line">rabbitmqctl forget_cluster_node rabbitmq-102(主机名称)</span><br><span class="line"># rabbitmq-102 上重新加入集群</span><br><span class="line">rabbitmqctl join_cluster rabbit@rabbitmq-101 --ram/disc</span><br><span class="line"># 启动 app</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<h3 id="2-数据损坏问题"><a href="#2-数据损坏问题" class="headerlink" title="2. 数据损坏问题"></a>2. 数据损坏问题</h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页面上显示 Virtual host / experienced an error on node rabbit@&lt;hostname&gt; and may be inaccessible</span><br></pre></td></tr></table></figure>

<p>查看RabbitMQ的日志，里面有很多类似如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/rabbitmq/mnesia/rabbit@&lt;hostname&gt;/msg_stores/vhosts/9Q355W65BH1CKHLV81SV8HAB4/recovery.dets</span><br></pre></td></tr></table></figure>

<p>修复方式：</p>
<ol>
<li>停止RabbitMQ集群</li>
<li>删除错误的<code>vhosts/9Q355W65BH1CKHLV81SV8HAB4</code>文件</li>
<li>启动RabbitMQ集群</li>
</ol>
<h3 id="3-强制删除-NaN-队列"><a href="#3-强制删除-NaN-队列" class="headerlink" title="3. 强制删除 NaN 队列"></a>3. 强制删除 NaN 队列</h3><p>集群由于故障，出现大量 NaN 的队列，在 management 界面无法正常删除，可以采用如下方法删除</p>
<p>方法一</p>
<p>有些情况下导致队列无法删除，可使用如下命令强制删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl eval &#x27;rabbit_amqqueue:internal_delete(&#123;resource,&lt;&lt;&quot;/&quot;&gt;&gt;,queue,&lt;&lt;&quot;cinder.info&quot;&gt;&gt;&#125;).&#x27;</span><br></pre></td></tr></table></figure>

<p> 方法二</p>
<p>有些情况下导致队列无法删除，可使用如下命令强制删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl eval &quot;Q = rabbit_misc:r(&lt;&lt;\&quot;$vhost\&quot;&gt;&gt;, queue, &lt;&lt;\&quot;$queue\&quot;&gt;&gt;), rabbit_amqqueue:internal_delete(Q, &lt;&lt;\&quot;cli\&quot;&gt;&gt;).&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_queues -p xie-queue-name | awk -F &quot; &quot; &#x27;&#123;print $1&#125;&#x27; |grep -v &quot;Timeout&quot; | grep -v &quot;Listing&quot; | grep -Ev &quot;^$&quot; | xargs -p -I abcdef rabbitmqctl eval &quot;Q = rabbit_misc:r(&lt;&lt;\&quot;xie-queue-name\&quot;&gt;&gt;, queue, &lt;&lt;\&quot;abcdef\&quot;&gt;&gt;), rabbit_amqqueue:internal_delete(Q, &lt;&lt;\&quot;cli\&quot;&gt;&gt;).&quot;</span><br></pre></td></tr></table></figure>

<p>方法三</p>
<p>大量出现 <code>NaN</code> 的 queue 可以通过停止集群所有节点来清理掉。</p>
<h3 id="4-脑裂问题"><a href="#4-脑裂问题" class="headerlink" title="4. 脑裂问题"></a>4. 脑裂问题</h3><p>现象是在 RabbitMQ GUI上显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network partition detected</span><br><span class="line">Mnesia reports that this RabbitMQ cluster has experienced a network partition. There is a risk of losing data. Please read RabbitMQ documentation about network partitions and the possible solutions.</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>这是由于网络问题导致集群出现了脑裂</p>
<p>解决办法：</p>
<p>在相对不怎么信任的分区里，对那个分区的节点实行，在出现问题的节点上执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>一些情况下可以直接重启RabbitMQ服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.8版本 使用配置文件为 redis.conf</span><br><span class="line">cluster_partition_handling=autoheal</span><br><span class="line">net_ticktime=120</span><br><span class="line">channel_amx=2047</span><br><span class="line">shiyong</span><br><span class="line">设置配置文件</span><br><span class="line">CONFIG_FILE=/etc/rabbitmq/rabbitmq.conf</span><br><span class="line">使用rabbitmqctl status | grep net_ticktime查看是否生效。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>brilliance</tag>
      </tags>
  </entry>
  <entry>
    <title>elk安转说明</title>
    <url>/knowledge-base/2019/09/24/elk-install/</url>
    <content><![CDATA[<div class="note primary"></div>
<span id="more"></span>]]></content>
      <categories>
        <category>elsearch</category>
      </categories>
      <tags>
        <tag>elsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>网银数据库恢复步骤</title>
    <url>/knowledge-base/2019/09/11/netpostgresdb/</url>
    <content><![CDATA[<div class="note primary"><p>网银数据库恢复步骤</p>
</div>
<span id="more"></span>


<p>一、问题描述</p>
<pre><code>数据库宕机重启后一直处于recovrying状态，psql连接数据库报starting up信息，且无法登陆
</code></pre>
<p>二、修复步骤</p>
<p>1、停止数据库</p>
<pre><code>pg_ctl -D /data/postgres/data stop -m immediate
</code></pre>
<p>2、修复PostgreSql控制文件</p>
<pre><code>pg_resetxlog -D /data/postgres/data -f
#pg_resetxlog 修复后数据库只是可以登陆，但sql操作还是有报错，需采取将数据然后在导入新库的方式修复。
</code></pre>
<p>3、启动数据库</p>
<pre><code>pg_ctl -D /data/postgres/data start
</code></pre>
<p>4、备份</p>
<pre><code>1) 备份表结构
  pg_dump -h 数据库ip -U chldb -d chldb -s  &gt;  tbl_st.sql
2) 备份数据
  pg_dump -h 数据库ip -U chldb -d chldb -a  &gt;  tbl_data.sql
3) 备份数据库配置文件
  cp /data/postgres/data/postgresql.conf  /data/postgres/postgresql.conf.bak
  cp /data/postgres/data/pg_hba.conf      /data/postgres/pg_hba.conf.bak
  cp /data/postgres/data/pg_ident.conf    /data/postgres/pg_ident.conf.bak、
4）备份数据可目录
  cp -r /data/postgres/data  /data/postgres/data.bak
  cp -r /data/postgres/chltdb  /data/postgres/chltdb.bak
  cp -r /data/postgres/chltmgt  /data/postgres/chltmgr.bak
</code></pre>
<p>5、新建数据库</p>
<pre><code>1) 停止旧库
   pg_ctl -D /data/postgres/data stop
2) 删除旧库数据目录
   rm -rf /data/postgres/data
3) 重新初始初始化数据库
   initdb -D /data/postgres/data -E UTF8
4) 设置数据库配置文件postgresql.conf
   cp /data/postgres/postgresql.conf.bak  /data/postgres/data
5）设置pg_hba.conf
  sed  &#39;s/md5/trust/g&#39;   /data/postgres/pg_hba.conf.bak   /data/postgres/data/pg_hba.conf
6）启动数据库
  pg_ctl -D /data/postgres/data start
7） 创建数据库用户
  crateuser chldb
8) 创建数据库
  createdb chldb chldb
</code></pre>
<p>6、导入数据</p>
<pre><code>1) 加载分区库插件pg_pathman
 psql -U postgres -d chldb -c &quot; create extension pg_pathman&quot;
2) 创建表
 psql -U chldb -d chldb -f  tbl_st.sql
3) 创建表分区
 已chldb用户登陆chldb数据库
 select create_range_partitions(&#39;表名&#39;::regclass,&#39;分区字段&#39;，&#39;开始时间&#39;,分区间隔，分区数量)；
4）导入数据
  psql  -U chldb -d chldb -f  tbl_data.sql
</code></pre>
<p>7、重建备库</p>
<pre><code>1) 停止备库
    pg_ctl -D /data/postgres/data stop
2) 删除旧库数据目录
   rm -rf /data/postgres/data
3）通过流复制方式重建备库
    pg_basebackup -h 主库ip -U postgres -D /data/postgres/data/ -X stream -P
</code></pre>
<p>8、重建高可用集群</p>
<pre><code>1)  修改流复制方式
    修改congfig.in和config.pcs文件中rep_mode的值有sync改为async
2）重新配置集群
    cd /data/postgres/conf
    sh setup.sh
3) 查看集群状态
   cd /data/postgres/bin
   ./cls_status
</code></pre>
<p>三、另一种修复方式</p>
<p>1、问题表述</p>
<pre><code>主备库流复制差额比较大，数据库还有正常运行，为了防止数据库出问题，采取了两种措施：1、重建数据库备库；2、修改同步流复制为异步流复制。
</code></pre>
<p>2、修复步骤</p>
<p>1、重建备库</p>
<pre><code>1) 停止备库
   pg_ctl  -D /data/postgres/data stop
   #由于高可用软件migration-threshold的配置为3，所以数据可要停3次才能 不备pacemaker再次拉起
2）重建备库
   pg_basebackup -h 主库ip -U postgres -D /data/postgres/data/ -X stream -P
3）拉起备库
   #清楚数据库failcount计数，是pacemaker拉起数据库
   #在root用户下执行
   cd /data/postgres/bin
   ./cls_cleanup
</code></pre>
<p>2、修改流复制方式</p>
<pre><code>1） 修改流复制方式为异步备
   #在root用户下执行
   pcs resource pgsql rep_mod=asycn
2） 查看流复制状体
    #查看集群状态
    #下root用户下执行
    cd /data/postgres/bin
    ./cls_status
3) 查看流复制差额
   #用管理员用户postgres，登陆主库
    select client_addr,sync_state,pg_xlog_location_diff(sent_location,replay_location),replay_location from pg_stat_replication;
</code></pre>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>错误异常too many open files解决方法</title>
    <url>/knowledge-base/2019/09/09/openfilemany/</url>
    <content><![CDATA[<div class="note primary"><p>too many open files是Linux系统中常见的错误 解决方法</p>
</div>
<span id="more"></span>

<h2 id="一、产生原因"><a href="#一、产生原因" class="headerlink" title="一、产生原因"></a>一、产生原因</h2><p>too many open files是Linux系统中常见的错误，从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，也包括打开的通讯链接(比如socket)，正在监听的端口等等，所以有时候也可以叫做句柄(handle)，这个错误通常也可以叫做句柄数超出系统限制。<br>引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数，通过命令ulimit -a可以查看当前系统设置的最大句柄数是多少：</p>
<p>open files那一行就代表系统目前允许单个进程打开的最大句柄数，这里是1024。<br>使用命令lsof -p 进程id可以查看单个进程所有打开的文件详情，使用命令lsof -p 进程id | wc -l可以统计进程打开了多少文件，如果文件数过多使用lsof -p 进程id命令无法完全查看的话，可以使用lsof -p 进程id &gt; openfiles.log将执行结果内容输出到日志文件中查看。</p>
<h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><h3 id="1、增大允许打开的文件数——命令方式"><a href="#1、增大允许打开的文件数——命令方式" class="headerlink" title="1、增大允许打开的文件数——命令方式"></a>1、增大允许打开的文件数——命令方式</h3><p>ulimit -n 2048<br>这样就可以把当前用户的最大允许打开文件数量设置为2048了，但这种设置方法在重启后会还原为默认值。<br>ulimit -n命令非root用户只能设置到4096。<br>想要设置到更大需要sudo权限或者root用户。</p>
<h3 id="2、增大允许打开的文件数——修改系统配置文件"><a href="#2、增大允许打开的文件数——修改系统配置文件" class="headerlink" title="2、增大允许打开的文件数——修改系统配置文件"></a>2、增大允许打开的文件数——修改系统配置文件</h3><p>vim &#x2F;etc&#x2F;security&#x2F;limits.conf  </p>
<p>添加内容 </p>
<ul>
<li><p>soft nofile 4096  </p>
</li>
<li><p>hard nofile 4096<br>或者只加入</p>
</li>
<li><ul>
<li>nofile 8192</li>
</ul>
</li>
</ul>
<p>最前的 * 表示所有用户，可根据需要设置某一用户，例如</p>
<p>roy soft nofile 8192<br>roy hard nofile 8192<br>注意”nofile”项有两个可能的限制措施。就是项下的hard和soft。 要使修改过得最大打开文件数生效，必须对这两种限制进行设定。 如果使用”-“字符设定, 则hard和soft设定会同时被设定。</p>
<h3 id="3、检查程序问题"><a href="#3、检查程序问题" class="headerlink" title="3、检查程序问题"></a>3、检查程序问题</h3><p>如果你对你的程序有一定的解的话，应该对程序打开文件数(链接数)上限有一定的估算，如果感觉数字异常，请使用第一步的lsof -p 进程id &gt; openfiles.log命令，获得当前占用句柄的全部详情进行分析</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pip 通过 requirements 文件，批量下载包，批量离线安装包</title>
    <url>/knowledge-base/2019/08/31/pip-install/</url>
    <content><![CDATA[<div class="note success"><p>本文主要讲述 pip 离线安装包的相关事宜，主要针对内网无法直接使用pip安装的情况, 使用的是linux 服务器</p>
<p>我的讲述重点是能够学会离线的环境下批量安装python库</p>
</div>
<span id="more"></span>

<p>本文概览</p>
<p>本文主要讲述 pip 离线安装包的相关事宜，<br>主要针对内网无法直接使用pip安装的情况, 使用的是linux 服务器</p>
<pre><code>由于大多数情况下都可直接使用 pip install -r requirements.txt
我的讲述重点是能够学会离线的环境下批量安装python库
会兼顾一些常见问题和基础知识，本文不会讲的太深，在一些地方会给出链接，以便深入讨论该主题
本文不仅仅是为了写出解决方案，更多地是学习python 库的基础知识，以便遇见问题时能够自行解决
</code></pre>
<h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><pre><code>python库的安装方法 主要讲安装python 库的几种方式及其分析
pip, pypi与python 库 主要讲安装pip 的安装方法，与python 库的各种分类
操作步骤 主要讲整体操作
常见问题 各种安装或异常情况的问题及其处理

该文也是边学习边总结中不断修改，不断更新的，希望能够帮助到你，有问题可留言评论
</code></pre>
<h3 id="一、-python库的安装方法"><a href="#一、-python库的安装方法" class="headerlink" title="一、 python库的安装方法"></a>一、 python库的安装方法</h3><pre><code>更多关于python 库安装的资料
</code></pre>
<p>常见的安装方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">直接在 pypi 官网下载，而后进行手动安装</span><br><span class="line">使用 pip 根据requirements文件下载安装包，到离线环境中再使用 pip 安装</span><br><span class="line">通过docker 安装相应环境，高级版</span><br><span class="line">通过 Ansible 自动化部署，超级版</span><br></pre></td></tr></table></figure>

<p>各种方式优劣</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一种效率低，但可以解决一两个包的安装，暂时性地解决问题</span><br><span class="line">第二种是本文推荐的方式，可以批量的下载，并且批量安装，解决的是一台服务器上安装多个包的问题</span><br><span class="line">第三种这种方式可以将python 环境进行复制，更适合于多个服务器的安装</span><br><span class="line">不了解，有兴趣可以自行学习</span><br></pre></td></tr></table></figure>

<h3 id="二、pip-pypi与python-库"><a href="#二、pip-pypi与python-库" class="headerlink" title="二、pip, pypi与python 库"></a>二、pip, pypi与python 库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip 官方文档</span><br><span class="line">pip 快速上手</span><br><span class="line">pypi 官网</span><br><span class="line">python package官方文档</span><br><span class="line"></span><br><span class="line">pypi 是存储 python 库(package) 并可通过 pip 进行安装的一个平台</span><br><span class="line"></span><br><span class="line">python 库 比作货物，pypi 就是存储货物的仓库，而pip 可以想象成 pypi 的管理人员，帮助你获取python 库</span><br><span class="line">pip 也是一个python 库，是 easy_install 的升级版，两者就好像 rpm 和 yum 一样</span><br><span class="line">pypi 是一个python 库的官方存储仓库，相应的还有一些镜像源，用来提升速度的</span><br></pre></td></tr></table></figure>

<p>python 库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python 库是什么</span><br><span class="line">python 库本质上就是一个python 程序包，路径一般在 /usr/lib/python3<span class="number">.6</span>/site-packages 下</span><br><span class="line">python 库很重要的一点是 库与库之间是相互依赖的，还有python 库的版本问题也很重要</span><br><span class="line">python 库的常见分类</span><br><span class="line">    是否需要安装后才可使用，可以分为标准库(内置库)和第三方库</span><br><span class="line">    按照操作系统，可以大致分为 windows 和 UNIX 系统两类</span><br><span class="line">    按照python 版本，可以分为 python <span class="number">2</span> ，python <span class="number">3.6</span>，python <span class="number">3.7</span> 等等</span><br><span class="line">    按照解释器，可以分为 cp(C语言 解释器)，jp(Java 解释器)，IronPython（.Net 解释器）等等</span><br><span class="line">    并且库本身还有很多版本，相应版本之间也会有差异</span><br><span class="line">    按照安装包的方式可以分为， 源码包，wheel 包， egg包</span><br><span class="line">源码包，wheel 包与 egg 包</span><br><span class="line">    常见的是 源码包和wheel 包，egg 已经较少了</span><br><span class="line">    源码包就是二进制包，一般安装后会有一个可执行文件</span><br><span class="line">    wheel 包是一种包的格式，可直接使用 pip install xxx.whl 进行安装</span><br><span class="line">    egg 包是以前的版本，相对来说，wheel 格式是 egg 格式的升级版本 ，可使用 python setup.py xxx.egg进行安装</span><br><span class="line">wheel包的命名方式(源码包只有包的版本号)</span><br><span class="line">    wheel包名官方文档</span><br><span class="line">    wheel 包的命名格式为 &#123;distribution&#125;-&#123;version&#125;(-&#123;build tag&#125;)?-&#123;python tag&#125;-&#123;abi tag&#125;-&#123;platform tag&#125;.whl</span><br><span class="line">    例如 mysql_connector-<span class="number">2.1</span><span class="number">.6</span>-cp36-cp36m-win_amd64.whl</span><br><span class="line">    一些通用的包可以使用 no 或者 <span class="built_in">any</span> 对相应字段进行替换，例如这个包是linux 和 windows 都通用的，就可以在platform 上写 <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<p>名称 	对应名称 	解释<br>distribution 	mysql_connector 	包名<br>version 	2.1.6 	版本<br>bulid tag 	备注标签 	可省略<br>python-tag 	cp36 	表示 cpython 3.6 版本<br>abi-tag 	cp36m 	abi Application Binary Interface<br>应用程序二进制接口<br>platform 	win_amd64 	platform 还可以是 any<br>win32 , linux_i386 , linux_x86_64, any 表示 跨平台</p>
<h3 id="三、操作步骤"><a href="#三、操作步骤" class="headerlink" title="三、操作步骤"></a>三、操作步骤</h3><ol>
<li><p>源码包手动安装</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">以 uwsgi 为例，在linux 上安装uwsgi</span><br><span class="line"></span><br><span class="line">下载 uwsgi 源码包, Pypi 官网下载</span><br><span class="line">解压 tar -zxvf uwsgi.tar.gz</span><br><span class="line">进入目录 cd uwsgi</span><br><span class="line">使用python 安装 python3 setup.py install</span><br><span class="line">即可安装成功</span><br><span class="line"></span><br><span class="line">更简单的方法</span><br><span class="line">pip3 install uwsgi-<span class="number">2.0</span><span class="number">.18</span>.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip 安装 官方说明</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In some cases, you may want to install <span class="keyword">from</span> local packages only, <span class="keyword">with</span> no traffic to PyPI.</span><br></pre></td></tr></table></figure>

</li>
<li><p>首先，在项目中分析出所有依赖的库</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

</li>
<li><p>将所有包下载到DIR这个目录中</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> pip download -d DIR -r requirements.txt</span><br><span class="line"> pip wheel -w DIR -r requirements.txt</span><br><span class="line"></span><br><span class="line">切记，不要在 windows 下载包，然后放到 Linux 上进行安装，这样八成装不上</span><br><span class="line"></span><br><span class="line">这两条命令的区别在于wheel 方式下载会将下载的包放入wheel 缓存，但缺点是wheel 不可以下载源码包</span><br><span class="line">download 命令会查看wheel缓存，然后再去PyPI下载库，但download命令下载的包不会进入wheel缓存，download 的优点是可以下载源码包</span><br><span class="line">需要注意，使用wheel 方式安装可能会报错，因为有些包是源码包，不能被打包成wheel 格式</span><br><span class="line">download 方法下载的包，不会对依赖性进行检查，这意味着，如果下载 Flask-PyMongo 这个包，只会下载该包，而不会下载 pymongo，经试验发现，download 适合补充wheel不可下载的包，两者搭配使用，才能将requirements文件的库完整的下载</span><br><span class="line">注意: 如果只使用download 方法下载，很有可能安装时候会报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>将文件打包后放到离线服务器上，并进行解压缩</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 下载后执行下面的命令就可以进行安装了</span><br><span class="line"></span><br><span class="line">$ pip3 install --no-index --find-links=DIR -r requirements.txt</span><br><span class="line">命令说明</span><br><span class="line">freeze 将依赖关系分析出来并 使用管道符导入到该文件中</span><br><span class="line">download 分析 requirements 文件，将所有包进行下载，通过 d 选项导入 DIR 文件夹</span><br><span class="line">wheel 分析requirements 文件，并将所有包及其依赖包下载为 wheel 格式，通过 w 选项导入 DIR 文件夹中</span><br><span class="line">--find-links 指定离线安装的文件夹DIR，也就是你下载好的包</span><br><span class="line">注意: --no-index 必须搭配 --find-links 使用</span><br><span class="line"></span><br><span class="line">--no-index¶</span><br><span class="line">Ignore package index (only looking at --find-links URLs instead).</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">注意生产环境是什么平台，如果是Linux，你需要在虚拟机中下载 wheel包，切记</span><br><span class="line">    包名中有 win ，代表只能在windows 中安装</span><br><span class="line">    没有 win，代表跨平台</span><br><span class="line"></span><br><span class="line">安装时报错，不能找到相应的包，打开文件夹后却发现有 cffi 这个库</span><br><span class="line"></span><br><span class="line">Collecting cffi==<span class="number">1.11</span><span class="number">.5</span> (<span class="keyword">from</span> -r lla/requirements.txt (line <span class="number">12</span>))</span><br><span class="line">  Could <span class="keyword">not</span> find a version that satisfies the requirement cffi==<span class="number">1.11</span><span class="number">.5</span> </span><br><span class="line">    (<span class="keyword">from</span> -r lla/requirements.txt (line <span class="number">12</span>)) (<span class="keyword">from</span> versions: )</span><br><span class="line">No matching distribution found <span class="keyword">for</span> cffi==<span class="number">1.11</span><span class="number">.5</span> (<span class="keyword">from</span> -r lla/requirements.txt (line <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    原因是该库是<span class="number">3.7</span> 版本，而服务器是<span class="number">3.6</span> 版本，导致安装不上</span><br><span class="line">    使用以下命令选择合适的版本，注意 --no-deps 不可缺少，参考官方文档</span><br><span class="line"></span><br><span class="line">     pip3 download </span><br><span class="line">     	--no-deps</span><br><span class="line">        --platform linux_x86_64</span><br><span class="line">        --python-version <span class="number">36</span></span><br><span class="line">        --implementation cp  </span><br><span class="line">        --abi cp36m    </span><br><span class="line">         -r requirements.txt -d pk</span><br><span class="line"></span><br><span class="line">下载时报错</span><br><span class="line"></span><br><span class="line">  Failed building wheel <span class="keyword">for</span> alembic</span><br><span class="line">  Running setup.py clean <span class="keyword">for</span> alembic</span><br><span class="line">  Running setup.py bdist_wheel <span class="keyword">for</span> Mako ... error</span><br><span class="line">  Complete output <span class="keyword">from</span> command /usr/local/<span class="built_in">bin</span>/python3<span class="number">.7</span> -u -c <span class="string">&quot;import setuptoolstokenize;</span></span><br><span class="line"><span class="string">  __file__=&#x27;/tmp/pip-wheel-e6wqgb6g/Mako/setup.py&#x27;;</span></span><br><span class="line"><span class="string">  f=getattr(tokenize,&#x27;open&#x27;, open)(__file__);</span></span><br><span class="line"><span class="string">  code=f.read().replace(&#x27;\r\n&#x27;, &#x27;\n&#x27;);f.close();exec(compile(code, __file__, &#x27;exec&#x27;))&quot;</span></span><br><span class="line">   bdist_wheel -d /tmp/pip-wheel-l_pjqx6k:</span><br><span class="line">  usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]</span><br><span class="line">     <span class="keyword">or</span>: -c --<span class="built_in">help</span> [cmd1 cmd2 ...]</span><br><span class="line">     <span class="keyword">or</span>: -c --<span class="built_in">help</span>-commands</span><br><span class="line">     <span class="keyword">or</span>: -c cmd --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">  error: invalid command <span class="string">&#x27;bdist_wheel&#x27;</span></span><br><span class="line"></span><br><span class="line">  ----------------------------------------</span><br><span class="line">  Failed building wheel <span class="keyword">for</span> Mako</span><br><span class="line">  Running setup.py clean <span class="keyword">for</span> Mako</span><br><span class="line">Failed to build mysql-connector uwsgi SQLAlchemy alembic Mako</span><br><span class="line">ERROR: Failed to build one <span class="keyword">or</span> more wheels</span><br><span class="line">    问题原因，因为这些包的格式是 tar.gz，也就是源码包，是不可以直接转为 wheel 包的</span><br><span class="line">    可参考上面源代码安装方式</span><br><span class="line"></span><br><span class="line">安装报错</span><br><span class="line">    由于服务器自带的是python2，存在python <span class="number">3</span> 和 python <span class="number">2</span> 两个版本共存的情况</span><br><span class="line">    pip 版本错了，换成 pip3 就OK了</span><br></pre></td></tr></table></figure>

<p>PyPI 服务器搭建</p>
<pre><code>https://www.cnblogs.com/special-li/p/9149573.html
该项没有研究
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Promise对象</title>
    <url>/knowledge-base/2019/08/27/react-promise/</url>
    <content><![CDATA[<div class="note info"><p>简述Promise对象的特点和使用方法</p>
</div>
<span id="more"></span>

<h2 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h2><p>promise是异步编程的一种解决方法,比传统的回调函数和事件更合理更强大<br>。他由社区最早提出和实现，ES6将其写进语言标准，统一了用法，原生提供了promise对象。<br>所谓promise，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从语法上说，promise是一个对象，从它可以获取异步操作的消息，promise提供了统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<h2 id="promise对象的特点"><a href="#promise对象的特点" class="headerlink" title="promise对象的特点"></a>promise对象的特点</h2><p>（1）对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承若”；<br>（2）一旦状态改变就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</p>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h2 id="一，用法"><a href="#一，用法" class="headerlink" title="一，用法"></a>一，用法</h2><p>promise对象是一个构造函数，用来生成promise实例;<br>创建一个promise对象实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="keyword">function</span>(<span class="params"> resolve, reject</span>) &#123;</span><br><span class="line">       <span class="comment">//some code</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="comment">//异步操作成功)&#123;</span></span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="title function_">reject</span>(error);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject，他们是两个函数，由Javascript引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将promise对象的状态从“pending”变为‘’resolved‘’，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">   <span class="comment">//success</span></span><br><span class="line">   &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">   <span class="comment">//failure</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>then方法可以接受连个回调函数作为参数，第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数是promise对象的状态变为rejected时调用，其中，第二个函数是可选的，不一定要提供，这两个函数都接受promise对象传出的值作为参数；</p>
<h3 id="promise对象的简单例子"><a href="#promise对象的简单例子" class="headerlink" title="promise对象的简单例子"></a>promise对象的简单例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeOut</span> (ms) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span>    <span class="built_in">setTimeout</span>(resolve,ms,<span class="string">&quot;done&quot;</span>);</span><br><span class="line">       &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">timeOut</span>(<span class="number">3000</span>).<span class="title function_">then</span>( <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>timeOut方法返回一个promise实例，表示一段时间以后才会发生的结果，过了指定的时间（ms）以后，promise实例的状态变为resolved，就会触发then方法绑定的回调函数</p>
<h3 id="Promise新建后就会立即执行"><a href="#Promise新建后就会立即执行" class="headerlink" title="Promise新建后就会立即执行"></a>Promise新建后就会立即执行</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<p>Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
<h3 id="异步加载图片你的例子"><a href="#异步加载图片你的例子" class="headerlink" title="异步加载图片你的例子"></a>异步加载图片你的例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span> (url) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="keyword">function</span>(<span class="params"> resolve, reject</span>)&#123;</span><br><span class="line">              <span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">             image .<span class="property">onoad</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(image);</span><br><span class="line">               &#125;;</span><br><span class="line">             image.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                     <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;could not load image at &quot;</span>+ url) );</span><br><span class="line">             &#125;;</span><br><span class="line">            image.<span class="property">src</span> =url;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">loadImageAsync</span>(url).<span class="title function_">then</span>( <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p>
<h3 id="promise对象实现ajax操作的例子"><a href="#promise对象实现ajax操作的例子" class="headerlink" title="promise对象实现ajax操作的例子"></a>promise对象实现ajax操作的例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>( <span class="keyword">function</span>(<span class="params">resolve,reject </span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> <span class="variable constant_">XHR</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">           <span class="variable constant_">XHR</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,url);</span><br><span class="line">           <span class="variable constant_">XHR</span>.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !==<span class="number">4</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">           <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">               <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>) );</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">            <span class="variable constant_">XHR</span>.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">            <span class="variable constant_">XHR</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>,<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">           <span class="variable constant_">XHR</span>.<span class="title function_">send</span>();</span><br><span class="line">     &#125;);</span><br><span class="line"><span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Contents : &quot;</span>+json );</span><br><span class="line">         &#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了&quot;</span>, error);</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure>

<p>getJSON是对XMLHTTPRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个promise对象，需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数；<br>如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，表示抛出的错误，resolve函数的参数除了正常的值以外，还可以是另一个promise实例；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。<br>这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。<br>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.prototype.then()<br>Promise实例具有then方法，也就是说,then方法定义在原型对象Promise.prototype上的。他的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数 ,第二个参数是rejected状态的回调函数。<br>thenf方法返回的是一个新的Promise实例（不是原来那个Promise实例），因此可以采用链式写法，即then方法后面再调用另一个then方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">json</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> post.<span class="property">json</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>)&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>依次指定了两个回调函数，第一个回到函数完成以后会将返回结果作为参数，传入第二个回调函数。<br>采用链式的then，可以指定一组按照次序调用的回调函数。这时前一个回调函数，有可能返回的还是一个promise对象(即有异步操作)，这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;posts/1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>  <span class="title function_">funA</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved:&quot;</span> ,comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> <span class="title function_">funB</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected：&quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面第一个then方法指定的回调函数，返回的是另一个promise对象，这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funA，如果状态变为rejected，就调用funB。改为箭头函数，代码更简洁:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line"><span class="function"><span class="params">post</span> =&gt;</span> <span class="title function_">getJSON</span>(psot.<span class="property">commentURL</span>)</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line"> <span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved:&quot;</span>,comments),</span><br><span class="line"><span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected:&quot;</span> ,err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件生命周期</title>
    <url>/knowledge-base/2019/08/26/react-lifecycle/</url>
    <content><![CDATA[<div class="note danger"><p>组件的生命周期可分成三个状态：<br>   Mounting：已插入真实 DOM<br>   Updating：正在被重新渲染<br>   Unmounting：已移出真实 DOM</p>
</div>
<span id="more"></span>

<h3 id="生命周期的方法有："><a href="#生命周期的方法有：" class="headerlink" title="生命周期的方法有："></a>生命周期的方法有：</h3><pre><code>componentWillMount 在渲染前调用,在客户端也在服务端。

componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。

componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。

shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。
可以在你确认不需要更新组件时使用。

componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。

componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。

componentWillUnmount在组件从 DOM 中移除之前立刻被调用。
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以下实例在 <span class="title class_">Hello</span> 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔<span class="number">100</span>毫秒重新设置组件的透明度，并重新渲染：</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>React 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">super</span>(props);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">opacity</span>: <span class="number">1.0</span>&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">var</span> opacity = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">opacity</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      opacity -= <span class="number">.05</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (opacity &lt; <span class="number">0.1</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        opacity = <span class="number">1.0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">opacity</span>: opacity</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">100</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  render () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;opacity:</span> <span class="attr">this.state.opacity</span>&#125;&#125;&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">        Hello &#123;this.props.name&#125;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>/&gt;</span></span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="property">body</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">以下实例初始化 state ， setNewnumber 用于更新 state。所有生命周期在 <span class="title class_">Content</span> 组件中。</span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>React 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">super</span>(props);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">data</span>: <span class="number">0</span>&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">setNewNumber</span> = <span class="variable language_">this</span>.<span class="property">setNewNumber</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setNewNumber</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">data</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span> + <span class="number">1</span>&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.setNewNumber&#125;</span>&gt;</span>INCREMENT<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">            <span class="tag">&lt;<span class="name">Content</span> <span class="attr">myNumber</span> = <span class="string">&#123;this.state.data&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">class</span> <span class="title class_">Content</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component WILL MOUNT!&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component DID MOUNT!&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">newProps</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component WILL RECEIVE PROPS!&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component WILL UPDATE!&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component DID UPDATE!&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component WILL UNMOUNT!&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;this.props.myNumber&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      );</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title>docker 安装和设置</title>
    <url>/knowledge-base/2019/08/23/docker_install/</url>
    <content><![CDATA[<div class="note primary"><p>记录docker 安装和设置</p>
</div>
<span id="more"></span>

<h1 id="linux下-docker-离线安装"><a href="#linux下-docker-离线安装" class="headerlink" title="linux下 docker 离线安装"></a>linux下 docker 离线安装</h1><p><strong>一、基础环境</strong><br>1、操作系统：CentOS 7.3<br>2、Docker版本：<a href="https://download.docker.com/linux/static/stable/x86_64/">18.06.1 官方下载地址（打不开可能需要梯子）</a><br>3、百度云Docker 18.06.1地址：<a href="https://pan.baidu.com/s/1YdN9z72QutPkHBfLq06H1A">https://pan.baidu.com/s/1YdN9z72QutPkHBfLq06H1A</a> 密码：dvvh<br>4、官方参考文档：<a href="https://docs.docker.com/install/linux/docker-ce/binaries/#install-static-binaries">https://docs.docker.com/install/linux/docker-ce/binaries/#install-static-binaries</a></p>
<p><strong>二、Docker安装</strong></p>
<p>1、下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.docker.com/linux/static/stable/x86_64/docker-18.06.1-ce.tgz</span><br></pre></td></tr></table></figure>

<p>2、解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf docker-20.10.3_arm.tgz</span><br></pre></td></tr></table></figure>

<p>3、将解压出来的docker文件内容移动到 &#x2F;usr&#x2F;bin&#x2F; 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp docker/* /usr/bin/</span><br></pre></td></tr></table></figure>

<p>4、将docker注册为service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">  </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"># the default is not to use systemd for cgroups because the delegate issues still</span><br><span class="line"># exists and systemd currently does not support the cgroup feature set required</span><br><span class="line"># for containers run by docker</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"># Uncomment TasksMax if your systemd version supports it.</span><br><span class="line"># Only systemd 226 and above support this version.</span><br><span class="line">#TasksMax=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"># set delegate yes so that systemd does not reset the cgroups of docker containers</span><br><span class="line">Delegate=yes</span><br><span class="line"># kill only the docker process, not all processes in the cgroup</span><br><span class="line">KillMode=process</span><br><span class="line"># restart the docker process if it exits prematurely</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">  </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>5、启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/systemd/system/docker.service #添加文件权限并启动docker </span><br><span class="line">systemctl daemon-reload         #重新加载配置文件</span><br><span class="line">systemctl start docker     #启动Docker</span><br><span class="line">systemctl enable docker.service     #设置开机自启</span><br><span class="line">普通用户使用docker</span><br><span class="line">groupadd docker //建立 Docker 用户组</span><br><span class="line">usermod -G docker appbbfb</span><br></pre></td></tr></table></figure>

<p>6、验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker     #查看Docker状态 docker -v      #查看Docker版本</span><br></pre></td></tr></table></figure>

<p>7.<em>[可选]</em> 为 Docker 建立用户组</p>
<p>docker 命令与 Docker 引擎通讯之间通过 UnixSocket ，但是能够有权限访问 UnixSocket 的用户只有 root 和 docker 用户组的用户才能够进行访问，所以我们需要建立一个 docker 用户组，并且将需要访问 docker 的用户添加到这一个用户组当中来。</p>
<ol>
<li>建立 Docker 用户组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>2.添加当前用户到 docker 组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启docker 服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="把在使用的Linux系统做成docker镜像"><a href="#把在使用的Linux系统做成docker镜像" class="headerlink" title="把在使用的Linux系统做成docker镜像"></a>把在使用的Linux系统做成docker镜像</h2><p>1.选定制作成镜像的系统</p>
<p>2.系统进行格式转化并压缩，执行如下命令，生成一个镜像的centos7-base.tar的文件<br>   tar –numeric-owner –exclude&#x3D;&#x2F;proc –exclude&#x3D;&#x2F;sys -cvf centos7-base.tar &#x2F;    </p>
<p>​     或者</p>
<p>tar -cvpf &#x2F;home&#x2F;buildrpm.tar –directory&#x3D;&#x2F; –exclude&#x3D;proc –exclude&#x3D;sys –exclude&#x3D;dev –exclude&#x3D;run &#x2F;</p>
<p>3.docker import 导入   把镜像文件centos7-base.tar放到装有docker的系统上<br>  docker import      centos7-base.tar         自定义images名字<br>4.docker images 查看后使用即可<br>  docker run -it  –name    images名字        &#x2F;bin&#x2F;bash</p>
<h3 id="制作自己的系统的镜像"><a href="#制作自己的系统的镜像" class="headerlink" title="制作自己的系统的镜像"></a>制作自己的系统的镜像</h3><p>试验如下：在centos7机器上做centos镜像</p>
<p>直接参考这个脚本</p>
<p><a href="https://raw.githubusercontent.com/docker/docker/master/contrib/mkimage-yum.sh">https://raw.githubusercontent.com/docker/docker/master/contrib/mkimage-yum.sh</a></p>
<p>.&#x2F;mkimage-yum.sh -y &#x2F;etc&#x2F;yum.conf centos7</p>
<p>执行如上脚本，成功后，就可以看到镜像了【docker images】,概要说明一下，主要是如下几步：</p>
<p>1．tmp目录下建立临时目录和文件系统</p>
<p>2．使用yum安装相关的软件包</p>
<p>3．软件包安装和信息定制</p>
<p>4．tar打包</p>
<p>5．清理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Create a base CentOS Docker image.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script is useful on systems with yum installed (e.g., building</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a CentOS image on CentOS).  See contrib/mkimage-rinse.sh <span class="keyword">for</span> a way</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to build CentOS images on other systems.</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">	cat &lt;&lt; EOOPTS</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(<span class="built_in">basename</span> <span class="variable">$0</span>) [OPTIONS] &lt;name&gt;</span></span><br><span class="line">OPTIONS:</span><br><span class="line">  -p &quot;&lt;packages&gt;&quot;  The list of packages to install in the container.</span><br><span class="line">                   The default is blank. Can use multiple times.</span><br><span class="line">  -g &quot;&lt;groups&gt;&quot;    The groups of packages to install in the container.</span><br><span class="line">                   The default is &quot;Core&quot;. Can use multiple times.</span><br><span class="line">  -y &lt;yumconf&gt;     The path to the yum config to install packages from. The</span><br><span class="line">                   default is /etc/yum.conf for Centos/RHEL and /etc/dnf/dnf.conf for Fedora</span><br><span class="line">  -t &lt;tag&gt;         Specify Tag information.</span><br><span class="line">                   default is reffered at /etc/&#123;redhat,system&#125;-release</span><br><span class="line">EOOPTS</span><br><span class="line">	exit 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">option defaults</span></span><br><span class="line">yum_config=/etc/yum.conf</span><br><span class="line">if [ -f /etc/dnf/dnf.conf ] &amp;&amp; command -v dnf &amp;&gt; /dev/null; then</span><br><span class="line">	yum_config=/etc/dnf/dnf.conf</span><br><span class="line">	alias yum=dnf</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> names with spaces, use double quotes (<span class="string">&quot;) as install_groups=(&#x27;Core&#x27; &#x27;&quot;</span>Compute Node<span class="string">&quot;&#x27;)</span></span></span><br><span class="line">install_groups=()</span><br><span class="line">install_packages=()</span><br><span class="line">version=</span><br><span class="line">while getopts &quot;:y:p:g:t:h&quot; opt; do</span><br><span class="line">	case $opt in</span><br><span class="line">		y)</span><br><span class="line">			yum_config=$OPTARG</span><br><span class="line">			;;</span><br><span class="line">		h)</span><br><span class="line">			usage</span><br><span class="line">			;;</span><br><span class="line">		p)</span><br><span class="line">			install_packages+=(&quot;$OPTARG&quot;)</span><br><span class="line">			;;</span><br><span class="line">		g)</span><br><span class="line">			install_groups+=(&quot;$OPTARG&quot;)</span><br><span class="line">			;;</span><br><span class="line">		t)</span><br><span class="line">			version=&quot;$OPTARG&quot;</span><br><span class="line">			;;</span><br><span class="line">		\?)</span><br><span class="line">			echo &quot;Invalid option: -$OPTARG&quot;</span><br><span class="line">			usage</span><br><span class="line">			;;</span><br><span class="line">	esac</span><br><span class="line">done</span><br><span class="line">shift $((OPTIND - 1))</span><br><span class="line">name=$1</span><br><span class="line"></span><br><span class="line">if [[ -z $name ]]; then</span><br><span class="line">	usage</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">default to Core group if not specified otherwise</span></span></span><br><span class="line">if [ $&#123;#install_groups[*]&#125; -eq 0 ]; then</span><br><span class="line">	install_groups=(&#x27;Core&#x27;)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">target=$(mktemp -d --tmpdir $(basename $0).XXXXXX)</span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line"></span><br><span class="line">mkdir -m 755 &quot;$target&quot;/dev</span><br><span class="line">mknod -m 600 &quot;$target&quot;/dev/console c 5 1</span><br><span class="line">mknod -m 600 &quot;$target&quot;/dev/initctl p</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/full c 1 7</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/null c 1 3</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/ptmx c 5 2</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/random c 1 8</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/tty c 5 0</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/tty0 c 4 0</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/urandom c 1 9</span><br><span class="line">mknod -m 666 &quot;$target&quot;/dev/zero c 1 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">amazon linux yum will fail without vars set</span></span></span><br><span class="line">if [ -d /etc/yum/vars ]; then</span><br><span class="line">	mkdir -p -m 755 &quot;$target&quot;/etc/yum</span><br><span class="line">	cp -a /etc/yum/vars &quot;$target&quot;/etc/yum/</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n &quot;$install_groups&quot; ]]; then</span><br><span class="line">	yum -c &quot;$yum_config&quot; --installroot=&quot;$target&quot; --releasever=/ --setopt=tsflags=nodocs \</span><br><span class="line">		--setopt=group_package_types=mandatory -y groupinstall &quot;$&#123;install_groups[@]&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n &quot;$install_packages&quot; ]]; then</span><br><span class="line">	yum -c &quot;$yum_config&quot; --installroot=&quot;$target&quot; --releasever=/ --setopt=tsflags=nodocs \</span><br><span class="line">		--setopt=group_package_types=mandatory -y install &quot;$&#123;install_packages[@]&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">yum -c &quot;$yum_config&quot; --installroot=&quot;$target&quot; -y clean all</span><br><span class="line"></span><br><span class="line">cat &gt; &quot;$target&quot;/etc/sysconfig/network &lt;&lt; EOF</span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=localhost.localdomain</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">effectively: febootstrap-minimize --keep-zoneinfo --keep-rpmdb --keep-services &quot;</span><span class="variable">$target</span><span class="string">&quot;.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> locales</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/usr/&#123;&#123;lib,share&#125;/locale,&#123;lib,lib64&#125;/gconv,bin/localedef,sbin/build-locale-archive&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> docs and man pages</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/usr/share/&#123;man,doc,info,gnome/help&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> cracklib</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/usr/share/cracklib</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> i18n</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/usr/share/i18n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> yum cache</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/var/cache/yum</span><br><span class="line">mkdir -p --mode=0755 &quot;$target&quot;/var/cache/yum</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> sln</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/sbin/sln</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string"> ldconfig</span></span></span><br><span class="line">rm -rf &quot;$target&quot;/etc/ld.so.cache &quot;$target&quot;/var/cache/ldconfig</span><br><span class="line">mkdir -p --mode=0755 &quot;$target&quot;/var/cache/ldconfig</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$version&quot; ]; then</span><br><span class="line">	for file in &quot;$target&quot;/etc/&#123;redhat,system&#125;-release; do</span><br><span class="line">		if [ -r &quot;$file&quot; ]; then</span><br><span class="line">			version=&quot;$(sed &#x27;s/^[^0-9\]*\([0-9.]\+\).*$/\1/&#x27; &quot;$file&quot;)&quot;</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$version&quot; ]; then</span><br><span class="line">	echo &gt;&amp;2 &quot;warning: cannot autodetect OS version, using &#x27;$name&#x27; as tag&quot;</span><br><span class="line">	version=$name</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">tar --numeric-owner -c -C &quot;$target&quot; . | docker import - $name:$version</span><br><span class="line"></span><br><span class="line">docker run -i -t --rm $name:$version /bin/bash -c &#x27;echo success&#x27;</span><br><span class="line"></span><br><span class="line">rm -rf &quot;$target&quot;</span><br></pre></td></tr></table></figure>

<p>docker run -d  -p 1000:22 –name&#x3D;ax7-test ax7:7.3.1512  &#x2F;usr&#x2F;sbin&#x2F;init</p>
<p>docker exec -it ax7 bash</p>
<h2 id="修改运行中的docker容器的端口映射和挂载目录"><a href="#修改运行中的docker容器的端口映射和挂载目录" class="headerlink" title="修改运行中的docker容器的端口映射和挂载目录"></a>修改运行中的docker容器的端口映射和挂载目录</h2><p>在docker run创建并运行容器的时候，可以通过-p指定端口映射规则。但是，我们经常会遇到刚开始忘记设置端口映射或者设置错了需要修改。当docker start运行容器后并没有提供一个-p选项或设置，让你修改指定端口映射规则。那么这种情况我们该怎么处理呢？今天Docker君教你如何修改运行中的docker容器的端口映射？</p>
<h3 id="方法一：删除原有容器，重新建新容器"><a href="#方法一：删除原有容器，重新建新容器" class="headerlink" title="方法一：删除原有容器，重新建新容器"></a>方法一：删除原有容器，重新建新容器</h3><p>这个解决方案最为简单，把原来的容器删掉，重新建一个。当然这次不要忘记加上端口映射。</p>
<p>优缺点：优点是简单快捷，在测试环境使用较多。缺点是如果是数据库镜像，那重新建一个又要重新配置一次，就比较麻烦了。</p>
<h3 id="方法二：修改容器配置文件，重启docker服务"><a href="#方法二：修改容器配置文件，重启docker服务" class="headerlink" title="方法二：修改容器配置文件，重启docker服务"></a>方法二：修改容器配置文件，重启docker服务</h3><p>容器的配置文件路径：</p>
<ol>
<li><code>/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code></li>
</ol>
<p>  其中的hashofthecontainer是docker镜像的hash值，可以通过docker ps或者docker inspect containername查看。（CONTAINER ID就可以看出来）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ecs-5286 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                     COMMAND             CREATED             STATUS                  PORTS                                                                  NAMES</span><br><span class="line">f8511e56585f        gitlab/gitlab-ce:latest   &quot;/assets/wrapper&quot;   8 months ago        Up 16 hours (healthy)   0.0.0.0:10022-&gt;22/tcp, 0.0.0.0:8080-&gt;80/tcp, 0.0.0.0:10443-&gt;443/tcp   gitlab-ce</span><br><span class="line">[root@ecs-5286 ~]# </span><br><span class="line">[root@ecs-5286 ~]# </span><br><span class="line">[root@ecs-5286 ~]# cat /var/lib/docker/containers/f8511e56585fdd68d4bb5ad57250d829bac52626d722305a43dec1e5cf18406c/hostconfig.json </span><br><span class="line">&#123;&quot;Binds&quot;:[&quot;/srv/gitlab/logs:/var/log/gitlab&quot;,&quot;/srv/gitlab/data:/var/opt/gitlab&quot;,&quot;/srv/gitlab/config:/etc/gitlab&quot;],&quot;ContainerIDFile&quot;:&quot;&quot;,&quot;LogConfig&quot;:&#123;&quot;Type&quot;:&quot;journald&quot;,&quot;Config&quot;:&#123;&#125;&#125;,&quot;NetworkMode&quot;:&quot;default&quot;,&quot;PortBindings&quot;:&#123;&quot;22/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10022&quot;&#125;],&quot;443/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10443&quot;&#125;],&quot;80/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;10080&quot;&#125;]&#125;,&quot;RestartPolicy&quot;:&#123;&quot;Name&quot;:&quot;always&quot;,&quot;MaximumRetryCount&quot;:0&#125;,&quot;AutoRemove&quot;:false,&quot;VolumeDriver&quot;:&quot;&quot;,&quot;VolumesFrom&quot;:null,&quot;CapAdd&quot;:null,&quot;CapDrop&quot;:null,&quot;Dns&quot;:[],&quot;DnsOptions&quot;:[],&quot;DnsSearch&quot;:[],&quot;ExtraHosts&quot;:null,&quot;GroupAdd&quot;:null,&quot;IpcMode&quot;:&quot;&quot;,&quot;Cgroup&quot;:&quot;&quot;,&quot;Links&quot;:[],&quot;OomScoreAdj&quot;:0,&quot;PidMode&quot;:&quot;&quot;,&quot;Privileged&quot;:false,&quot;PublishAllPorts&quot;:false,&quot;ReadonlyRootfs&quot;:false,&quot;SecurityOpt&quot;:null,&quot;UTSMode&quot;:&quot;&quot;,&quot;UsernsMode&quot;:&quot;&quot;,&quot;ShmSize&quot;:67108864,&quot;Runtime&quot;:&quot;docker-runc&quot;,&quot;ConsoleSize&quot;:[0,0],&quot;Isolation&quot;:&quot;&quot;,&quot;CpuShares&quot;:0,&quot;Memory&quot;:0,&quot;NanoCpus&quot;:0,&quot;CgroupParent&quot;:&quot;&quot;,&quot;BlkioWeight&quot;:0,&quot;BlkioWeightDevice&quot;:null,&quot;BlkioDeviceReadBps&quot;:null,&quot;BlkioDeviceWriteBps&quot;:null,&quot;BlkioDeviceReadIOps&quot;:null,&quot;BlkioDeviceWriteIOps&quot;:null,&quot;CpuPeriod&quot;:0,&quot;CpuQuota&quot;:0,&quot;CpuRealtimePeriod&quot;:0,&quot;CpuRealtimeRuntime&quot;:0,&quot;CpusetCpus&quot;:&quot;&quot;,&quot;CpusetMems&quot;:&quot;&quot;,&quot;Devices&quot;:[],&quot;DiskQuota&quot;:0,&quot;KernelMemory&quot;:0,&quot;MemoryReservation&quot;:0,&quot;MemorySwap&quot;:0,&quot;MemorySwappiness&quot;:-1,&quot;OomKillDisable&quot;:false,&quot;PidsLimit&quot;:0,&quot;Ulimits&quot;:null,&quot;CpuCount&quot;:0,&quot;CpuPercent&quot;:0,&quot;IOMaximumIOps&quot;:0,&quot;IOMaximumBandwidth&quot;:0&#125;</span><br><span class="line">[root@ecs-5286 ~]# </span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p>按需修改端口, 按需修改挂载目录(权限和属主属组要相同)，然后重启docker服务，再启动容器服务就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p> 优缺点：这个方法的优点是没有副作用，操作简单。缺点是需要重启整个docker服务，如果在同一个宿主机上运行着多个容器服务的话，就会影响其他容器服务。</p>
<h2 id="Docker-修改默认存储路径的一个方法"><a href="#Docker-修改默认存储路径的一个方法" class="headerlink" title="Docker 修改默认存储路径的一个方法"></a><a href="https://www.cnblogs.com/jinanxiaolaohu/p/8301786.html">Docker 修改默认存储路径的一个方法</a></h2><p>\1. 前期安装创建centOS的虚拟机时发现自己对linux的挂载点不清楚, 造成挂载点的分配不太均匀,如图:</p>
<p>root &#x2F; 节点的大小设置的比较小 &#x2F;home路径设置的一直比较大</p>
<p>但是docker 默认的存储路径在 &#x2F;var&#x2F;lib&#x2F;docker下面 感觉不太好.</p>
<p><img src="https://images2017.cnblogs.com/blog/485196/201801/485196-20180117110412474-1975160813.png" alt="img"></p>
<p>\2. 为了解决这个问题, 计划将docker的默认存储路径从&#x2F;var&#x2F;lib&#x2F;docker中移出去</p>
<p>方法: 在&#x2F;home 目录下创建目录.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir docker</span><br></pre></td></tr></table></figure>

<p>\3. 修改docker的systemd的 docker.service的配置文件</p>
<p>不知道 配置文件在哪里可以使用systemd 命令显示一下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl disable docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">#显示结果</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>

<p>\4. 修改docker.service文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>

<p>\5. 在里面的EXECStart的后面增加后如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd --graph /home/docker</span><br></pre></td></tr></table></figure>

<p>\6. 重新enable 一下docker 服务 重新进行软连接 以及进行一次 daemon-reload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl disable docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systecmtl daemon-reload</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">http://22.200.126.235:15672/</span><br><span class="line">http://22.200.126.236:15672/</span><br><span class="line">  http://22.200.126.237:15672/</span><br><span class="line">http://22.200.126.238:15672/</span><br></pre></td></tr></table></figure>

<p>\7. 查看docker info 信息<br><img src="/knowledge-base/docker-info.png" alt="img"></p>
<p>\8. docker pull 一个image 查看存放路径是否准确</p>
<p>验证镜像信息存放到了 &#x2F;home&#x2F;docker 目录下</p>
<p><img src="/knowledge-base/du-docker.png" alt="img"></p>
<h2 id="linux修改用户主目录的方法"><a href="#linux修改用户主目录的方法" class="headerlink" title="linux修改用户主目录的方法"></a>linux修改用户主目录的方法</h2><p>第一：修改&#x2F;etc&#x2F;passwd文件<br>第二：usermod命令 </p>
<p>详细说明如下：<br>第一种方法：vi &#x2F;etc&#x2F;passwd<br>找到要修改的用户那几行，修改掉即可。此法很暴力，建议慎用。<br>&#x2F;etc&#x2F;passwd文件格式<br>登录名：加密口令：数字用户ID:数字组ID:注释字段：起始目录：shell程序<br>用此方法修改了用户宿主目录后，会出现某些异常，如：bash环境异常，需要将用户原宿主目录下的隐藏文件拷贝到更改后的宿主目录即可<br>cp &#x2F;原宿主目录&#x2F;.* &#x2F;目标目录  </p>
<p>第二种：usermod<br>usermod -d &#x2F;usr&#x2F;newfolder -u uid<br>-u后面一定要接uid啊，不是username<br>附：usermod详细参数<br>语　　法：usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][- f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s ][-u ] [用户帐号] </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用案例 </span><br><span class="line">heihaier@heihaier-desktop:~$ id root </span><br><span class="line">uid=0(root) gid=0(root) groups=0(root) </span><br><span class="line">方法二：查看 /etc/password 文件  </span><br><span class="line">/etc/password 文件格式 </span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br><span class="line">上面是这个文件的一行实例，每个域用 : 区分，从左向右分别是 </span><br><span class="line">root 用户名：1~32 字节长。 </span><br><span class="line">x 密码：字符x表示密码被加密保存在 /etc/shadow 文件中。 </span><br><span class="line">0 用户ID(UID)：每个用户必需指定UID。UID 0 是保留给 root 用户的。UID 1~99是保留给其它预定义用户的。 UID 100~999是保留给系统用户的。 </span><br><span class="line">0 组ID(GID)：主组ID（保存在 /etc/group 文件中）。 </span><br><span class="line">root 用户ID信息：用户备注信息。 </span><br><span class="line">/root 主目录：用户主目录。 </span><br><span class="line">/bin/bash 命令解释器(Shell)：用户默认的命令解释器的路径。 </span><br><span class="line">使用案例 </span><br><span class="line">heihaier@heihaier-desktop:~$ sudo cat /etc/passwd | grep root </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="修改目录之后shell出现bash-4-2想象"><a href="#修改目录之后shell出现bash-4-2想象" class="headerlink" title="修改目录之后shell出现bash-4.2想象"></a>修改目录之后shell出现bash-4.2想象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拷贝/etc/skel的文件到$HOME的文件家目录</span><br></pre></td></tr></table></figure>

<h2 id="docker远程仓库镜像删除"><a href="#docker远程仓库镜像删除" class="headerlink" title="docker远程仓库镜像删除"></a>docker远程仓库镜像删除</h2><p>1、 查看仓库中的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET http://registry.test.cn:5000/v2/_catalog |python -m json.tool </span><br><span class="line">&#123;     &quot;repositories&quot;: [        &quot;nginx&quot;,        &quot;grafana&quot;    ] &#125; </span><br></pre></td></tr></table></figure>

<p>2、 查看某个镜像的标签列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET http://registry.test.cn:5000/v2/grafana/tags/list |python -m json.tool </span><br><span class="line">&#123;    &quot;name&quot;: &quot;grafana&quot;,    &quot;tags&quot;: [        &quot;v3.11.82&quot;,        &quot;latest&quot;    ] &#125; </span><br></pre></td></tr></table></figure>

<p>3、 查看某个镜像的digest值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  -I -X GET http://registry.test.cn:5000/v2/grafana/manifests/v3.11.82 </span><br><span class="line">HTTP/1.1 200 OK Content-Length: 5805 Content-Type: application/vnd.docker.distribution.manifest.v1+prettyjws Docker-Content-Digest: sha256:2d6ff127dd79779c7a4c0e42975ddec4d7243019946e0a53084c8107a736f9e5 Docker-Distribution-Api-Version: registry/2.0 Etag: &quot;sha256:2d6ff127dd79779c7a4c0e42975ddec4d7243019946e0a53084c8107a736f9e5&quot; Date: Wed, 04 Mar 2020 09:48:38 GMT </span><br></pre></td></tr></table></figure>

<p>4、 删除某个镜像的某个版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  -X DELETE http://registry.test.cn:5000/v2/grafana/manifests/v3.11.82 </span><br><span class="line">或者 </span><br><span class="line">curl  -X DELETE http://registry.test.cn:5000/v2/grafana/manifests/sha256:2d6ff127dd79779c7a4c0e42975ddec4d7243019946e0a53084c8107a736f9e5 &#123;&quot;errors&quot;:[&#123;&quot;code&quot;:&quot;UNSUPPORTED&quot;,&quot;message&quot;:&quot;The operation is unsupported.&quot;&#125;]&#125; </span><br></pre></td></tr></table></figure>

<h1 id="docker-私有仓库-删除镜像"><a href="#docker-私有仓库-删除镜像" class="headerlink" title="docker 私有仓库 删除镜像"></a><a href="https://www.cnblogs.com/liubiaos/p/11271395.html">docker 私有仓库 删除镜像</a></h1><p>1、查找官方删除法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/burnettk/delete-docker-registry-image</span><br></pre></td></tr></table></figure>

<p>2、民用删除法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000018166325</span><br></pre></td></tr></table></figure>

<p>3、测试过后，发现自己部署的居然和大众不一样，随机自己摸索。</p>
<p>大体流程，找到数据存放在服务器的数据，然后删除数据。即便这样删除了，也没有用，需要再到容器内部更新数据，启用垃圾回收机制，才能真正的删除掉数据。</p>
<p>1、查看是否开启了删除数据功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it registry sh 进入容器内部，查看数据是否有开删除数据功能``cd /etc/registry/config.yml  </span><br></pre></td></tr></table></figure>

<p>　　<img src="https://img2018.cnblogs.com/blog/1244297/201907/1244297-20190730170416919-244362191.png" alt="img"></p>
<p>2、查看数据存放在哪？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /data/registry/docker/registry/v2/repositories</span><br></pre></td></tr></table></figure>

<p>　　查看到仓库数据，所以尝试删出一个仓库数据。（这个需要查看容器和服务器的文件夹目录来找到）</p>
<p>3、删除数据，同步垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry garbage-collect /etc/registry/config.yml</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>4、查看效果</p>
<p><img src="https://img2018.cnblogs.com/blog/1244297/201907/1244297-20190730170837131-976985934.png" alt="img"></p>
<p>删除完毕！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/etcd/bin/etcd --name=etcd01 --data-dir=/opt/etcd/data/default.etcd --listen-client-urls=https://192.168.0.201:2379,http://127.0.0.1:2379 --listen-peer-urls=https://192.168.0.201:2380 --advertise-client-urls=https://192.168.0.201:2379 --initial-advertise-peer-urls=https://192.168.0.201:2380 --initial-cluster-token=etcd-cluster --initial-cluster=etcd01=https://192.168.0.201:2380,etcd02=https://192.168.0.10:2380 --initial-cluster-state=new  --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --peer-cert-file=/opt/etcd/ssl/server.pem --peer-key-file=/opt/etcd/ssl/server-key.pem --trusted-ca-file=/opt/etcd/ssl/ca.pem --peer-trusted-ca-file=/opt/etcd/ssl/ca.pem</span><br></pre></td></tr></table></figure>

<p>老师，应用堡垒机的网络是你们这边打通吗？</p>
<p> 21.9.198.229&#x2F;230–&gt; 22.252.7.3 端口443</p>
<p>21.9.198.229&#x2F;230–&gt; 22.244.87.22 端口15672</p>
<p>21.9.198.229&#x2F;230–&gt; 22.244.87.23 端口 15672</p>
<p>21.9.198.229&#x2F;230–&gt; 22.244.87.24 端口 15672</p>
<p>21.9.198.229&#x2F;230–&gt; 22.244.87.25 端口 15672</p>
<p>21.9.198.229&#x2F;230–&gt; 22.244.87.26 端口 15672</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 详解</title>
    <url>/knowledge-base/2019/08/23/docker/</url>
    <content><![CDATA[<div class="note primary"><p>记录dokcer学习路程</p>
</div>
<span id="more"></span>

<h2 id="docker离线安装"><a href="#docker离线安装" class="headerlink" title="docker离线安装"></a>docker离线安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 下载docker安装包</span><br><span class="line">docker安装包下载地址：https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</span><br><span class="line">选择对应的安装包</span><br><span class="line">需要下载</span><br><span class="line">selinux包：docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm  -- 这个可以不用</span><br><span class="line">docker包：docker-ce-17.03.2.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">拷贝到linx环境</span><br><span class="line">先安装selinux包：rpm -ivh docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm </span><br><span class="line">然后安装docker包：rpm -ivh docker-ce-17.03.2.ce-1.el7.centos.x86_64.rpm</span><br><span class="line">2. 启动docker</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>

<h2 id="docker创建本地源"><a href="#docker创建本地源" class="headerlink" title="docker创建本地源"></a>docker创建本地源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.拉取镜像仓库</span><br><span class="line">docker  pull  registry </span><br><span class="line">2.查看所有镜像</span><br><span class="line"> docker images</span><br><span class="line">3.启动镜像服务器registry</span><br><span class="line">首先在在主机上新建一个目录，供存储镜像</span><br><span class="line">cd /usr/local/</span><br><span class="line">mkdir docker_registry </span><br><span class="line">启动镜像</span><br><span class="line">docker run -d -p 5000:5000 --name=brillianceregistry --restart=always --privileged=true  -v /usr/local/docker_registry:/var/lib/registry  docker.io/registry</span><br><span class="line">解释：</span><br><span class="line">  -p 5000:5000 端口</span><br><span class="line">  --name=jackspeedregistry 运行的容器名称</span><br><span class="line">  --restart=always 自动重启</span><br><span class="line">   --privileged=true centos7中的安全模块selinux把权限禁止了，加上这行是给容器增加执行权限</span><br><span class="line">  -v /usr/local/docker_registry:/var/lib/registry 把主机的/usr/local/docker_registry 目录挂载到registry容器的/var/lib/registry目录下，假如有删除容器操作，我们的镜像也不会被删除</span><br><span class="line">  docker.io/registry  镜像名称</span><br><span class="line">查看启动的容器</span><br><span class="line"></span><br><span class="line">已经启动的镜像</span><br><span class="line">4.从公有仓库拉取一个镜像下来，然后push到私有仓库中进行测试，当前用nginx镜像做测试</span><br><span class="line">docker pull  nginx  --- 这是需要联网的</span><br><span class="line">docker images </span><br><span class="line"></span><br><span class="line">5.给docker注册https协议，支持https访问</span><br><span class="line"></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">如果daemon文件不存在，vim会自己创建一个，假如一下代码，</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;主机的IP地址或者域名:5000&quot;],</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">注释：</span><br><span class="line">  insecure-registries-----&gt;开放注册https协议</span><br><span class="line">  registry-mirrors-----&gt;仓库源</span><br><span class="line"></span><br><span class="line">6.新建一个tag，把docker.io/nginx名称变成域名或者IP/镜像名称</span><br><span class="line"></span><br><span class="line">docker tag docker.io/nginx ip或者域名:5000/nginx</span><br><span class="line">推送到本地仓库</span><br><span class="line"></span><br><span class="line">docker push ip或者域名:5000/nginx</span><br><span class="line"></span><br><span class="line">docker pull 报错Get https://xxx.xxx.xxx.xxx:5000/v1/_ping: http: server gave HTTP response</span><br><span class="line">解决方法：</span><br><span class="line">    运行命令：</span><br><span class="line">        echo &#x27;&#123; &quot;insecure-registries&quot;:[&quot;xxx.xxx.xxx.xxx:5000&quot;] &#125;&#x27; &gt; /etc/docker/daemon.json</span><br><span class="line">        systemctl restart docker</span><br><span class="line"></span><br><span class="line">上传完成</span><br><span class="line">7.进入刚才新建的nginx仓库目录得到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.删除刚刚tag的镜像 （11.*******:5000/nginx刚才创建的镜像的tag）</span><br><span class="line"></span><br><span class="line">docker rmi 111.*******:5000/nginx</span><br><span class="line">docker rmi  nginx </span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实验环境</span><br><span class="line"></span><br><span class="line">192.168.80.200 #不能上外网的docker仓库，centos7系统</span><br><span class="line"></span><br><span class="line">192.168.80.100 #能上外网的Linux服务器，centos7系统</span><br><span class="line"></span><br><span class="line">利用yum仓库安装docker服务</span><br><span class="line"></span><br><span class="line">把docker的rpm包导入内网yum仓库中（docker软件包docker-ce，container-selinux）</span><br><span class="line"></span><br><span class="line">（下载地址：http://rpmfind.net/linux/rpm2html/search.php）</span><br><span class="line"></span><br><span class="line">配置好本地yum仓库源（具体配置可看：http://vcvcv.blog.51cto.com/11324936/1934834）</span><br><span class="line"></span><br><span class="line">安装docker服务</span><br><span class="line"></span><br><span class="line">yum install docker-ce</span><br><span class="line"></span><br><span class="line">启动docker服务</span><br><span class="line"></span><br><span class="line">systemctl docker start</span><br><span class="line"></span><br><span class="line">以上就安装好了内网docker服务</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内网环境创建docker仓库"><a href="#内网环境创建docker仓库" class="headerlink" title="内网环境创建docker仓库"></a>内网环境创建docker仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">部署docker镜像仓库</span><br><span class="line"></span><br><span class="line">在192.168.80.100上，安装docker服务，拉取镜像</span><br><span class="line"></span><br><span class="line">docker pull registry</span><br><span class="line">导出镜像</span><br><span class="line"></span><br><span class="line">docker save c2a449c9f834 &gt; /root/docker-registry-p_w_picpath.tar</span><br><span class="line">将导出的镜像包发送到目的主机</span><br><span class="line"></span><br><span class="line">scp /root/docker-registry-p_w_picpath.tar root@192.168.80.200:/root/</span><br><span class="line">登录到目的主机，加载镜像</span><br><span class="line"></span><br><span class="line">docker load -i /root/docker-registry-p_w_picpath.tar</span><br><span class="line">加载好镜像后，运行docker registry容器</span><br><span class="line"></span><br><span class="line">mkdir /registry    #创建本地挂载目录</span><br><span class="line">docker run -d -p 5000:5000 -v /registry:/tmp/registry localregistry  #把本地的目录mount到容器/tmp/registry目录下</span><br><span class="line">接下来查看本地docker仓库的容器是否运行</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">以上docker本地仓库就配置完毕</span><br><span class="line"></span><br><span class="line">接下来介绍下docker仓库的镜像上传（隔绝外网的情况下）</span><br><span class="line"></span><br><span class="line">在192.168.80.100上，安装docker服务</span><br><span class="line"></span><br><span class="line">docker pull ubuntu:lastest #默认会去docker.io拉取镜像源</span><br><span class="line">把拉取下来的镜像源改名为docker仓库的ip/端口:版本号</span><br><span class="line"></span><br><span class="line">docker tag ubuntu:lastest 192.168.80.200:5000/ubuntu:lastest</span><br><span class="line">最后上传镜像</span><br><span class="line"></span><br><span class="line">docker push 192.168.80.200:5000/ubuntu:lastest #这样镜像就能上传到本地docker仓库</span><br><span class="line">以上docker本地仓库的镜像上传就完成了</span><br><span class="line"></span><br><span class="line">docker服务和镜像rpm包地址：http://pan.baidu.com/s/1kVOJgR9</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器和镜像的导入、导出"><a href="#Docker容器和镜像的导入、导出" class="headerlink" title="Docker容器和镜像的导入、导出"></a>Docker容器和镜像的导入、导出</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一、镜像导出 save</span><br><span class="line"></span><br><span class="line">查看镜像</span><br><span class="line"></span><br><span class="line">docker images</span><br><span class="line">导出镜像</span><br><span class="line"></span><br><span class="line">docker save -o test.tar image_name</span><br><span class="line">或者</span><br><span class="line">docker save image_name &gt; /test.tar</span><br><span class="line"></span><br><span class="line">二、容器导出 export</span><br><span class="line"></span><br><span class="line">导出容器，命令格式为：</span><br><span class="line"></span><br><span class="line">docker export [-o|--output[=&quot;&quot;]] CONTATINER</span><br><span class="line">或</span><br><span class="line">docker export 容器id/name &gt;文件名.tar</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker export -o test.img test</span><br><span class="line">test.img : 这里可以导出tar文件 ， 也可以导出二进制镜像文件img</span><br><span class="line">test : 需要导出的容器名， 通过docker ps查看</span><br><span class="line"></span><br><span class="line">三、导入压缩包（包括压缩的镜像和容器）</span><br><span class="line"></span><br><span class="line">1.import</span><br><span class="line">docker import [-c|--change[=[]]] [-m|--message[=MESSAGE]] file|URL|-[REPOSITORY[:YAG]]</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">docker import test.img test</span><br><span class="line">test : 为镜像名</span><br><span class="line"></span><br><span class="line">2.load</span><br><span class="line">docker load --input /test.tar</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">docker save保存的是镜像（image），docker export保存的是容器（container）；</span><br><span class="line">docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</span><br><span class="line">docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</span><br><span class="line"></span><br><span class="line">Docker load 之后镜像名字为none问题解决</span><br><span class="line">这个问题是根本在于这个镜像压缩包在打包的时候导致</span><br><span class="line"></span><br><span class="line">例如，以下打包方式将会导致解压的出来的镜像没有名字</span><br><span class="line">docker save -o redis.tar 7864316753</span><br><span class="line">因此，推荐使用镜像的名字进行打包，例如：</span><br><span class="line">docker save -o redis:5.0.2</span><br><span class="line">此方式打包的镜像，解压出来就有镜像名称了</span><br><span class="line"></span><br><span class="line">进一步出现这样错误的原因是在docker load 的时候会将同名image覆盖，并将原有镜像重命名，也就出现了上图所示问题。</span><br><span class="line">另外，附上重命名镜像的方法：</span><br><span class="line">docker tage [镜像id] [新镜像名称]:[新镜像标签]  </span><br><span class="line">docker tag elf…4b reg.emphant.com：5000/python-env：2.7.13</span><br></pre></td></tr></table></figure>

<h2 id="docker-run-命令解释"><a href="#docker-run-命令解释" class="headerlink" title="docker run 命令解释"></a>docker run 命令解释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker run 命令</span><br><span class="line"> Docker 命令大全Docker 命令大全</span><br><span class="line">docker run ：创建一个新的容器并运行一个命令</span><br><span class="line">语法</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-P: 随机端口映射，容器内部端口随机映射到主机的端口</span><br><span class="line">-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name=&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line">--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line">-h &quot;mars&quot;: 指定容器的hostname；</span><br><span class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line">--env-file=[]: 从指定文件读入环境变量；</span><br><span class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；</span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">--link=[]: 添加链接到另一个容器；</span><br><span class="line">--expose=[]: 开放一个端口或一组端口；</span><br><span class="line">--volume , -v: 绑定一个卷</span><br><span class="line">实例</span><br><span class="line">使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line">使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line">使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line">绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span><br><span class="line">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br><span class="line">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span><br><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/# </span><br></pre></td></tr></table></figure>



<h2 id="删除所有已经停止的容器"><a href="#删除所有已经停止的容器" class="headerlink" title="删除所有已经停止的容器"></a>删除所有已经停止的容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">杀死所有正在运行的容器</span><br><span class="line">docker kill $(docker ps -a -q)</span><br><span class="line">删除所有已经停止的容器 docker rmi 并不能定制容器</span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line">删除所有未打 dangling 标签的镜像</span><br><span class="line">docker rmi $(docker images -q -f dangling=true)</span><br><span class="line">删除所有镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line">强制删除镜像名称中包含“doss-api”的镜像</span><br><span class="line">docker rmi --force $(docker images | grep doss-api | awk &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">删除所有未使用数据</span><br><span class="line">docker system prune  </span><br><span class="line">只删除未使用的volumes </span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>

<h3 id="docker容器封装应用的好处"><a href="#docker容器封装应用的好处" class="headerlink" title="docker容器封装应用的好处"></a>docker容器封装应用的好处</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Docker引擎统一基础设别环境 --- docker环境</span><br><span class="line">硬件的配置</span><br><span class="line">操作系统的版本</span><br><span class="line">运行时环境</span><br><span class="line">2.Docker引擎统一程序打包方式 --- docker镜像</span><br><span class="line">java程序</span><br><span class="line">python进程</span><br><span class="line">nodejs程序</span><br><span class="line">...</span><br><span class="line">3.Docker引擎统一程序部署（运行）方式 --- docker容器</span><br><span class="line">java -- jar ---&gt; docker run</span><br><span class="line">python manage.py runserver </span><br><span class="line">npm run dev </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="docker容器封装应用程序的缺点"><a href="#docker容器封装应用程序的缺点" class="headerlink" title="docker容器封装应用程序的缺点"></a>docker容器封装应用程序的缺点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单机使用，无法有效集群</span><br><span class="line">随着容器数量的上升，管理成本攀升</span><br><span class="line">没有有效的容灾、自愈机制</span><br><span class="line">没有预设编排末班，无法实现快速、大规模容器调度</span><br><span class="line">没有统一的配置管理中心工具</span><br><span class="line">没有容器生命周期的管理工具</span><br><span class="line">没哟图形化运维管理工具</span><br><span class="line"></span><br><span class="line">基于Docker容器引擎的开源容器编排工具：Kubernetes(k8s)</span><br></pre></td></tr></table></figure>

<h3 id="kubernetes-优势"><a href="#kubernetes-优势" class="headerlink" title="kubernetes 优势"></a>kubernetes 优势</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动装箱，水平扩展，自我修复</span><br><span class="line">服务发现和负载均衡</span><br><span class="line">自动发布（默认滚动发布模式）和回滚</span><br><span class="line">集中化配置管理和秘钥管理</span><br><span class="line">存储编排</span><br><span class="line">任务处理运行</span><br></pre></td></tr></table></figure>

<h3 id="1-kubernetes-快速入门"><a href="#1-kubernetes-快速入门" class="headerlink" title="1. kubernetes 快速入门"></a>1. kubernetes 快速入门</h3><p>####1.1四组基本概念<br> Pod&#x2F;Pod控制器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pod</span><br><span class="line">Pod 是k8s里能够被运行的最小的逻辑单元（原子单元）</span><br><span class="line">1个Pod里面可以运行多个容器，它们共享UTS+NET+IPC名称空间</span><br><span class="line">可以把Pod理解成豌豆荚，而同一个Pod内的每个容器是一颗颗豌豆</span><br><span class="line">Pod 控制器</span><br><span class="line">Pod控制器是Pod启动的一种模板，用来保证在k8s里启动的Pod应始终按照人们的运行预期（副本数，生命周期，健康检查）</span><br><span class="line">k8s内提供了众多的Pod控制器，常见的有以下集中：</span><br><span class="line"> Deloyment --- 常用</span><br><span class="line"> Deamonset --- 常用</span><br><span class="line"> Replicaset</span><br><span class="line"> Statefulset</span><br><span class="line"> Job</span><br><span class="line"> Cronjob</span><br></pre></td></tr></table></figure>

<p> Name&#x2F;Namespace</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Name:</span><br><span class="line"> 1、由于k8s内部，使用“资源”来定义每一个逻辑概念（功能）每种“资源”，都应该有自己的“名称”</span><br><span class="line"> 2、“资源” 有api版本（apiversion)类别（kind)元数据（metadata)定义清单（spec)状态（status）等配置信息</span><br><span class="line"> 3、“名称” 通常定义在“资源”的“元数据”信息里</span><br><span class="line">Namespace:</span><br><span class="line"> 1、随着项目增多，人员增加，集群规模的扩大，需要一种能够隔离k8s内各种“资源”的方法，这是名称空间</span><br><span class="line"> 2、名称空间可以理解为k8s内部的虚拟集群组</span><br><span class="line"> 3、不同名称空间内的“资源”，名称可以相同，相同名称空间内的同种“资源”，“名称” 不能相同</span><br><span class="line"> 4、合理的使用k8s的名称空间，使得集群管理员能够更好的对交付到k8s里的服务进行分类管理和浏览</span><br><span class="line"> 5、k8s里默认存在的名称空间有：default,kube-system,kube-public</span><br><span class="line"> 6、查询k8s里特定“资源”要带上相应的名称空间</span><br></pre></td></tr></table></figure>

<p>Label&#x2F;Label选择器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Label </span><br><span class="line">  1、标签是k8s特色的管理方式，便于分类管理资源对象</span><br><span class="line">  2、一个标签可以对应多个资源，一个资源可以有多个标签，它们是多对多的关系。</span><br><span class="line">  3、一个资源拥有多个标签，可以实现不同维度的管理。</span><br><span class="line">  4、标签的组成是： key=value</span><br><span class="line">  5、与标签类似的，还是一种“注释” （annotations）</span><br><span class="line">Label选择器</span><br><span class="line">  1、给资源打上标签后，可以使用标签选择器过滤指定的标签</span><br><span class="line">  2、标签选择器目前有两个：基于等值关系（等于，不等于）和基于集合关系（属于、不属于、存在）</span><br><span class="line">  3、许多资源支持内嵌标签选择器字段</span><br><span class="line">     matchLabels</span><br><span class="line">     matchExpresssion</span><br></pre></td></tr></table></figure>

<p>Service&#x2F;Ingress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Service:</span><br><span class="line">	1、在k8s的世界里，虽然每个Pod都会被分配一个单独的IP地址，但是这个IP地址会随着Pod的销毁而消失</span><br><span class="line">	2、Service(服务）就是用来解决这个问题的核心概念</span><br><span class="line">	3、一个Service可以看做一组提供相同服务的Pod的对外访问接口</span><br><span class="line">	4、Service作用于哪些Pod是通过标签选择器来定义的</span><br><span class="line">Ingress </span><br><span class="line">  1、Ingress是k8s集群里工作在OSI网络参考模型下，第7层的应用，对外暴露的接口</span><br><span class="line">  2、service只能进行L4流量调度，表现形式为ip+port</span><br><span class="line">  3、Ingress可以调度不同业务域，不同URL访问路径的业务流量</span><br></pre></td></tr></table></figure>

<h4 id="1-2-核心组件"><a href="#1-2-核心组件" class="headerlink" title="1.2 核心组件"></a>1.2 核心组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置存储中心 ---&gt; etcd服务</span><br><span class="line">主控（master）节点</span><br><span class="line">   kube-apiserver服务</span><br><span class="line">   kube-contoller-manager服务</span><br><span class="line">   kube-scheduler服务</span><br><span class="line">运算（node)节点</span><br><span class="line">   kube-kubelet服务</span><br><span class="line">   kube-proxy服务</span><br><span class="line">cli客户端</span><br><span class="line">   kubectl</span><br><span class="line">核心附件</span><br><span class="line">   CNI网络插件 -&gt; flannel/calico</span><br><span class="line">   服务发现用插件 -&gt; coredns</span><br><span class="line">   服务暴露用插件 -&gt; traefik</span><br><span class="line">   GUI管理插件    -&gt; Dashboard</span><br></pre></td></tr></table></figure>

<h1 id="修改docker容器端口映射的方法"><a href="#修改docker容器端口映射的方法" class="headerlink" title="修改docker容器端口映射的方法"></a>修改docker容器端口映射的方法</h1><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul>
<li>1、停止容器(docker stop d00254ce3af7)</li>
<li>2、停止docker服务(systemctl stop docker)</li>
<li>3、修改这个容器的hostconfig.json文件中的端口（原帖有人提到，如果config.v2.json里面也记录了端口，也要修改）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/lib/docker/containers/d00254ce3af7*     #这里是CONTAINER ID</span><br><span class="line"></span><br><span class="line">vim hostconfig.json</span><br><span class="line">如果之前没有端口映射, 应该有这样的一段:</span><br><span class="line">&quot;PortBindings&quot;:&#123;&#125;</span><br><span class="line"></span><br><span class="line">增加一个映射, 这样写:</span><br><span class="line">&quot;PortBindings&quot;:&#123;&quot;8080/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;60000&quot;&#125;]&#125;</span><br><span class="line">前一个数字是容器端口, 后一个是宿主机端口。将宿主机的60000端口映射到容器的8080端口</span><br><span class="line">而修改现有端口映射更简单, 把端口号改掉就行。</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<ul>
<li>4、启动docker服务(systemctl start docker)</li>
<li>5、启动容器(docker start d00254ce3af7)</li>
</ul>
<p><strong>hostconfig.json文件</strong><br><img src="https://img-blog.csdn.net/20180918143102223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODg2NDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>config.v2.json文件</strong><br><img src="https://img-blog.csdn.net/20180918143114273?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODg2NDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>1、获得容器IP<br>将container_name 换成实际环境中的容器名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect `container_name` | grep IPAddress</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>2、iptable转发端口<br>将宿主机的60000端口映射到容器的8080端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A  DOCKER -p tcp --dport 60000 -j DNAT --to-destination 172.17.0.2:8080</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>postgres 同步/异步流复制详解</title>
    <url>/knowledge-base/2018/08/26/pg-basebackup/</url>
    <content><![CDATA[<div class="note info"><p>PG主备流复制的核心部分由walsender，walreceiver和startup三个进程组成。</p>
<p>walsender进程是用来发送WAL日志记录的<br>walreceiver进程是用来接收WAL日志记录的<br>startup进程是用来apply日志的</p>
</div>

<span id="more"></span>

<h2 id="流复制命令参数详解"><a href="#流复制命令参数详解" class="headerlink" title="流复制命令参数详解"></a>流复制命令参数详解</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_basebackup 命令行参数</span><br><span class="line"> <span class="operator">-</span>D, <span class="comment">--pgdata=DIRECTORY receive base backup into directory</span></span><br><span class="line">    指定把备份写到那个目录，如果这个目录或这个目录路径中的各级父目录不存在，则pg_basebackup就会自动创建这个目录，如果目录存在，但目录不为空，则会导致pg_basebackup执行失败。</span><br><span class="line"><span class="operator">-</span>F, <span class="comment">--format=p|t       output format (plain (default), tar)</span></span><br><span class="line"> <span class="comment">--指定输出格式：</span></span><br><span class="line">   p原样输出，即把主数据库中的各个数据文件，配置文件、目录结构都完全一样的写到备份目录；</span><br><span class="line">   t 把输出的备份文件打包到一个tar文件中。</span><br><span class="line"><span class="operator">-</span>R, <span class="comment">--write-recovery-conf</span></span><br><span class="line">    <span class="comment">-- write recovery.conf after backup</span></span><br><span class="line">     生成recovery.conf文件</span><br><span class="line"><span class="operator">-</span>x, <span class="comment">--xlog   include required WAL files in backup (fetch mode)</span></span><br><span class="line">    备份时会把备份中产生的xlog文件也自动备份出来，这样才能在恢复数据库时，应用这些xlog文件把数据库推到一个一致点，然后真正打开这个备份的数据库，这个选项与 <span class="operator">-</span>X <span class="keyword">fetch</span>是完全一样的。使用这个选项，需要设置&quot;wal_keep_segments&quot;参数，以保证在备份过程中，需要的WAL日志文件不会被覆盖。</span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--progress         show progress information</span></span><br><span class="line">    在备份过程中实时打印备份进度</span><br><span class="line"><span class="operator">-</span>X, <span class="comment">--xlog-method=fetch|stream</span></span><br><span class="line">    xlogdir<span class="operator">=</span>XLOGDIR  location <span class="keyword">for</span> the transaction log directory</span><br><span class="line"><span class="operator">-</span>z, <span class="comment">--gzip             compress tar output </span></span><br><span class="line">    使用gzip压缩，仅能能与tar输出模式配合使用。</span><br><span class="line">实例：</span><br><span class="line">pg_basebackup   <span class="operator">-</span>D backup     <span class="operator">-</span>Ft  <span class="operator">-</span>z <span class="operator">-</span>R <span class="operator">-</span>P </span><br><span class="line">pg_basebackup   <span class="operator">-</span>D backup     <span class="operator">-</span>Fp    <span class="operator">-</span>P </span><br><span class="line">pg_basebackup <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.106</span><span class="number">.128</span> <span class="operator">-</span>p <span class="number">5432</span> <span class="operator">-</span>U postgres <span class="operator">-</span>D $HOME<span class="operator">/</span>data <span class="operator">-</span>Ft <span class="operator">-</span>z <span class="operator">-</span>R <span class="operator">-</span>P</span><br></pre></td></tr></table></figure>
<h2 id="postgresql-主备库archive-mode、archive-command"><a href="#postgresql-主备库archive-mode、archive-command" class="headerlink" title="postgresql 主备库archive_mode、archive_command"></a>postgresql 主备库archive_mode、archive_command</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、在主库,postgresql.conf配置文件配置如下</span><br><span class="line"></span><br><span class="line">      archive_mode=on</span><br><span class="line"></span><br><span class="line">      archive_command =<span class="string">&#x27;cp -i %p /u01/pg9.1/archivelog/%f &lt;/dev/null&#x27;</span></span><br><span class="line"></span><br><span class="line">      主库开启归档模式，归档日志写入/pg9.1/data/pg_xlog目录，archive_command把归档日志复制到/u01/pg9.1/archivelog/</span><br><span class="line"></span><br><span class="line">2、在备库，archive_mode、archive_command是否注销对备库没有任何影响，备库不会加载该配置。</span><br><span class="line"></span><br><span class="line">3、主库归档事务提交后，备库进行相应操作，进行归档，归档日志写入/pg9.1/data/pg_xlog目录，但不执行archive_command命令。</span><br></pre></td></tr></table></figure>

<h2 id="异步流复制"><a href="#异步流复制" class="headerlink" title="异步流复制"></a>异步流复制</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">主数据库配置</span><br><span class="line"><span class="number">1.</span> 主机<span class="number">192.168</span><span class="number">.1</span><span class="number">.202</span></span><br><span class="line"><span class="number">1.1</span> 首先需要配置一个账号进行主从同步。</span><br><span class="line">创建replica用户设置密码，登录和备份权限。</span><br><span class="line"><span class="keyword">CREATE</span> ROLE replica login replication encrypted password <span class="string">&#x27;replica&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span> 修改pg_hba.conf，增加replica用户，进行同步。</span><br><span class="line">host    replication     replica     <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span><span class="operator">/</span><span class="number">24</span>              md5</span><br><span class="line">这样，就设置了replica这个用户可以从<span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span>对应的网段进行流复制请求。</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span> 修改postgresql.conf，注意设置下下面几个地方：</span><br><span class="line">wal_level <span class="operator">=</span> hot_standby   # 这个是设置主为wal的主机</span><br><span class="line">max_wal_senders <span class="operator">=</span> <span class="number">5</span>       # 这个设置了可以最多有几个流复制连接，差不多有几个从，就设置几个</span><br><span class="line">wal_keep_segments <span class="operator">=</span> <span class="number">128</span>   # 设置流复制保留的最多的xlog数目</span><br><span class="line">wal_sender_timeout <span class="operator">=</span> <span class="number">60</span>s  # 设置流复制主机发送数据的超时时间</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">100</span>     # 这个设置要注意下，从库的max_connections必须要大于主库的</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span> 重启主库</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 备数据库配置</span><br><span class="line">主机<span class="number">192.168</span><span class="number">.1</span><span class="number">.203</span></span><br><span class="line"><span class="number">2.1</span> 使用pg_basebackup建备库</span><br><span class="line">pg_basebackup <span class="operator">-</span>F p <span class="comment">--progress -D /home/postgres/data -h 192.168.1.202 -p 5432 -U replica --password</span></span><br><span class="line">这里使用了pg_basebackup这个命令，<span class="operator">/</span>home<span class="operator">/</span>postgres<span class="operator">/</span>data这个目录是空的</span><br><span class="line">成功之后，就可以看到这个目录中现有的文件都是一样的了。</span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> 进入到<span class="operator">/</span>home<span class="operator">/</span>postgres<span class="operator">/</span>data目录，修改recovery.conf，只要修改几个地方就行了</span><br><span class="line">standby_mode <span class="operator">=</span> <span class="keyword">on</span>  # 这个说明这台机器为从库</span><br><span class="line">primary_conninfo <span class="operator">=</span> <span class="string">&#x27;host=192.168.1.202 port=5432 user=replica password=replica&#x27;</span>  # 这个说明这台机器对应主库的信息</span><br><span class="line">recovery_target_timeline <span class="operator">=</span> <span class="string">&#x27;latest&#x27;</span> # 这个说明这个流复制同步到最新的数据</span><br><span class="line"></span><br><span class="line"><span class="number">2.3</span> postgresql.conf中也有几个地方要进行修改</span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">200</span>              # 一般查多于写的应用从库的最大连接数要比较大</span><br><span class="line">hot_standby <span class="operator">=</span> <span class="keyword">on</span>                   # 说明这台机器不仅仅是用于数据归档，也用于数据查询</span><br><span class="line">max_standby_streaming_delay <span class="operator">=</span> <span class="number">30</span>s  # 数据流备份的最大延迟时间</span><br><span class="line">wal_receiver_status_interval <span class="operator">=</span> <span class="number">10</span>s # 多久向主报告一次从的状态，当然从每次数据复制都会向主报告状态，这里只是设置最长的间隔时间</span><br><span class="line">hot_standby_feedback <span class="operator">=</span> <span class="keyword">on</span>          # 如果有错误的数据复制，是否向主进行反馈</span><br><span class="line"></span><br><span class="line"><span class="number">2.4</span> 启动备</span><br><span class="line"></span><br><span class="line">【主库】查看配置结果</span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_stat_replication ;</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">1</span> ]<span class="comment">----+------------------------------</span></span><br><span class="line">pid              <span class="operator">|</span> <span class="number">1793</span></span><br><span class="line">usesysid         <span class="operator">|</span> <span class="number">24576</span></span><br><span class="line">usename          <span class="operator">|</span> replica</span><br><span class="line">application_name <span class="operator">|</span> walreceiver</span><br><span class="line">client_addr      <span class="operator">|</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.203</span></span><br><span class="line">client_hostname  <span class="operator">|</span> </span><br><span class="line">client_port      <span class="operator">|</span> <span class="number">32250</span></span><br><span class="line">backend_start    <span class="operator">|</span> <span class="number">2017</span><span class="number">-09</span><span class="number">-01</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">16.924496</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">backend_xmin     <span class="operator">|</span> <span class="number">1676</span></span><br><span class="line">state            <span class="operator">|</span> streaming</span><br><span class="line">sent_location    <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">60003E0</span></span><br><span class="line">write_location   <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">60003E0</span></span><br><span class="line">flush_location   <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">60003E0</span></span><br><span class="line">replay_location  <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">60003E0</span></span><br><span class="line">sync_priority    <span class="operator">|</span> <span class="number">0</span></span><br><span class="line">sync_state       <span class="operator">|</span> async</span><br></pre></td></tr></table></figure>
<h2 id="异步流复制-1"><a href="#异步流复制-1" class="headerlink" title="异步流复制"></a>异步流复制</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 主数据库配置</span><br><span class="line">主机<span class="number">192.168</span><span class="number">.1</span><span class="number">.202</span></span><br><span class="line"><span class="number">1.1</span> 修改postgresql.conf</span><br><span class="line">synchronous_standby_names <span class="operator">=</span> <span class="string">&#x27;standby01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 备数据库配置</span><br><span class="line">主机<span class="number">192.168</span><span class="number">.1</span><span class="number">.203</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> vi recovery.conf </span><br><span class="line">standby_mode <span class="operator">=</span> <span class="keyword">on</span></span><br><span class="line">primary_conninfo <span class="operator">=</span> <span class="string">&#x27;application_name=standby01 host=192.168.1.202 port=5432 user=replica password=replica&#x27;</span></span><br><span class="line">recovery_target_timeline <span class="operator">=</span> <span class="string">&#x27;latest&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--注意：application_name 名称必须和主库的postgres.conf中的synchronous_standby_names 参数必须一致</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>重启动主备库</span><br><span class="line"></span><br><span class="line">【主库】查看</span><br><span class="line">postgres<span class="operator">=</span># <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_stat_replication ;</span><br><span class="line"><span class="operator">-</span>[ RECORD <span class="number">1</span> ]<span class="comment">----+----------------------------</span></span><br><span class="line">pid              <span class="operator">|</span> <span class="number">1706</span></span><br><span class="line">usesysid         <span class="operator">|</span> <span class="number">24576</span></span><br><span class="line">usename          <span class="operator">|</span> replica</span><br><span class="line">application_name <span class="operator">|</span> standby01</span><br><span class="line">client_addr      <span class="operator">|</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.203</span></span><br><span class="line">client_hostname  <span class="operator">|</span> </span><br><span class="line">client_port      <span class="operator">|</span> <span class="number">59550</span></span><br><span class="line">backend_start    <span class="operator">|</span> <span class="number">2017</span><span class="number">-09</span><span class="number">-01</span> <span class="number">23</span>:<span class="number">36</span>:<span class="number">05.7176</span><span class="operator">+</span><span class="number">08</span></span><br><span class="line">backend_xmin     <span class="operator">|</span> <span class="number">1676</span></span><br><span class="line">state            <span class="operator">|</span> streaming</span><br><span class="line">sent_location    <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">70000</span>D0</span><br><span class="line">write_location   <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">70000</span>D0</span><br><span class="line">flush_location   <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">70000</span>D0</span><br><span class="line">replay_location  <span class="operator">|</span> <span class="number">0</span><span class="operator">/</span><span class="number">70000</span>D0</span><br><span class="line">sync_priority    <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">sync_state       <span class="operator">|</span> sync</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>postgres</category>
      </categories>
  </entry>
  <entry>
    <title>shell 常用命令</title>
    <url>/knowledge-base/2018/08/25/shell-cmd/</url>
    <content><![CDATA[<div class="note primary"><p>记录平时使用频繁的系统命令，例如快速删除日志，修改主机名，修改静态网络。</p>
</div>

<span id="more"></span>

<h3 id="修改目录权限，让view用户可以访问其他用户的内容，没有写的权限。"><a href="#修改目录权限，让view用户可以访问其他用户的内容，没有写的权限。" class="headerlink" title="修改目录权限，让view用户可以访问其他用户的内容，没有写的权限。"></a>修改目录权限，让view用户可以访问其他用户的内容，没有写的权限。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod o+r /app</span><br></pre></td></tr></table></figure>
<h3 id="centos永久关闭防火墙"><a href="#centos永久关闭防火墙" class="headerlink" title="centos永久关闭防火墙"></a>centos永久关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭iptables</span></span><br><span class="line">/etc/init.d/iptables stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">chkconfig iptables off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查</span></span><br><span class="line">chkconfig --list iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭selinux</span></span><br><span class="line">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure>
<h3 id="根据文档内容分组计数"><a href="#根据文档内容分组计数" class="headerlink" title="根据文档内容分组计数"></a>根据文档内容分组计数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat lsof.txt |awk &#x27;&#123;++PID[$2]&#125; END &#123;for(key in PID) print key,&#x27;\t&#x27;,PID[key]&#125;&#x27;|sort -nk 2</span><br></pre></td></tr></table></figure>
<p>查看进程时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -eo comm,lstart|grep server |sort -u |awk -F &quot;:&quot; &#x27;&#123;printf(&quot;%s,%s\n&quot;,$1,$2)&#125;|sort -u</span><br></pre></td></tr></table></figure>

<h3 id="编写shell脚本注意事项"><a href="#编写shell脚本注意事项" class="headerlink" title="编写shell脚本注意事项"></a>编写shell脚本注意事项</h3><p><strong>1.使用readonly和local修饰变量</strong></p>
<p><img src="http://p3.pstatp.com/large/pgc-image/13ccb4e345394a6c9588a654fe40243c" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly</span><br><span class="line">顾名思义，只读。</span><br><span class="line">local</span><br><span class="line">函数内变量。</span><br><span class="line">别图省事，提高安全性的同时，能避免很多让人崩溃的莫名其妙的错误。脚本写得专不专业，往往不是什么高深的点，从基本功绝逼能体现。</span><br><span class="line">画外音：据说，一个C++程序员到什么水平，从ta代码里const的使用频度，能够看出来。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用$()代替&#96;(反单引号)</strong></p>
<p><img src="http://p1.pstatp.com/large/pgc-image/ebd8bf36784640e39c87ebbe8a437015" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么？看了上面的例子你就懂了：</span><br><span class="line">（1）$()能够支持内嵌；</span><br><span class="line">（2）$()不用转义；</span><br><span class="line">（3）有些字体，`(反单引号)和’(单引号)很像，容易把人搞晕；</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用[[]]代替[]</strong></p>
<p>用单中括号：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/246b925610da478d82764b9fbba83d62" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<p>用双中括号：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/b2ca753bc4134899af09c777e495e788" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">看出差别了么？[[]]更符合人性编码：</span><br><span class="line">（1）避免转义问题；</span><br><span class="line">（2）有不少新功能；</span><br><span class="line">新功能包含但不限于：</span><br><span class="line">|| ：逻辑or</span><br><span class="line">&amp;&amp; ：逻辑and</span><br><span class="line">&lt; ：字符串比较（不需要转义）</span><br><span class="line">== ：通配符(globbing)字符串比较</span><br><span class="line">=~ ：正则表达式(regular expression, RegEx)字符串比较</span><br></pre></td></tr></table></figure>

<p><img src="http://p1.pstatp.com/large/pgc-image/0b2b26175ccc48be885c5d699b5983ae" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要注意的是，从bash3.2开始，通配符和正则表达式都不能用引号包裹了（所以，上面的例子，加了引号就是字面比较）。</span><br></pre></td></tr></table></figure>

<p><img src="http://p9.pstatp.com/large/pgc-image/81e677d77bb64aa0b20e9664e2f9caf0" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所以如果表达式里有空格，必须存储到一个变量里，再进行通配符与正则的比较。</span><br></pre></td></tr></table></figure>

<p><strong>4. echo不是唯一的调试方法</strong></p>
<p><img src="http://p3.pstatp.com/large/pgc-image/1a8f88b032ba4c5aac80bfdd5fee0a0c" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以用-n对脚本进行语法检查。</span><br></pre></td></tr></table></figure>

<p><img src="http://p3.pstatp.com/large/pgc-image/9aadbdb6273844ad8f0dc7a0bac66d56" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以用-v跟踪脚本里的每个命令的执行。</span><br></pre></td></tr></table></figure>

<p><img src="http://p3.pstatp.com/large/pgc-image/cd890aaf25094746994343522cc241b1" alt="6条shell小技巧，让脚本显得不再业余（1分钟系列）"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以用-x跟踪脚本里的每个命令的执行，并附加扩充信息。</span><br><span class="line">当然，也可以在脚本里，添加</span><br><span class="line">set -o verbose</span><br><span class="line">set -o xtrace</span><br><span class="line">来永久指定输出调试信息。</span><br></pre></td></tr></table></figure>

<h3 id="awk-打印第2列到最后一列"><a href="#awk-打印第2列到最后一列" class="headerlink" title="awk 打印第2列到最后一列"></a>awk 打印第2列到最后一列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat TB_CUST_INFO.mod |awk -F &quot;|&quot; &#x27;&#123;$1=&quot;&quot;; print $0&#125;&#x27;|sed &#x27;s/ /|/g&#x27;</span><br></pre></td></tr></table></figure>

<p>###传递多个参数脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf  &quot;psc\n psr\n&quot; |  tmadmin </span><br></pre></td></tr></table></figure>

<h3 id="修改用户ID"><a href="#修改用户ID" class="headerlink" title="修改用户ID"></a>修改用户ID</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 修改用户ID</span><br><span class="line">usermod -u 1005 chtars</span><br><span class="line">2. 修改组ID</span><br><span class="line">groupmod -g 1005 chtars</span><br><span class="line">3. 修改组名</span><br><span class="line">groupmod -n 新组名称 原来组名称</span><br></pre></td></tr></table></figure>

<h3 id="查看列数总合"><a href="#查看列数总合" class="headerlink" title="查看列数总合"></a>查看列数总合</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history | awk &#x27;&#123;print $1&#125;&#x27; | awk &#x27;&#123;sum+=$1&#125;END&#123;print sum&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="tar-批量解压"><a href="#tar-批量解压" class="headerlink" title="tar 批量解压"></a>tar 批量解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种：</span><br><span class="line">for tar in *.tar.gz;  do tar xvf $tar; done</span><br><span class="line">for tar in *.tar.bz2; do tar xvf $tar; done</span><br><span class="line"></span><br><span class="line">第二种：用tar命令批量解压某个文件夹下所有的tar.gz文件</span><br><span class="line">ls *.tar.gz | xargs -n1 tar xzvf</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">find -maxdepth 1 -name &quot;*.bz2&quot;|xargs -i tar xvjf &#123;&#125;</span><br><span class="line">这条命令可解压当前目录下的所有bz2文件，maxdepth表示搜索深度，1代表只搜索当前目录</span><br><span class="line"></span><br><span class="line">第四种：</span><br><span class="line">for i in $(ls *.tar);do tar xvf $i;done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Tars脱机安装</title>
    <url>/knowledge-base/2018/08/25/tars-install/</url>
    <content><![CDATA[<div class="note primary"><p>腾讯tars框架安装</p>
</div>


<span id="more"></span>

<h1 id="Tars脱机安装"><a href="#Tars脱机安装" class="headerlink" title="Tars脱机安装"></a>Tars脱机安装</h1><h2 id="一、检查环境"><a href="#一、检查环境" class="headerlink" title="一、检查环境"></a>一、检查环境</h2><p>###1、操作系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统版本：Asianux Server release 7.3.1512 (Lotus) </span><br></pre></td></tr></table></figure>

<h3 id="2、检查基本环境"><a href="#2、检查基本环境" class="headerlink" title="2、检查基本环境"></a>2、检查基本环境</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc 、bison、flex 系统镜像自带可通过系统镜像安装</span><br><span class="line">yum install -y  gcc bison flex</span><br><span class="line">yum install -y ncurses-devel zlib-devel cmake make gcc gcc-c++</span><br><span class="line">yum install -y openssh* openssl*</span><br><span class="line">yum install -y perl*</span><br><span class="line">yum install -y yum-utils psmisc telnet net-tools wget unzip</span><br></pre></td></tr></table></figure>

<h2 id="二、CMAKE安装"><a href="#二、CMAKE安装" class="headerlink" title="二、CMAKE安装"></a>二、CMAKE安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、cd  tars_install/source</span><br><span class="line">2.解压文件tar -xvf cmake-3.19.0-rc1.tar.gz，并修改文件权限chmod -R 777 cmake-3.19.0-rc1.tar.gz</span><br><span class="line">3.进入cmake-3.19.0-rc1.tar.gz 进入命令 cd cmake-3.19.0-rc1.tar.gz</span><br><span class="line"></span><br><span class="line">4.执行sudo ./bootstrap </span><br><span class="line">5.执行sudo make </span><br><span class="line">6.执行 sudo make install </span><br><span class="line">7.执行 cmake –version，返回cmake版本信息，则说明安装成功</span><br><span class="line"></span><br><span class="line">成功！</span><br></pre></td></tr></table></figure>

<h2 id="三、安装MYSQL"><a href="#三、安装MYSQL" class="headerlink" title="三、安装MYSQL"></a>三、安装MYSQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、准备</span><br><span class="line">    创建用户</span><br><span class="line">    usaradd chmap -d /app/chmap</span><br><span class="line">    设置安装目录，切换至root用户</span><br><span class="line">    cd /usr/local</span><br><span class="line">    mkdir mysql-5.6.26</span><br><span class="line">    chown chmap:chmap ./mysql-5.6.26</span><br><span class="line">    ln -s /usr/local/mysql-5.6.26 /usr/local/mysql</span><br><span class="line">2、用utf8的安装方式 下载mysql源码（这里使用的是mysql-5.6.26）,用utf8的安装方式mysql，解压后编译： 下面增加了mysql-5.6.26的安装方式</span><br><span class="line">    cd ~/tars_install/source</span><br><span class="line">    tar -zxvf mysql-5.6.26.tar.gz</span><br><span class="line">    cd mysql-5.6.26</span><br><span class="line">    cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-5.6.26 -DWITH_INNOBASE_STORAGE_ENGINE=1 -       DMYSQL_USER=mysql -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci</span><br><span class="line">    make</span><br><span class="line">    make instal</span><br><span class="line">  ** 注意，对于用Tars的c++进行开发编译的服务，mysql建议采用静态库，源码编译，避免所有服务器都要安装mysql的动态库。</span><br><span class="line">  cd /usr/local/mysql</span><br><span class="line">  useradd mysql</span><br><span class="line">  rm -rf /usr/local/mysql/data</span><br><span class="line">  mkdir -p /data/mysql-data</span><br><span class="line">  ln -s /data/mysql-data /usr/local/mysql/data</span><br><span class="line">  chown -R mysql:mysql /data/mysql-data /usr/local/mysql/data</span><br><span class="line">  cp support-files/mysql.server /etc/init.d/mysql</span><br><span class="line">  perl scripts/mysql_install_db --user=mysql</span><br><span class="line">  **如果/etc/目录下有my.cnf存在，需要把这个配置删除了**</span><br><span class="line">  rm -rf /etc/my.cnf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/mysql/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># Remove leading # and set to the amount of RAM for the most important data</span><br><span class="line"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span><br><span class="line">innodb_buffer_pool_size = 128M</span><br><span class="line"></span><br><span class="line"># Remove leading # to turn on a very important data integrity option: logging</span><br><span class="line"># changes to the binary log between backups.</span><br><span class="line">log_bin</span><br><span class="line"></span><br><span class="line"># These are commonly set, remove the # and set as required.</span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br><span class="line"># port = .....</span><br><span class="line"># server_id = .....</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">bind-address=$&#123;your machine ip&#125;</span><br><span class="line"></span><br><span class="line"># Remove leading # to set options mainly useful for reporting servers.</span><br><span class="line"># The server defaults are faster for transactions and fast SELECTs.</span><br><span class="line"># Adjust sizes as needed, experiment to find the optimal values.</span><br><span class="line">join_buffer_size = 128M</span><br><span class="line">sort_buffer_size = 2M</span><br><span class="line">read_rnd_buffer_size = 2M</span><br><span class="line"></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">#注意将bind-address改为部署机器的IP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动mysql</span><br><span class="line">service mysql start</span><br><span class="line">chkconfig mysql on</span><br><span class="line">结束mysql</span><br><span class="line">service mysql stop</span><br><span class="line">添加mysql的bin路径</span><br><span class="line">vim /etc/profile</span><br><span class="line">PATH=$PATH:/usr/local/mysql/bin</span><br><span class="line">export PATH</span><br><span class="line">修改root密码(采用root密码)</span><br><span class="line">cd /usr/local/mysql</span><br><span class="line">./bin/mysqladmin -u root password &#x27;r00tme&#x27;</span><br><span class="line">./bin/mysqladmin -u root -h $&#123;主机名&#125; password &#x27;r00tme&#x27;</span><br><span class="line">#注意$&#123;主机名&#125;需要修改成自身机器的名称或者IP，可以通过查看/etc/hosts</span><br><span class="line">添加mysql库路径</span><br><span class="line">vim /etc/ld.so.conf</span><br><span class="line">/usr/local/mysql/lib/</span><br><span class="line">ldconfig</span><br><span class="line">mysql主从配置可以参考网上教程</span><br><span class="line">master赋予权限:</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;mysql-sync&#x27;@&#x27;%&#x27; identified by &#x27;sync@appinside&#x27;</span><br><span class="line">slave设置主备同步项</span><br><span class="line">change master to master_host=&#x27;$&#123;备机Ip&#125;&#x27;,master_user=&#x27;mysql-sync&#x27;,master_password=&#x27;sync@appinside&#x27; ,master_log_file=&#x27;iZ94orl0ix4Z-bin.000004&#x27;,master_log_pos=611;</span><br><span class="line">stop slave</span><br><span class="line">start slave</span><br><span class="line">show master status\G;</span><br><span class="line">show slave status\G;</span><br><span class="line">#注意$&#123;备机Ip&#125;需要修改成备机数据库的Ip</span><br></pre></td></tr></table></figure>

<h3 id="四、安装nodejs"><a href="#四、安装nodejs" class="headerlink" title="四、安装nodejs"></a>四、安装nodejs</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/tars_install/source</span><br><span class="line">tar -Jxvf node-v12.19.0-linux-x64.tar.xz</span><br><span class="line">mkdir -p /usr/local/nodejs</span><br><span class="line">cp -r node-v12.19.0-linux-x64 /usr/local/nodejs</span><br><span class="line"> 激活修改</span><br><span class="line">source /etc/profile</span><br><span class="line">#验证</span><br><span class="line"> node -v</span><br><span class="line"> npm -v</span><br><span class="line">#离线安装pm2</span><br><span class="line">	首先在线安装pm2的机器</span><br><span class="line">		执行 npm install pm2 -g 安装pm2</span><br><span class="line">	安装结束，执行 npm config get prefix，获取npm默认全局安装目录NPM_PATH</span><br><span class="line">	cd &#123;NPM_PATH&#125;/lib/node_modules/</span><br><span class="line">	执行tar cvfJ pm2.tar.xz pm2/    ,打包pm2并下载</span><br><span class="line">	登录离线安装机器</span><br><span class="line">	执行 npm config get prefix；获取npm默认全局安装目录NPM_PATH</span><br><span class="line">	cd &#123;NPM_PATH&#125;/lib/node_modules/</span><br><span class="line">	拷贝你的 pm2.tar.xz ;</span><br><span class="line">	tar Jxvf pm2.tar.xz</span><br><span class="line">	#注意文件拥有人、拥有组 （chown -hR 拥有人:拥有组  pm2）</span><br><span class="line">	cd &#123;NPM_PATH&#125;/bin；ln -s &#123;NPM_PATH&#125;/lib/node_modules/pm2/bin/pm2 pm2</span><br><span class="line">	#验证 pm2 list</span><br><span class="line">安装koa</span><br><span class="line">   cd ~/tars_install/source</span><br><span class="line">   tar -zxvf koa.tar.gz </span><br><span class="line">   cp -r koa /usr/local/nodejs/node-v12.19.0-linux-x64/lib/node_modules</span><br></pre></td></tr></table></figure>

<h2 id="五、安装TarsFramework安装"><a href="#五、安装TarsFramework安装" class="headerlink" title="五、安装TarsFramework安装"></a>五、安装TarsFramework安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、编译</span><br><span class="line">cd ~/tars_install/source</span><br><span class="line">tar -zxvf TarsFramework_dy.tar.gz</span><br><span class="line">cd TarsFramework</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">2、安装</span><br><span class="line">切换至root用户，创建安装目录</span><br><span class="line">cd /usr/local</span><br><span class="line">mkdir tars</span><br><span class="line">mkdir app</span><br><span class="line">安装</span><br><span class="line">cd ~/tars_install/source/TarsFramework/build</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、安装tarsweb"><a href="#六、安装tarsweb" class="headerlink" title="六、安装tarsweb"></a>六、安装tarsweb</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 安装过程中, 由于tars-web依赖nodejs, 所以会自动下载nodejs, npm, pm2以及相关的依赖, 并设置好环境变量, 保证nodejs生效</span><br><span class="line">注意:需要完成TarsFramework的编译和安装</span><br><span class="line">cd ~/tars_install/source</span><br><span class="line">tar -zxvf TarsWeb.tar.gz</span><br><span class="line">cp -r TarsWeb web</span><br><span class="line">cp -rf web /usr/local/tars/cpp/deploy/</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进入/usr/local/tars/cpp/deploy, 执行:</span><br><span class="line">chmod a+x linux-install.sh</span><br><span class="line">./linux-install.sh MYSQL_HOST MYSQL_PASSWORD INET REBUILD(false[default]/true) SLAVE(false[default]/true) MYSQL_USER MYSQL_PORT</span><br><span class="line">cd ~/tars_install/source</span><br><span class="line">cp linux-install.sh  /usr/local/tars/cpp/deploy</span><br><span class="line">cd /usr/local/tars/cpp/deploy</span><br><span class="line">chmod 755 linux-install.sh</span><br><span class="line">./linux-install.sh 192.168.182.167 r00tme ens33 true  false root 3306</span><br><span class="line"></span><br><span class="line">安装node_modules</span><br><span class="line">cp -r node_modules </span><br><span class="line">tar -zxvf  node_modules.tar.gz</span><br><span class="line">cp -r node_modules  /usr/local/app/web</span><br><span class="line">启动</span><br><span class="line">  cd /usr/local/app/web; npm run prd </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">   MYSQL_HOST: mysql数据库的ip地址</span><br><span class="line">   MYSQL_PASSWORD: mysql数据库的MYSQL_USER的密码(注意密码不要有太特殊的字符, 例如!, 否则shell脚本识别  有问题, 因为是特殊字符)</span><br><span class="line">   INET: 网卡的名称(ifconfig可以看到, 比如eth0), 表示框架绑定的本机IP, 注意不能是127.0.0.1</span><br><span class="line">   REBUILD: 是否重建数据库,通常为false, 如果中间装出错, 希望重置数据库, 可以设置为true</span><br><span class="line">   SLAVE: 是否是从节点</span><br><span class="line">   MYSQL_USER: mysql用户, 默认是root</span><br><span class="line">   MYSQL_PORT: mysql端口</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tars</category>
      </categories>
      <tags>
        <tag>tars</tag>
      </tags>
  </entry>
  <entry>
    <title>sed命令详细使用</title>
    <url>/knowledge-base/2018/08/25/sed-usage/</url>
    <content><![CDATA[<div class="note warning"><p>sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
</div>

<span id="more"></span>

<h2 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a>sed 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a\ 在当前行下面插入文本。</span><br><span class="line">i\ 在当前行上面插入文本。</span><br><span class="line">c\ 把选定的行改为新的文本。</span><br><span class="line">d 删除，删除选择的行。</span><br><span class="line">D 删除模板块的第一行。</span><br><span class="line">s 替换指定字符</span><br><span class="line">h 拷贝模板块的内容到内存中的缓冲区。</span><br><span class="line">H 追加模板块的内容到内存中的缓冲区。</span><br><span class="line">g 获得内存缓冲区的内容，并替代当前模板块中的文本。</span><br><span class="line">G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。</span><br><span class="line">l 列表不能打印字符的清单。</span><br><span class="line">n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</span><br><span class="line">N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</span><br><span class="line">p 打印模板块的行。</span><br><span class="line">P(大写) 打印模板块的第一行。</span><br><span class="line">q 退出Sed。</span><br><span class="line">b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</span><br><span class="line">r file 从file中读行。</span><br><span class="line">t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span><br><span class="line">T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span><br><span class="line">w file 写并追加模板块到file末尾。  </span><br><span class="line">W file 写并追加模板块的第一行到file末尾。  </span><br><span class="line">! 表示后面的命令对所有没有被选定的行发生作用。  </span><br><span class="line">= 打印当前行号码。  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把注释扩展到下一个换行符以前。</span></span><br></pre></td></tr></table></figure>
<h2 id="sed-替换标记"><a href="#sed-替换标记" class="headerlink" title="sed 替换标记"></a>sed 替换标记</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g 表示行内全面替换。  </span><br><span class="line">p 表示打印行。  </span><br><span class="line">w 表示把行写入一个文件。  </span><br><span class="line">x 表示互换模板块中的文本和缓冲区中的文本。  </span><br><span class="line">y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）</span><br><span class="line">\1 子串匹配标记</span><br><span class="line">&amp; 已匹配字符串标记</span><br></pre></td></tr></table></figure>
<h2 id="sed-元字符集"><a href="#sed-元字符集" class="headerlink" title="sed 元字符集"></a>sed 元字符集</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">匹配行结束，如：/sed$/匹配所有以sed结尾的行。</span></span><br><span class="line">. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</span><br><span class="line">* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</span><br><span class="line">[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  </span><br><span class="line">[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span><br><span class="line">\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。</span><br><span class="line">&amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。</span><br><span class="line">\&lt; 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。</span><br><span class="line">\&gt; 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。</span><br><span class="line">x\&#123;m\&#125; 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。</span><br><span class="line">x\&#123;m,\&#125; 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。</span><br><span class="line">x\&#123;m,n\&#125; 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。</span><br></pre></td></tr></table></figure>
<h2 id="sed-用法实例"><a href="#sed-用法实例" class="headerlink" title="sed 用法实例"></a>sed 用法实例</h2><h3 id="替换操作：s命令"><a href="#替换操作：s命令" class="headerlink" title="替换操作：s命令"></a>替换操作：s命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">替换文本中的字符串：</span><br><span class="line">sed &#x27;s/book/books/&#x27; file</span><br><span class="line"></span><br><span class="line">-n选项和p命令一起使用表示只打印那些发生替换的行：</span><br><span class="line">sed -n &#x27;s/test/TEST/p&#x27; file</span><br><span class="line"></span><br><span class="line">直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books：</span><br><span class="line">sed -i &#x27;s/book/books/g&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="全面替换标记g"><a href="#全面替换标记g" class="headerlink" title="全面替换标记g"></a>全面替换标记g</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用后缀 /g 标记会替换每一行中的所有匹配：</span><br><span class="line"></span><br><span class="line">sed &#x27;s/book/books/g&#x27; file</span><br><span class="line">当需要从第N处匹配开始替换时，可以使用 /Ng：</span><br><span class="line"></span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/2g&#x27;</span><br><span class="line">skSKSKSKSKSK</span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/3g&#x27;</span><br><span class="line">skskSKSKSKSK</span><br><span class="line">echo sksksksksksk | sed &#x27;s/sk/SK/4g&#x27;</span><br><span class="line">skskskSKSKSK</span><br></pre></td></tr></table></figure>

<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符：</span><br><span class="line"></span><br><span class="line">sed &#x27;s:test:TEXT:g&#x27;</span><br><span class="line">sed &#x27;s|test|TEXT|g&#x27;</span><br><span class="line">定界符出现在样式内部时，需要进行转义：</span><br><span class="line"></span><br><span class="line">sed &#x27;s/\/bin/\/usr\/local\/bin/g&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作：d命令"><a href="#删除操作：d命令" class="headerlink" title="删除操作：d命令"></a>删除操作：d命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除空白行：</span><br><span class="line"></span><br><span class="line">sed &#x27;/^$/d&#x27; file</span><br><span class="line">删除文件的第2行：</span><br><span class="line"></span><br><span class="line">sed &#x27;2d&#x27; file</span><br><span class="line">删除文件的第2行到末尾所有行：</span><br><span class="line"></span><br><span class="line">sed &#x27;2,$d&#x27; file</span><br><span class="line">删除文件最后一行：</span><br><span class="line"></span><br><span class="line">sed &#x27;$d&#x27; file</span><br><span class="line">删除文件中所有开头是test的行：</span><br><span class="line"></span><br><span class="line">sed &#x27;/^test/&#x27;d file</span><br></pre></td></tr></table></figure>
<h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">正则表达式 \w\+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</span><br><span class="line"></span><br><span class="line">echo this is a test line | sed &#x27;s/\w\+/[&amp;]/g&#x27;</span><br><span class="line">[this] [is] [a] [test] [line]</span><br><span class="line">所有以192.168.0.1开头的行都会被替换成它自已加localhost：</span><br><span class="line"></span><br><span class="line">sed &#x27;s/^192.168.0.1/&amp;localhost/&#x27; file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</span><br><span class="line"></span><br><span class="line">test=hello</span><br><span class="line">echo hello WORLD | sed &quot;s/$test/HELLO&quot;</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>
<h3 id="选定行的范围：-（逗号）"><a href="#选定行的范围：-（逗号）" class="headerlink" title="选定行的范围：,（逗号）"></a>选定行的范围：,（逗号）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">所有在模板test和check所确定的范围内的行都被打印：</span><br><span class="line"></span><br><span class="line">sed -n &#x27;/test/,/check/p&#x27; file</span><br><span class="line">打印从第5行开始到第一个包含以test开始的行之间的所有行：</span><br><span class="line"></span><br><span class="line">sed -n &#x27;5,/^test/p&#x27; file</span><br><span class="line">对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</span><br><span class="line"></span><br><span class="line">sed &#x27;/test/,/west/s/$/aaa bbb/&#x27; file</span><br></pre></td></tr></table></figure>
<h3 id="多点编辑：e命令"><a href="#多点编辑：e命令" class="headerlink" title="多点编辑：e命令"></a>多点编辑：e命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e选项允许在同一行里执行多条命令：</span><br><span class="line"></span><br><span class="line">sed -e &#x27;1,5d&#x27; -e &#x27;s/test/check/&#x27; file</span><br><span class="line">上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</span><br></pre></td></tr></table></figure>
<p>###从文件读入：r命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面：</span><br><span class="line"></span><br><span class="line">sed &#x27;/test/r file&#x27; filename</span><br><span class="line">写入文件：w命令  </span><br><span class="line">在example中所有包含test的行都被写入file里：</span><br><span class="line"></span><br><span class="line">sed -n &#x27;/test/w file&#x27; example</span><br><span class="line">追加（行下）：a\命令</span><br><span class="line">将 this is a test line 追加到 以test 开头的行后面：</span><br><span class="line"></span><br><span class="line">sed &#x27;/^test/a\this is a test line&#x27; file</span><br><span class="line">在 test.conf 文件第2行之后插入 this is a test line：</span><br><span class="line"></span><br><span class="line">sed -i &#x27;2a\this is a test line&#x27; test.conf</span><br><span class="line">插入（行上）：i\命令</span><br><span class="line">将 this is a test line 追加到以test开头的行前面：</span><br><span class="line"></span><br><span class="line">sed &#x27;/^test/i\this is a test line&#x27; file</span><br><span class="line">在test.conf文件第5行之前插入this is a test line：</span><br><span class="line"></span><br><span class="line">sed -i &#x27;5i\this is a test line&#x27; test.conf</span><br></pre></td></tr></table></figure>
<h3 id="下一个：n命令"><a href="#下一个：n命令" class="headerlink" title="下一个：n命令"></a>下一个：n命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续：</span><br><span class="line"></span><br><span class="line">sed &#x27;/test/&#123; n; s/aa/bb/; &#125;&#x27; file</span><br><span class="line">变形：y命令</span><br><span class="line">把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：</span><br><span class="line"></span><br><span class="line">sed &#x27;1,10y/abcde/ABCDE/&#x27; file</span><br><span class="line">退出：q命令</span><br><span class="line">打印完第10行后，退出sed</span><br><span class="line"></span><br><span class="line">sed &#x27;10q&#x27; file</span><br></pre></td></tr></table></figure>
<h3 id="保持和获取：h命令和G命令"><a href="#保持和获取：h命令和G命令" class="headerlink" title="保持和获取：h命令和G命令"></a>保持和获取：h命令和G命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。</span><br><span class="line"></span><br><span class="line">sed -e &#x27;/test/h&#x27; -e &#x27;$G&#x27; file</span><br><span class="line">在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。</span><br></pre></td></tr></table></figure>

<h3 id="保持和互换：h命令和x命令"><a href="#保持和互换：h命令和x命令" class="headerlink" title="保持和互换：h命令和x命令"></a>保持和互换：h命令和x命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换：</span><br><span class="line"></span><br><span class="line">sed -e &#x27;/test/h&#x27; -e &#x27;/check/x&#x27; file</span><br></pre></td></tr></table></figure>

<h3 id="打印奇数行或偶数行"><a href="#打印奇数行或偶数行" class="headerlink" title="打印奇数行或偶数行"></a>打印奇数行或偶数行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法1：</span><br><span class="line"></span><br><span class="line">sed -n &#x27;p;n&#x27; test.txt  #奇数行</span><br><span class="line">sed -n &#x27;n;p&#x27; test.txt  #偶数行</span><br><span class="line">方法2：</span><br><span class="line"></span><br><span class="line">sed -n &#x27;1~2p&#x27; test.txt  #奇数行</span><br><span class="line">sed -n &#x27;2~2p&#x27; test.txt  #偶数行</span><br></pre></td></tr></table></figure>
<h3 id="打印匹配字符串的下一行"><a href="#打印匹配字符串的下一行" class="headerlink" title="打印匹配字符串的下一行"></a>打印匹配字符串的下一行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -A 1 SCC URFILE</span><br><span class="line">sed -n &#x27;/SCC/&#123;n;p&#125;&#x27; URFILE</span><br><span class="line">awk &#x27;/SCC/&#123;getline; print&#125;&#x27; URFILE</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>pg-install</title>
    <url>/knowledge-base/2018/08/25/pg-install/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ansible常用命令</title>
    <url>/knowledge-base/2018/05/27/ansible-cmd/</url>
    <content><![CDATA[<div class="note primary"><p>本文主要介绍ansible的主机组配置，简单阐述ansible常用模块的使用方法，设计到的模块有ping，shell，command，script，file，fetch等内容。</p>
</div>
<span id="more"></span>
<h2 id="1-ansible主机清单的配置"><a href="#1-ansible主机清单的配置" class="headerlink" title="1. ansible主机清单的配置"></a>1. ansible主机清单的配置</h2><p><strong>vim &#x2F;etc&#x2F;ansible&#x2F;hosts</strong></p>
<p><strong>定义方式：</strong></p>
<p>直接指明主机地址或主机名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blue.example.com</span><br><span class="line">192.168.100.1</span><br></pre></td></tr></table></figure>

<p>定义一个主机组<code>[组名]</code>把地址或主机名加进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">alpha.example.org</span><br><span class="line">beta.example.org</span><br><span class="line">192.168.1.100</span><br><span class="line"></span><br><span class="line">#组成员可以使用通配符来匹配，如下</span><br><span class="line">www[001:006].example.com  #表示从www001-www006主机</span><br></pre></td></tr></table></figure>

<p>  嵌套</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[webservers]</span><br><span class="line">192.168.3.49 ansible_ssh_user=chdb ansible_ssh_pass=HF*cb303</span><br><span class="line">[dbservers]</span><br><span class="line">192.168.3.62</span><br><span class="line">[wolf:children]</span><br><span class="line">webservers</span><br><span class="line">dbservers</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你没有使用公钥，想要使用密码，你也可以这样写（适用于第一次登陆控制）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：【主机名】 【主机地址】 【主机密码】  默认是root用户来进行的</span><br><span class="line">[keepalived]</span><br><span class="line">keepalived1  ansible_ssh_host=192.168.146.136  ansible_ssh_user=chdb ansible_ssh_pass=&quot;test&quot;</span><br><span class="line">keepalived2  ansible_ssh_host=192.168.146.137 ansible_ssh_pass=&quot;test&quot;</span><br></pre></td></tr></table></figure>


<h2 id="2-ansible的使用ansible-doc"><a href="#2-ansible的使用ansible-doc" class="headerlink" title="2. ansible的使用ansible-doc"></a>2. ansible的使用<code>ansible-doc</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一般用法:</span><br><span class="line">ansible-doc -l 获取模块信息</span><br><span class="line">ansible-doc -s MOD_NAME 获取指定模块的使用帮助</span><br></pre></td></tr></table></figure>

<h2 id="3-ansible使用-“命令管理方式”"><a href="#3-ansible使用-“命令管理方式”" class="headerlink" title="3. ansible使用  “命令管理方式”"></a>3. ansible使用  “命令管理方式”</h2><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>ping：探测目标主机是否存活；</strong></p>
<p>ping模块主要是无意义的测试模块，主要用来检查ansible是否可以用的模块以及python是否配置好的，在playbook中基本不会使用，在能成功连接之后，总是返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ansibleserver ~]# ansible all -m ping</span><br><span class="line">SSH password:</span><br><span class="line">ansiblemoniter | success &gt;&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><strong>command：在远程主机执行命令；不支持|管道命令</strong></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible storm_cluster(用户组) -m command -a &quot;ls –al /tmp/resolv.conf&quot;</span><br></pre></td></tr></table></figure>

<p><strong>ansible 批量创建用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible chmap   -m shell -a &quot;useradd -m chdb -d /app/chdb&quot;</span><br><span class="line">修改密码:</span><br><span class="line">ansible chmap   -m shell -a &quot;echo &#x27;chmap&#x27;  |passwd  chmap   --stdin&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关选项如下：</span><br><span class="line">creates：一个文件名，当该文件存在，则该命令不执行</span><br><span class="line">free_form：要执行的linux指令</span><br><span class="line">chdir：在执行指令之前，先切换到该目录</span><br><span class="line">removes：一个文件名，当该文件不存在，则该选项不执行</span><br><span class="line">executable：切换shell来执行指令，该执行路径必须是一个绝对路径</span><br></pre></td></tr></table></figure>

<p><strong>shell：在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等 ；</strong></p>
<p>注意：command和shell模块的核心参数直接为命令本身；而其它模块的参数通常为“key&#x3D;value”格式；</p>
<p><strong>ansible 批量创建用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible chmap   -m shell -a &quot;useradd -m chdb -d /app/chdb&quot;</span><br><span class="line">修改密码:</span><br><span class="line">ansible chmap   -m shell -a &quot;echo &#x27;chmap&#x27;  |passwd  chmap   --stdin&quot;</span><br></pre></td></tr></table></figure>

<p><strong>shell：在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等 ；</strong></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><strong>copy：复制文件到远程主机，可以改权限等</strong></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用法：</span><br><span class="line">(1) 复制文件</span><br><span class="line">    -a &quot;src=  dest=  &quot;</span><br><span class="line">(2) 给定内容生成文件</span><br><span class="line">    -a &quot;content=  dest=  &quot;</span><br><span class="line"> 例如:</span><br><span class="line"> ansible all -m copy -a &quot;src=/etc/fstab dest=/tmp/asnbiblecopy mode=640 backup=yes&quot; </span><br><span class="line">  ansible all -m copy -a &quot;content=&#x27;hello\nworld&#x27; dest=/tmp/asnbiblecopy mode=640 backup=yes&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 相关选项如下：</span><br><span class="line">backup：在覆盖之前，将源文件备份，备份文件包含时间信息。有两个选项：yes|no</span><br><span class="line">content：用于替代“src”，可以直接设定指定文件的值</span><br><span class="line">dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录</span><br><span class="line">directory_mode：递归设定目录的权限，默认为系统默认权限</span><br><span class="line">force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</span><br><span class="line">others：所有的file模块里的选项都可以在这里使用</span><br><span class="line">src：被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用“/”来结尾，则只复制目录里的内容，如果没有使用“/”来结尾，则包含目录在内的整个内容全部复制，类似于rsync。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>file ：设置文件属性。</strong></p>
<p><strong>设置文件属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m file -a &quot;path=/root/123 owner=kel group=kel mode=0644&quot;</span><br></pre></td></tr></table></figure>

<p>文件路径为path，表示文件路径，设定所属用户和所属用户组，权限为0644</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m file -a &quot;path=/tmp/kel/ owner=kel group=kel mode=0644 recurse=yes&quot;</span><br></pre></td></tr></table></figure>

<p>文件路径为path，使用文件夹进行递归修改权限，使用的参数为recurse表示为递归</p>
<p><strong>创建目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m file -a &quot;path=/tmp/kel state=directory mode=0755&quot;</span><br></pre></td></tr></table></figure>

<p>创建目录，使用的参数主要是state为directory</p>
<p><strong>修改权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m file -a &quot;path=/tmp/kel mode=0444&quot;</span><br></pre></td></tr></table></figure>

<p>直接使用mode来进行修改权限</p>
<p><strong>创建软连接</strong> 	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m file -a &quot;src=/tmp/1 dest=/tmp/2 owner=kel state=link&quot;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>fetch：</strong> 从远程某一个主机获取文件到本地</p>
<p>文件拉取模块主要是将远程主机中的文件拷贝到本机中，和copy模块的作用刚刚相反，并且在保存的时候使用hostname来进行保存，当文件不存在的时候，会出现错误，除非设置了选项fail_on_missing为yes</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m fetch -a &quot;src=/root/123 dest=/root&quot;</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;dest&quot;: &quot;/root/192.168.1.60/root/123&quot;,</span><br><span class="line">    &quot;md5sum&quot;: &quot;31be5a34915d52fe0a433d9278e99cac&quot;,</span><br><span class="line">    &quot;remote_md5sum&quot;: &quot;31be5a34915d52fe0a433d9278e99cac&quot;</span><br><span class="line">&#125;</span><br><span class="line">src表示为远程主机上需要传送的文件路径，dest表示为本机上的路径，在传送过来的文件，是按照IP地址进行分类，然后路径是源文件的路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在拉取文件的时候，必须拉取的是文件，不能拉取文件夹</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>hostname: 修改主机名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@ansibleserver ~]# ansible pythonserver -m hostname -a &quot;name=python&quot;</span><br><span class="line">SSH password:</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;name&quot;: &quot;python&quot;</span><br><span class="line">&#125;</span><br><span class="line">在查看的时候，主要查看文件/etc/sysconfig/network，重启之后才能生效</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><strong>cron: 管理cron计划任务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- a &quot;&quot;: 设置管理节点生成定时任务</span><br><span class="line">action: cron</span><br><span class="line">backup=    # 如果设置，创建一个crontab备份</span><br><span class="line">cron_file=          #如果指定, 使用这个文件cron.d，而不是单个用户crontab</span><br><span class="line">day=       # 日应该运行的工作( 1-31, *, */2, etc )</span><br><span class="line">hour=      # 小时 ( 0-23, *, */2, etc )</span><br><span class="line">job=       #指明运行的命令是什么</span><br><span class="line">minute=    #分钟( 0-59, *, */2, etc )</span><br><span class="line">month=     # 月( 1-12, *, */2, etc )</span><br><span class="line">name=     #定时任务描述</span><br><span class="line">reboot    # 任务在重启时运行，不建议使用，建议使用special_time</span><br><span class="line">special_time       # 特殊的时间范围，参数：reboot（重启时）,annually（每年）,monthly（每月）,weekly（每周）,daily（每天）,hourly（每小时）</span><br><span class="line"></span><br><span class="line">state        #指定状态，prsent表示添加定时任务，也是默认设置，absent表示删除定时任务</span><br><span class="line"></span><br><span class="line">user         # 以哪个用户的身份执行</span><br><span class="line">weekday      # 周 ( 0-6 for Sunday-Saturday, *, etc )</span><br><span class="line"></span><br><span class="line">新增一个任务，每五分钟执行一次，任务名称为check</span><br><span class="line">ansible pythonserver -m cron -a &quot;name=check minute=5 job=&#x27;crontab -l &gt;&gt;/root/123&#x27;&quot;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">删除定时任务</span><br><span class="line">ansible pythonserver -m cron -a &quot;name=check state=absent&quot;</span><br><span class="line">SSH password:</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;jobs&quot;: []</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------	-------------------------</span><br><span class="line">新建一个cron文件</span><br><span class="line">ansible pythonserver -m cron -a &quot;name=&#x27;for test&#x27; weekday=&#x27;2&#x27; minute=&#x27;0&#x27; hour=12 user=&#x27;root&#x27; job=&#x27;cat /etc/passwd &gt;/root/111&#x27; cron_file=&#x27;test ansible&#x27;&quot;</span><br><span class="line">新增一个任务，在目录/etc/cron.d/目录中，文件名称为test ansible，用户为root</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">删除一个cron文件</span><br><span class="line">ansible pythonserver -m cron -a &quot;name=&#x27;for test&#x27; cron_file=&#x27;test ansible&#x27; state=absent&quot;</span><br><span class="line">SSH password:</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: true,</span><br><span class="line">    &quot;cron_file&quot;: &quot;test ansible&quot;,</span><br><span class="line">    &quot;jobs&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><strong>收集fact并且进行保存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible pythonserver -m setup --tree /tmp/facts</span><br></pre></td></tr></table></figure>

<p>执行之后，会显示相关的fact，并且在&#x2F;tmp&#x2F;facts中会保存fact信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ansibleserver tmp]# ls -l /tmp/facts/</span><br><span class="line">total 12-rw-r--r-- 1 root root 8990 Jan 18 13:16 192.168.1.60</span><br></pre></td></tr></table></figure>

<p>使用–tree选项，在分类的时候，会根据主机的名称进行分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">收集内存信息并输出</span><br><span class="line">ansible 20.200.21.22 -m setup  -a &quot;filter=ansible*mb&quot; -u chmap</span><br><span class="line">SSH password:</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;ansible_memfree_mb&quot;: 746,</span><br><span class="line">        &quot;ansible_memtotal_mb&quot;: 996,</span><br><span class="line">        &quot;ansible_swapfree_mb&quot;: 2015,</span><br><span class="line">        &quot;ansible_swaptotal_mb&quot;: 2015</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">收集主机网卡信息</span><br><span class="line">[root@ansibleserver tmp]# ansible pythonserver -m setup -a &quot;filter=ansible_eth[02]&quot;</span><br><span class="line">SSH password:</span><br><span class="line">192.168.1.60 | success &gt;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;ansible_eth0&quot;: &#123;</span><br><span class="line">            &quot;active&quot;: true,</span><br><span class="line">            &quot;device&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;ipv4&quot;: &#123;</span><br><span class="line">                &quot;address&quot;: &quot;192.168.1.60&quot;,</span><br><span class="line">                &quot;netmask&quot;: &quot;255.255.255.0&quot;,</span><br><span class="line">                &quot;network&quot;: &quot;192.168.1.0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;ipv6&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;address&quot;: &quot;fe80::a00:27ff:fee5:e8a8&quot;,</span><br><span class="line">                    &quot;prefix&quot;: &quot;64&quot;,</span><br><span class="line">                    &quot;scope&quot;: &quot;link&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;macaddress&quot;: &quot;08:00:27:e5:e8:a8&quot;,</span><br><span class="line">            &quot;module&quot;: &quot;e1000&quot;,</span><br><span class="line">            &quot;mtu&quot;: 1500,</span><br><span class="line">            &quot;promisc&quot;: false,</span><br><span class="line">            &quot;type&quot;: &quot;ether&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false</span><br><span class="line">&#125;</span><br><span class="line">收集可用的facts,收集每个节点的相关信息：架构信息，IP,时间，域名，网卡，MAC，主机名，CPU等信息。</span><br><span class="line">这些收集的信息，可以作为变量。</span><br></pre></td></tr></table></figure>

<p><strong>在远程主机执行本地脚本：script</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible erp -m script -a &#x27;/tmp/a.sh&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习笔记</title>
    <url>/knowledge-base/2021/10/04/go-study/</url>
    <content><![CDATA[<div class="note primary"><p>相关Go语言学习笔记</p>
</div>
<span id="more"></span>

<h2 id="Go-rabbitmq组件断链重连机制"><a href="#Go-rabbitmq组件断链重连机制" class="headerlink" title="Go rabbitmq组件断链重连机制"></a>Go rabbitmq组件断链重连机制</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案一：</span><br><span class="line">Rabbitmq在启动时，为rabbitmq设置一个status，在第一次建立连接的时候将其变为true，rabbitmq client在初始化时启动一个定时器，每隔一段时间开启一个线程，查询当前status的状态，如果status变为false，重新建立连接（包括connection、channel的连接）。</span><br><span class="line"></span><br><span class="line">方案二：</span><br><span class="line">Implement shutdown listener，如果rabbitmq断线，在shutdown方法执行相应的重连方法。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/knowledge-base/2022/09/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="built_in">ls</span> -lart</span><br><span class="line">find . -name  <span class="string">&quot;*c&quot;</span>|xargs grep int</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>React配置label报错，package.json和.babelrc出现冲突</title>
    <url>/knowledge-base/2019/08/20/labelerr/</url>
    <content><![CDATA[<div class="note warning"><p>Error: Multiple configuration files found. Please remove one: – package.json#babel – .babelrc</p>
</div>

<span id="more"></span>	

<h4 id="react报错如下："><a href="#react报错如下：" class="headerlink" title="react报错如下："></a>react报错如下：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Multiple configuration files found. Please remove one:</span><br><span class="line"> - package.json#babel</span><br><span class="line"> - .babelrc</span><br></pre></td></tr></table></figure>

<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果出现以上错误，就是 babel 的配置出现了重复，检查一下根目录的.<span class="property">babelrc</span>和package.<span class="property">json</span>中的babel配置出现了两份，删除一份即可。</span><br><span class="line">查看package.<span class="property">json</span>，是否存在代码，如果有删除</span><br><span class="line">   <span class="string">&quot;babel&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">       <span class="string">&quot;react-app&quot;</span></span><br><span class="line">     ]</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> <span class="regexp">/Users/</span>zhaodong/python/oms_web/file/hosts/versions/<span class="number">20190821</span><span class="comment">/*.war</span></span><br><span class="line"><span class="comment"> /Users/zhaodong/python/oms_web/file/versions/20190821</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
